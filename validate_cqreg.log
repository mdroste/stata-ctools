
  ___  ____  ____  ____  ____ ®
 /__    /   ____/   /   ____/      StataNow 18.5
___/   /   /___/   /   /___/       MP—Parallel Edition

 Statistics and Data Science       Copyright 1985-2023 StataCorp LLC
                                   StataCorp
                                   4905 Lakeway Drive
                                   College Station, Texas 77845 USA
                                   800-782-8272        https://www.stata.com
                                   979-696-4600        service@stata.com

Stata license: Unlimited-user 16-core network, expiring  2 Jul 2026
Serial number: 501909320077
  Licensed to: Michael Droste
               Stanford University GSB

Notes:
      1. Stata is running in batch mode.
      2. Unicode is supported; see help unicode_advice.
      3. More than 2 billion observations are allowed; see help obs_advice.
      4. Maximum number of variables is set to 5,000 but can be increased;
          see help set_maxvar.


Running /Users/Mike/Documents/Stata/profile.do ...

. do validation/validate_cqreg.do 

. /****************************************************************************
> ***
>  * validate_cqreg.do
>  *
>  * Comprehensive validation tests for cqreg vs qreg
>  * Tests quantile regression across various scenarios
>  *
>  * Note: Coefficients and standard errors are compared with tolerance 1e-6
>  * due to floating-point precision differences in complex optimization
>  ****************************************************************************
> **/
. 
. do "validation/validate_setup.do"

. *============================================================================
> ===
. * PROGRAM: validate_setup.do
. * PURPOSE: Helper programs for validation
. *============================================================================
> ===
. 
. version 14.0

. clear all

. set more off

. set trace off

. 
. * Add build directory with ctools to adopath
. adopath + "../build"
  [1]  (BASE)      "/Applications/Stata/ado/base/"
  [2]  (SITE)      "/Applications/Stata/ado/site/"
  [3]              "."
  [4]  (PERSONAL)  "/Users/Mike/Documents/Stata/ado/personal/"
  [5]  (PLUS)      "/Users/Mike/Library/Application Support/Stata/ado/plus/"
  [6]  (OLDPLACE)  "~/ado/"
  [7]              "../build"

. 
. * Global counters
. global TESTS_PASSED = 0

. global TESTS_FAILED = 0

. global TESTS_TOTAL = 0

. 
. *----------------------------------------------------------------------------
> ---
. * Helper program to compare scalars with tolerance
. *----------------------------------------------------------------------------
> ---
. 
. capture program drop assert_scalar_equal

. program define assert_scalar_equal
  1.     args name val1 val2 tol testname
  2. 
.     if "`tol'" == "" local tol = 1e-6
  3. 
.     global TESTS_TOTAL = $TESTS_TOTAL + 1
  4. 
.     local diff = abs(`val1' - `val2')
  5.     * Handle exact match case (for integers like N)
.     if `diff' == 0 | `diff' < `tol' {
  6.         global TESTS_PASSED = $TESTS_PASSED + 1
  7.         di as result "  PASS: `testname' (`name' diff = " %12.2e `diff' ")
> "
  8.     }
  9.     else {
 10.         global TESTS_FAILED = $TESTS_FAILED + 1
 11.         di as error "  FAIL: `testname' (`name': `val1' vs `val2', diff = 
> " %12.2e `diff' ")"
 12.     }
 13. end

. 
. *----------------------------------------------------------------------------
> ---
. * Helper program to compare matrices
. *----------------------------------------------------------------------------
> ---
. 
. capture program drop assert_matrix_equal

. program define assert_matrix_equal
  1.     args mat1 mat2 tol testname
  2. 
.     if "`tol'" == "" local tol = 1e-6
  3. 
.     global TESTS_TOTAL = $TESTS_TOTAL + 1
  4. 
.     tempname diff
  5.     matrix `diff' = `mat1' - `mat2'
  6.     local maxdiff = 0
  7.     local rows = rowsof(`diff')
  8.     local cols = colsof(`diff')
  9.     forvalues i = 1/`rows' {
 10.         forvalues j = 1/`cols' {
 11.             local d = abs(`diff'[`i', `j'])
 12.             if `d' > `maxdiff' local maxdiff = `d'
 13.         }
 14.     }
 15. 
.     if `maxdiff' < `tol' {
 16.         global TESTS_PASSED = $TESTS_PASSED + 1
 17.         di as result "  PASS: `testname' (max diff = " %12.2e `maxdiff' ")
> "
 18.     }
 19.     else {
 20.         global TESTS_FAILED = $TESTS_FAILED + 1
 21.         di as error "  FAIL: `testname' (max diff = " %12.2e `maxdiff' ")"
 22.     }
 23. end

. 
. *----------------------------------------------------------------------------
> ---
. * Helper program to compare variables
. *----------------------------------------------------------------------------
> ---
. 
. capture program drop assert_var_equal

. program define assert_var_equal
  1.     args var1 var2 tol testname
  2. 
.     if "`tol'" == "" local tol = 1e-10
  3. 
.     global TESTS_TOTAL = $TESTS_TOTAL + 1
  4. 
.     quietly count if abs(`var1' - `var2') > `tol'
  5.     local ndiff = r(N)
  6. 
.     if `ndiff' == 0 {
  7.         global TESTS_PASSED = $TESTS_PASSED + 1
  8.         di as result "  PASS: `testname' (all values match)"
  9.     }
 10.     else {
 11.         global TESTS_FAILED = $TESTS_FAILED + 1
 12.         di as error "  FAIL: `testname' (`ndiff' values differ)"
 13.     }
 14. end

. 
. *----------------------------------------------------------------------------
> ---
. * Helper program to compare string variables
. *----------------------------------------------------------------------------
> ---
. 
. capture program drop assert_strvar_equal

. program define assert_strvar_equal
  1.     args var1 var2 testname
  2. 
.     global TESTS_TOTAL = $TESTS_TOTAL + 1
  3. 
.     quietly count if `var1' != `var2'
  4.     local ndiff = r(N)
  5. 
.     if `ndiff' == 0 {
  6.         global TESTS_PASSED = $TESTS_PASSED + 1
  7.         di as result "  PASS: `testname' (all values match)"
  8.     }
  9.     else {
 10.         global TESTS_FAILED = $TESTS_FAILED + 1
 11.         di as error "  FAIL: `testname' (`ndiff' values differ)"
 12.     }
 13. end

. 
. *----------------------------------------------------------------------------
> ---
. * Helper to check if two datasets are identical (with fallback to sorted comp
> arison)
. 
. *----------------------------------------------------------------------------
> ---
. 
. capture program drop assert_data_equal

. program define assert_data_equal
  1.     args file1 file2 testname
  2. 
.     global TESTS_TOTAL = $TESTS_TOTAL + 1
  3. 
.     preserve
  4.     capture quietly {
  5.         use "`file1'", clear
  6.         cf _all using "`file2'"
  7.     }
  8.     local rc = _rc
  9.     restore
 10. 
.     if `rc' == 0 {
 11.         global TESTS_PASSED = $TESTS_PASSED + 1
 12.         di as result "  PASS: `testname' (datasets identical)"
 13.     }
 14.     else {
 15.         * Try sorting both datasets by all variables before comparing
.         preserve
 16.         capture quietly {
 17.             use "`file1'", clear
 18.             ds
 19.             local allvars `r(varlist)'
 20.             sort `allvars'
 21.             tempfile sorted1
 22.             save `sorted1', replace
 23. 
.             use "`file2'", clear
 24.             sort `allvars'
 25.             cf _all using `sorted1'
 26.         }
 27.         local rc2 = _rc
 28.         restore
 29. 
.         if `rc2' == 0 {
 30.             global TESTS_PASSED = $TESTS_PASSED + 1
 31.             di as result "  PASS: `testname' (datasets identical after sor
> ting)"
 32.         }
 33.         else {
 34.             global TESTS_FAILED = $TESTS_FAILED + 1
 35.             di as error "  FAIL: `testname' (datasets differ even after so
> rting)"
 36.         }
 37.     }
 38. end

. 
. *----------------------------------------------------------------------------
> ---
. * Helper to compare datasets after sorting (merges where row order may differ
> )
. *----------------------------------------------------------------------------
> ---
. 
. capture program drop assert_data_equal_sorted

. program define assert_data_equal_sorted
  1.     args file1 file2 sortkey testname
  2. 
.     global TESTS_TOTAL = $TESTS_TOTAL + 1
  3. 
.     preserve
  4.     quietly {
  5.         * Load and sort first file
.         use "`file1'", clear
  6.         sort `sortkey', stable
  7.         tempfile sorted1
  8.         save `sorted1'
  9. 
.         * Load and sort second file
.         use "`file2'", clear
 10.         sort `sortkey', stable
 11.         tempfile sorted2
 12.         save `sorted2'
 13. 
.         * Compare
.         use `sorted1', clear
 14.         cf _all using `sorted2'
 15.     }
 16.     local rc = _rc
 17.     restore
 18. 
.     if `rc' == 0 {
 19.         global TESTS_PASSED = $TESTS_PASSED + 1
 20.         di as result "  PASS: `testname' (datasets identical after sorting
> )"
 21.     }
 22.     else {
 23.         global TESTS_FAILED = $TESTS_FAILED + 1
 24.         di as error "  FAIL: `testname' (datasets differ even after sortin
> g)"
 25.     }
 26. end

. 
. *----------------------------------------------------------------------------
> ---
. * Helper to compare merge counts (merges where row order may differ)
. *----------------------------------------------------------------------------
> ---
. 
. capture program drop assert_merge_counts_equal

. program define assert_merge_counts_equal
  1.     args file1 file2 testname
  2. 
.     global TESTS_TOTAL = $TESTS_TOTAL + 1
  3. 
.     preserve
  4.     quietly {
  5.         use "`file1'", clear
  6.         local n1 = _N
  7.         count if _merge == 1
  8.         local m1_1 = r(N)
  9.         count if _merge == 2
 10.         local m1_2 = r(N)
 11.         count if _merge == 3
 12.         local m1_3 = r(N)
 13. 
.         use "`file2'", clear
 14.         local n2 = _N
 15.         count if _merge == 1
 16.         local m2_1 = r(N)
 17.         count if _merge == 2
 18.         local m2_2 = r(N)
 19.         count if _merge == 3
 20.         local m2_3 = r(N)
 21.     }
 22.     restore
 23. 
.     local pass = (`n1' == `n2') & (`m1_1' == `m2_1') & (`m1_2' == `m2_2') & (
> `m1_3' == `m2_3')
 24. 
.     if `pass' {
 25.         global TESTS_PASSED = $TESTS_PASSED + 1
 26.         di as result "  PASS: `testname' (N=`n1', m1=`m1_1', m2=`m1_2', m3
> =`m1_3')"
 27.     }
 28.     else {
 29.         global TESTS_FAILED = $TESTS_FAILED + 1
 30.         di as error "  FAIL: `testname' counts differ"
 31.         di as error "    Stata: N=`n1', m1=`m1_1', m2=`m1_2', m3=`m1_3'"
 32.         di as error "    cmerge: N=`n2', m1=`m2_1', m2=`m2_2', m3=`m2_3'"
 33.     }
 34. end

. 
. *----------------------------------------------------------------------------
> ---
. * Helper program to print section header
. *----------------------------------------------------------------------------
> ---
. 
. capture program drop print_section

. program define print_section
  1.     args title
  2.     di as text ""
  3.     di as text "{hline 70}"
  4.     di as text "`title'"
  5.     di as text "{hline 70}"
  6. end

. 
. * Helper program to print test summary
. capture program drop print_summary

. program define print_summary
  1.     args component
  2.     di as text ""
  3.     di as text "{hline 70}"
  4.     di as text "SUMMARY: `component'"
  5.     di as text "{hline 70}"
  6.     di as text "Tests passed: " as result $TESTS_PASSED
  7.     di as text "Tests failed: " as result $TESTS_FAILED
  8.     di as text "Total tests:  " as result $TESTS_TOTAL
  9.     if $TESTS_FAILED > 0 {
 10.         di as error "VALIDATION FAILED"
 11.     }
 12.     else {
 13.         di as result "ALL TESTS PASSED"
 14.     }
 15.     di as text "{hline 70}"
 16. end

. 
. * Load benchmark helper programs
. do "benchmark_helpers.do"
file benchmark_helpers.do not found
r(601);

end of do-file
r(601);

end of do-file
r(601);
