/*******************************************************************************
 * validate_cbinscatter.do
 *
 * Comprehensive validation tests for cbinscatter
 * Tests all options: nquantiles, discrete, controls, absorb, by, method(binsreg),
 * linetype, weights, savedata
 *
 * VERIFICATION: Tests compare e() results and check consistency with binscatter
 * and binsreg where applicable
 ******************************************************************************/

* Load setup (works from project root or validation dir)
capture do "validation/validate_setup.do"
if _rc != 0 {
    do "validate_setup.do"
}

quietly {

noi di as text "Running validation tests for cbinscatter..."

* Plugin check
sysuse auto, clear
capture cbinscatter price mpg, nograph
if _rc != 0 {
    test_fail "cbinscatter plugin load" "returned error `=_rc'"
    exit 1
}
test_pass "cbinscatter plugin loads and runs"

/*******************************************************************************
 * SECTION 2: Basic functionality
 ******************************************************************************/
print_section "Basic Functionality"

* Simple two-variable scatter
sysuse auto, clear
cbinscatter price mpg, nograph
if e(N) == _N & e(nquantiles) == 20 {
    test_pass "basic scatter (default 20 bins)"
}
else {
    test_fail "basic scatter" "N=`=e(N)' expected `=_N', nquantiles=`=e(nquantiles)' expected 20"
}

* Check e() results populated
sysuse auto, clear
cbinscatter price mpg, nograph
capture confirm matrix e(bindata)
if _rc == 0 {
    test_pass "e(bindata) matrix populated"
}
else {
    test_fail "e(bindata)" "matrix not found"
}

capture confirm matrix e(coefs)
if _rc == 0 {
    test_pass "e(coefs) matrix populated (linear fit)"
}
else {
    test_fail "e(coefs)" "matrix not found"
}

/*******************************************************************************
 * SECTION 3: nquantiles option
 ******************************************************************************/
print_section "nquantiles Option"

sysuse auto, clear
cbinscatter price mpg, nquantiles(10) nograph
if e(nquantiles) == 10 {
    test_pass "nquantiles(10)"
}
else {
    test_fail "nquantiles(10)" "got `=e(nquantiles)'"
}

sysuse auto, clear
cbinscatter price mpg, nquantiles(50) nograph
if e(nquantiles) == 50 {
    test_pass "nquantiles(50)"
}
else {
    test_fail "nquantiles(50)" "got `=e(nquantiles)'"
}

sysuse auto, clear
cbinscatter price mpg, nquantiles(5) nograph
if e(nquantiles) == 5 {
    test_pass "nquantiles(5)"
}
else {
    test_fail "nquantiles(5)" "got `=e(nquantiles)'"
}

* Test invalid nquantiles (should error)
sysuse auto, clear
capture cbinscatter price mpg, nquantiles(1) nograph
if _rc != 0 {
    test_pass "nquantiles(1) rejected (rc=`=_rc')"
}
else {
    test_fail "nquantiles(1)" "should have been rejected"
}

/*******************************************************************************
 * SECTION 4: discrete option
 ******************************************************************************/
print_section "discrete Option"

* Create discrete x variable
sysuse auto, clear
cbinscatter price rep78, discrete nograph
if e(N) > 0 {
    test_pass "discrete with rep78 (5 values)"
}
else {
    test_fail "discrete" "returned no observations"
}

* Discrete with few unique values
clear
set seed 12345
set obs 1000
gen x = runiformint(1, 10)
gen y = 2*x + rnormal()
cbinscatter y x, discrete nograph

* Should have ~10 bins (one per unique x value)
tempname binmat
matrix `binmat' = e(bindata)
local num_bins = 0
local nrows = rowsof(`binmat')
forval r = 1/`nrows' {
    if `binmat'[`r', 2] != . {
        local num_bins = `num_bins' + 1
    }
}
if `num_bins' == 10 {
    test_pass "discrete creates one bin per unique value"
}
else {
    test_fail "discrete creates one bin per unique value" "got `num_bins' bins, expected 10"
}

/*******************************************************************************
 * SECTION 5: controls option
 ******************************************************************************/
print_section "controls Option"

sysuse auto, clear
cbinscatter price mpg, controls(weight) nograph
if "`e(controls)'" == "weight" {
    test_pass "controls(weight)"
}
else {
    test_fail "controls(weight)" "e(controls)=`e(controls)'"
}

sysuse auto, clear
cbinscatter price mpg, controls(weight length) nograph
if "`e(controls)'" == "weight length" {
    test_pass "controls(weight length)"
}
else {
    test_fail "controls(weight length)" "e(controls)=`e(controls)'"
}

* Many controls
sysuse auto, clear
cbinscatter price mpg, controls(weight length turn displacement) nograph
if e(N) > 0 {
    test_pass "controls (4 variables)"
}
else {
    test_fail "controls (4 variables)" "returned no observations"
}

/*******************************************************************************
 * SECTION 6: absorb option
 ******************************************************************************/
print_section "absorb Option"

sysuse auto, clear
cbinscatter price mpg, absorb(foreign) nograph
if "`e(absorb)'" == "foreign" {
    test_pass "absorb(foreign)"
}
else {
    test_fail "absorb(foreign)" "e(absorb)=`e(absorb)'"
}

sysuse auto, clear
cbinscatter price mpg, absorb(foreign rep78) nograph
if "`e(absorb)'" == "foreign rep78" {
    test_pass "absorb(foreign rep78)"
}
else {
    test_fail "absorb(foreign rep78)" "e(absorb)=`e(absorb)'"
}

* Absorb with controls
sysuse auto, clear
cbinscatter price mpg, controls(weight) absorb(foreign) nograph
if "`e(controls)'" == "weight" & "`e(absorb)'" == "foreign" {
    test_pass "controls + absorb"
}
else {
    test_fail "controls + absorb" "controls=`e(controls)' absorb=`e(absorb)'"
}

/*******************************************************************************
 * SECTION 7: by() option
 ******************************************************************************/
print_section "by() Option"

sysuse auto, clear
cbinscatter price mpg, by(foreign) nograph
if e(num_groups) == 2 {
    test_pass "by(foreign) creates 2 groups"
}
else {
    test_fail "by(foreign)" "num_groups=`=e(num_groups)' expected 2"
}

* by with more groups
sysuse auto, clear
cbinscatter price mpg, by(rep78) nograph
if e(num_groups) >= 3 {
    test_pass "by(rep78) creates multiple groups"
}
else {
    test_fail "by(rep78)" "num_groups=`=e(num_groups)'"
}

* by with controls
sysuse auto, clear
cbinscatter price mpg, controls(weight) by(foreign) nograph
if e(num_groups) == 2 & "`e(controls)'" == "weight" {
    test_pass "by + controls"
}
else {
    test_fail "by + controls" "num_groups=`=e(num_groups)' controls=`e(controls)'"
}

* by with absorb
sysuse auto, clear
cbinscatter price mpg, absorb(rep78) by(foreign) nograph
if e(num_groups) == 2 & "`e(absorb)'" == "rep78" {
    test_pass "by + absorb"
}
else {
    test_fail "by + absorb" "num_groups=`=e(num_groups)' absorb=`e(absorb)'"
}

/*******************************************************************************
 * SECTION 8: method(binsreg) option
 *
 * Compares actual bin X and Y coordinates between cbinscatter method(binsreg)
 * and binsreg.ado. Uses price as X (continuous, 73 unique values in auto).
 *
 * TOLERANCE NOTE: binsreg.ado loses precision when storing quantile cutpoints
 * in Stata local macros (double->string->double via binsreg_irecode). This
 * causes ~1% of observations to be assigned to different bins vs xtile. Our
 * cutpoint algorithm matches xtile exactly, so bin X/Y means differ slightly.
 * We use a lower tolerance (0.5 sigfigs) to accommodate this known limitation.
 ******************************************************************************/
print_section "method(binsreg) Option"

* Check if binsreg is installed
capture which binsreg
local binsreg_installed = (_rc == 0)

if `binsreg_installed' {

    * -------------------------------------------------------------------------
    * Helper: compare_binsreg_bins
    *   Runs binsreg and cbinscatter, compares bin X and Y values.
    *   Arguments:
    *     binsreg_cmd  - full binsreg command (must include savedata(_binsreg_test) replace)
    *     cbins_cmd    - full cbinscatter command (must include method(binsreg) nograph)
    *     nbins        - number of bins requested
    *     testname     - test label
    * -------------------------------------------------------------------------
    capture program drop compare_binsreg_bins
    program define compare_binsreg_bins
        syntax, binsreg_cmd(string asis) cbins_cmd(string asis) nbins(integer) testname(string) [minsf(real 0.5)]

        local min_sigfigs = `minsf'

        * Run binsreg and extract bin coordinates
        preserve
        quietly `binsreg_cmd'
        use _binsreg_test, clear
        mkmat dots_fit, mat(_br_y)
        mkmat dots_x, mat(_br_x)
        local br_nbins = _N
        restore

        * Run cbinscatter
        `cbins_cmd'
        mat _cb = e(bindata)

        * Count non-missing cbinscatter bins
        local cb_nbins = 0
        local nrows = rowsof(_cb)
        forval r = 1/`nrows' {
            if _cb[`r', 2] != . {
                local cb_nbins = `cb_nbins' + 1
            }
        }

        * Check bin counts match before comparing values
        if `br_nbins' != `cb_nbins' {
            test_fail "binsreg X: `testname'" "bin count mismatch: binsreg=`br_nbins' cbinscatter=`cb_nbins'"
            test_fail "binsreg Y: `testname'" "bin count mismatch: binsreg=`br_nbins' cbinscatter=`cb_nbins'"
            cap erase _binsreg_test.dta
            mat drop _br_y _br_x _cb
            exit
        }

        * Compare X values (bin centers)
        local min_sf_x = 15
        forval i = 1/`br_nbins' {
            local val1 = _br_x[`i', 1]
            local val2 = _cb[`i', 3]
            sigfigs `val1' `val2'
            local sf = r(sigfigs)
            if `sf' < `min_sf_x' {
                local min_sf_x = `sf'
            }
        }

        if `min_sf_x' >= `min_sigfigs' {
            local sf_fmt : display %4.1f `min_sf_x'
            test_pass "binsreg X: `testname' (`sf_fmt' sf)"
        }
        else {
            local sf_fmt : display %4.1f `min_sf_x'
            test_fail "binsreg X: `testname'" "sigfigs=`sf_fmt', need `min_sigfigs'"
        }

        * Compare Y values (conditional means)
        local min_sf_y = 15
        forval i = 1/`br_nbins' {
            local val1 = _br_y[`i', 1]
            local val2 = _cb[`i', 4]
            sigfigs `val1' `val2'
            local sf = r(sigfigs)
            if `sf' < `min_sf_y' {
                local min_sf_y = `sf'
            }
        }

        if `min_sf_y' >= `min_sigfigs' {
            local sf_fmt : display %4.1f `min_sf_y'
            test_pass "binsreg Y: `testname' (`sf_fmt' sf)"
        }
        else {
            local sf_fmt : display %4.1f `min_sf_y'
            test_fail "binsreg Y: `testname'" "sigfigs=`sf_fmt', need `min_sigfigs'"
        }

        cap erase _binsreg_test.dta
        mat drop _br_y _br_x _cb
    end

    * Basic binsreg method (no controls, no absorb)
    sysuse auto, clear
    compare_binsreg_bins, ///
        binsreg_cmd(binsreg weight price, nbins(20) dots(0 0) savedata(_binsreg_test) replace) ///
        cbins_cmd(cbinscatter weight price, nquantiles(20) method(binsreg) nograph) ///
        nbins(20) testname("basic")

    * binsreg with controls
    sysuse auto, clear
    compare_binsreg_bins, ///
        binsreg_cmd(binsreg weight price length, nbins(20) dots(0 0) savedata(_binsreg_test) replace) ///
        cbins_cmd(cbinscatter weight price, controls(length) nquantiles(20) method(binsreg) nograph) ///
        nbins(20) testname("controls")

    * binsreg with absorb
    sysuse auto, clear
    compare_binsreg_bins, ///
        binsreg_cmd(binsreg weight price, absorb(foreign) nbins(20) dots(0 0) savedata(_binsreg_test) replace) ///
        cbins_cmd(cbinscatter weight price, absorb(foreign) nquantiles(20) method(binsreg) nograph) ///
        nbins(20) testname("absorb")

    * binsreg with controls + absorb
    sysuse auto, clear
    compare_binsreg_bins, ///
        binsreg_cmd(binsreg weight price length, absorb(foreign) nbins(20) dots(0 0) savedata(_binsreg_test) replace) ///
        cbins_cmd(cbinscatter weight price, controls(length) absorb(foreign) nquantiles(20) method(binsreg) nograph) ///
        nbins(20) testname("controls + absorb")
}
else {
    test_fail "method(binsreg) comparison" "binsreg not installed - cannot validate"
}

/*******************************************************************************
 * SECTION 9: Comparison with binscatter.ado
 *
 * Compares actual bin X and Y coordinates between cbinscatter and binscatter.
 *
 * binscatter saves bin means as CSV via savedata().
 * cbinscatter stores bin means in e(bindata)[,3] (x) and e(bindata)[,4] (y).
 *
 * MEAN OFFSET: binscatter adds sample means back to residuals after
 * partialling out controls/absorb; cbinscatter stores raw residuals. The
 * helper computes the mean difference between the two outputs and shifts
 * cbinscatter values to match. For the basic case (no controls/absorb),
 * the offset is ~0.
 ******************************************************************************/
print_section "Comparison vs binscatter.ado"

* Check if binscatter is installed
capture which binscatter
local binscatter_installed = (_rc == 0)

if `binscatter_installed' {

    * -------------------------------------------------------------------------
    * Helper: compare_binscatter_bins
    *   Runs binscatter and cbinscatter, compares bin X and Y values.
    *   Arguments:
    *     bs_cmd   - full binscatter command (must include savedata(_bs_test) replace)
    *     cb_cmd   - full cbinscatter command (must include nograph)
    *     nbins    - number of bins requested
    *     yvar     - y variable name (for renaming CSV columns)
    *     xvar     - x variable name (for renaming CSV columns)
    *     testname - test label
    *     minsf    - minimum significant figures (default $DEFAULT_SIGFIGS)
    * -------------------------------------------------------------------------
    capture program drop compare_binscatter_bins
    program define compare_binscatter_bins
        syntax, bs_cmd(string asis) cb_cmd(string asis) nbins(integer) yvar(string) xvar(string) testname(string) [minsf(real $DEFAULT_SIGFIGS)]

        local min_sigfigs = `minsf'

        * Run binscatter and extract bin data from CSV
        preserve
        quietly `bs_cmd'
        import delimited _bs_test.csv, clear
        rename `xvar' bs_x
        rename `yvar' bs_y
        sort bs_x
        mkmat bs_x bs_y, mat(_bs_data)
        local bs_nbins = _N
        restore

        * Run cbinscatter
        `cb_cmd'
        mat _cb_data = e(bindata)

        * Count non-missing cbinscatter bins
        local cb_nbins = 0
        local nrows = rowsof(_cb_data)
        forval r = 1/`nrows' {
            if _cb_data[`r', 2] != . {
                local cb_nbins = `cb_nbins' + 1
            }
        }

        * Check bin counts match before comparing values
        if `bs_nbins' != `cb_nbins' {
            test_fail "binscatter X: `testname'" "bin count mismatch: binscatter=`bs_nbins' cbinscatter=`cb_nbins'"
            test_fail "binscatter Y: `testname'" "bin count mismatch"
            cap erase _bs_test.csv
            cap erase _bs_test.do
            mat drop _bs_data _cb_data
            exit
        }

        * Compute mean offset (binscatter adds means back, cbinscatter may not)
        mata: st_local("bs_mean_x", strofreal(mean(st_matrix("_bs_data")[., 1]), "%21.15g"))
        mata: st_local("bs_mean_y", strofreal(mean(st_matrix("_bs_data")[., 2]), "%21.15g"))
        mata: st_local("cb_mean_x", strofreal(mean(st_matrix("_cb_data")[., 3]), "%21.15g"))
        mata: st_local("cb_mean_y", strofreal(mean(st_matrix("_cb_data")[., 4]), "%21.15g"))
        local offset_x = `bs_mean_x' - `cb_mean_x'
        local offset_y = `bs_mean_y' - `cb_mean_y'

        * Compare X values
        local min_sf_x = 15
        forval i = 1/`bs_nbins' {
            local val1 = _bs_data[`i', 1]
            local val2 = _cb_data[`i', 3] + `offset_x'
            sigfigs `val1' `val2'
            local sf = r(sigfigs)
            if `sf' < `min_sf_x' {
                local min_sf_x = `sf'
            }
        }

        if `min_sf_x' >= `min_sigfigs' {
            local sf_fmt : display %4.1f `min_sf_x'
            test_pass "binscatter X: `testname' (`sf_fmt' sf)"
        }
        else {
            local sf_fmt : display %4.1f `min_sf_x'
            test_fail "binscatter X: `testname'" "sigfigs=`sf_fmt', need `min_sigfigs'"
        }

        * Compare Y values
        local min_sf_y = 15
        forval i = 1/`bs_nbins' {
            local val1 = _bs_data[`i', 2]
            local val2 = _cb_data[`i', 4] + `offset_y'
            sigfigs `val1' `val2'
            local sf = r(sigfigs)
            if `sf' < `min_sf_y' {
                local min_sf_y = `sf'
            }
        }

        if `min_sf_y' >= `min_sigfigs' {
            local sf_fmt : display %4.1f `min_sf_y'
            test_pass "binscatter Y: `testname' (`sf_fmt' sf)"
        }
        else {
            local sf_fmt : display %4.1f `min_sf_y'
            test_fail "binscatter Y: `testname'" "sigfigs=`sf_fmt', need `min_sigfigs'"
        }

        cap erase _bs_test.csv
        cap erase _bs_test.do
        mat drop _bs_data _cb_data
    end

    * Basic scatter
    sysuse auto, clear
    compare_binscatter_bins, ///
        bs_cmd(binscatter price mpg, nquantiles(10) savedata(_bs_test) replace) ///
        cb_cmd(cbinscatter price mpg, nquantiles(10) nograph) ///
        nbins(10) yvar(price) xvar(mpg) testname("basic")

    * With controls
    sysuse auto, clear
    compare_binscatter_bins, ///
        bs_cmd(binscatter price mpg, controls(weight) nquantiles(10) savedata(_bs_test) replace) ///
        cb_cmd(cbinscatter price mpg, controls(weight) nquantiles(10) nograph) ///
        nbins(10) yvar(price) xvar(mpg) testname("controls(weight)")

    * With absorb
    sysuse auto, clear
    compare_binscatter_bins, ///
        bs_cmd(binscatter price mpg, absorb(foreign) nquantiles(10) savedata(_bs_test) replace) ///
        cb_cmd(cbinscatter price mpg, absorb(foreign) nquantiles(10) nograph) ///
        nbins(10) yvar(price) xvar(mpg) testname("absorb(foreign)")

    * Controls + absorb
    sysuse auto, clear
    compare_binscatter_bins, ///
        bs_cmd(binscatter price mpg, controls(weight) absorb(foreign) nquantiles(10) savedata(_bs_test) replace) ///
        cb_cmd(cbinscatter price mpg, controls(weight) absorb(foreign) nquantiles(10) nograph) ///
        nbins(10) yvar(price) xvar(mpg) testname("controls + absorb")

    * Multiple controls
    sysuse auto, clear
    compare_binscatter_bins, ///
        bs_cmd(binscatter price mpg, controls(weight length) nquantiles(10) savedata(_bs_test) replace) ///
        cb_cmd(cbinscatter price mpg, controls(weight length) nquantiles(10) nograph) ///
        nbins(10) yvar(price) xvar(mpg) testname("controls(weight length)")

    * Different nquantiles
    sysuse auto, clear
    compare_binscatter_bins, ///
        bs_cmd(binscatter price mpg, nquantiles(20) savedata(_bs_test) replace) ///
        cb_cmd(cbinscatter price mpg, nquantiles(20) nograph) ///
        nbins(20) yvar(price) xvar(mpg) testname("nquantiles(20)")

    * Different y/x variables
    sysuse auto, clear
    compare_binscatter_bins, ///
        bs_cmd(binscatter weight displacement, nquantiles(10) savedata(_bs_test) replace) ///
        cb_cmd(cbinscatter weight displacement, nquantiles(10) nograph) ///
        nbins(10) yvar(weight) xvar(displacement) testname("weight~displacement")

    * Controls + absorb + different variables
    sysuse auto, clear
    compare_binscatter_bins, ///
        bs_cmd(binscatter weight displacement, controls(length) absorb(foreign) nquantiles(10) savedata(_bs_test) replace) ///
        cb_cmd(cbinscatter weight displacement, controls(length) absorb(foreign) nquantiles(10) nograph) ///
        nbins(10) yvar(weight) xvar(displacement) testname("weight~displ ctrl+absorb")

    * Clean up helper
    capture program drop compare_binscatter_bins
}
else {
    test_fail "binscatter comparison" "binscatter not installed - cannot validate"
}

/*******************************************************************************
 * SECTION 10: method(binsreg) comparison with binsreg.ado
 *
 * Compares actual bin X and Y coordinates between cbinscatter method(binsreg)
 * and the binsreg package (Cattaneo, Crump, Farrell, Feng).
 *
 * binsreg with dots(0 0) produces degree-0 (constant) fits = conditional means,
 * which matches what cbinscatter method(binsreg) computes.
 *
 * binsreg savedata() creates a .dta with dots_x (bin center) and dots_fit (y).
 * cbinscatter stores bin centers in e(bindata)[,3] and y means in e(bindata)[,4].
 *
 * IMPORTANT: Use continuous X variables. binsreg with integer/discrete X
 * (e.g. mpg with 21 unique values) creates one bin per unique value regardless
 * of nbins(), making comparison impossible. Use price, weight, ln_wage, etc.
 *
 * TOLERANCE NOTE: binsreg.ado loses precision when storing quantile cutpoints
 * in Stata local macros (double->string->double via binsreg_irecode). This
 * causes ~1% of observations to be assigned to different bins vs xtile. Our
 * cutpoint algorithm matches xtile exactly, so bin X/Y means differ slightly.
 * We use a lower tolerance (0.5 sigfigs) to accommodate this known limitation.
 ******************************************************************************/
print_section "method(binsreg) vs binsreg.ado"

* Check if binsreg is installed
capture which binsreg
local binsreg_installed = (_rc == 0)

if `binsreg_installed' {

    * =====================================================================
    * AUTO DATASET - use price as X (73 unique values among 74 obs)
    * =====================================================================

    * auto: one control
    sysuse auto, clear
    compare_binsreg_bins, ///
        binsreg_cmd(binsreg weight price length, nbins(20) dots(0 0) savedata(_binsreg_test) replace) ///
        cbins_cmd(cbinscatter weight price, controls(length) nquantiles(20) method(binsreg) nograph) ///
        nbins(20) testname("auto: ctrl(length)")

    * auto: multiple controls
    sysuse auto, clear
    compare_binsreg_bins, ///
        binsreg_cmd(binsreg weight price length mpg, nbins(20) dots(0 0) savedata(_binsreg_test) replace) ///
        cbins_cmd(cbinscatter weight price, controls(length mpg) nquantiles(20) method(binsreg) nograph) ///
        nbins(20) testname("auto: ctrl(length mpg)")

    * auto: absorb only
    sysuse auto, clear
    compare_binsreg_bins, ///
        binsreg_cmd(binsreg weight price, absorb(foreign) nbins(20) dots(0 0) savedata(_binsreg_test) replace) ///
        cbins_cmd(cbinscatter weight price, absorb(foreign) nquantiles(20) method(binsreg) nograph) ///
        nbins(20) testname("auto: absorb(foreign)")

    * auto: controls + absorb
    sysuse auto, clear
    compare_binsreg_bins, ///
        binsreg_cmd(binsreg weight price length, absorb(foreign) nbins(20) dots(0 0) savedata(_binsreg_test) replace) ///
        cbins_cmd(cbinscatter weight price, controls(length) absorb(foreign) nquantiles(20) method(binsreg) nograph) ///
        nbins(20) testname("auto: ctrl + absorb")

    * auto: different y/x with controls
    sysuse auto, clear
    compare_binsreg_bins, ///
        binsreg_cmd(binsreg displacement price length, nbins(20) dots(0 0) savedata(_binsreg_test) replace) ///
        cbins_cmd(cbinscatter displacement price, controls(length) nquantiles(20) method(binsreg) nograph) ///
        nbins(20) testname("auto: displ~price ctrl(length)")

    * auto: if condition with controls
    sysuse auto, clear
    compare_binsreg_bins, ///
        binsreg_cmd(binsreg weight price length if price > 4000, nbins(20) dots(0 0) savedata(_binsreg_test) replace) ///
        cbins_cmd(cbinscatter weight price if price > 4000, controls(length) nquantiles(20) method(binsreg) nograph) ///
        nbins(20) testname("auto: if price>4000 + ctrl")

    * auto: aweights + controls
    sysuse auto, clear
    compare_binsreg_bins, ///
        binsreg_cmd(binsreg weight price mpg [aw=length], nbins(20) dots(0 0) savedata(_binsreg_test) replace) ///
        cbins_cmd(cbinscatter weight price [aw=length], controls(mpg) nquantiles(20) method(binsreg) nograph) ///
        nbins(20) testname("auto: aw + ctrl")

    * auto: aweights + absorb
    sysuse auto, clear
    compare_binsreg_bins, ///
        binsreg_cmd(binsreg weight price [aw=length], absorb(foreign) nbins(20) dots(0 0) savedata(_binsreg_test) replace) ///
        cbins_cmd(cbinscatter weight price [aw=length], absorb(foreign) nquantiles(20) method(binsreg) nograph) ///
        nbins(20) testname("auto: aw + absorb")

    * auto: aweights + controls + absorb
    sysuse auto, clear
    compare_binsreg_bins, ///
        binsreg_cmd(binsreg weight price mpg [aw=length], absorb(foreign) nbins(20) dots(0 0) savedata(_binsreg_test) replace) ///
        cbins_cmd(cbinscatter weight price [aw=length], controls(mpg) absorb(foreign) nquantiles(20) method(binsreg) nograph) ///
        nbins(20) testname("auto: aw + ctrl + absorb")

    * =====================================================================
    * NLSWORK DATASET - pre-drop missing values for consistent samples
    * Use ln_wage as X (continuous with many unique values)
    * =====================================================================

    * nlswork: with control (tenure)
    webuse nlswork, clear
    keep in 1/5000
    drop if missing(hours) | missing(ln_wage) | missing(tenure)
    compare_binsreg_bins, ///
        binsreg_cmd(binsreg hours ln_wage tenure, nbins(20) dots(0 0) savedata(_binsreg_test) replace) ///
        cbins_cmd(cbinscatter hours ln_wage, controls(tenure) nquantiles(20) method(binsreg) nograph) ///
        nbins(20) testname("nlswork: ctrl(tenure)")

    * nlswork: absorb(idcode) individual FE
    webuse nlswork, clear
    keep in 1/5000
    drop if missing(hours) | missing(ln_wage)
    compare_binsreg_bins, ///
        binsreg_cmd(binsreg hours ln_wage, absorb(idcode) nbins(20) dots(0 0) savedata(_binsreg_test) replace) ///
        cbins_cmd(cbinscatter hours ln_wage, absorb(idcode) nquantiles(20) method(binsreg) nograph) ///
        nbins(20) testname("nlswork: absorb(idcode)")

    * nlswork: controls + absorb
    webuse nlswork, clear
    keep in 1/5000
    drop if missing(hours) | missing(ln_wage) | missing(tenure)
    compare_binsreg_bins, ///
        binsreg_cmd(binsreg hours ln_wage tenure, absorb(idcode) nbins(20) dots(0 0) savedata(_binsreg_test) replace) ///
        cbins_cmd(cbinscatter hours ln_wage, controls(tenure) absorb(idcode) nquantiles(20) method(binsreg) nograph) ///
        nbins(20) testname("nlswork: ctrl + absorb(idcode)")

    * nlswork: two-way FE
    webuse nlswork, clear
    keep in 1/5000
    drop if missing(hours) | missing(ln_wage)
    compare_binsreg_bins, ///
        binsreg_cmd(binsreg hours ln_wage, absorb(idcode year) nbins(20) dots(0 0) savedata(_binsreg_test) replace) ///
        cbins_cmd(cbinscatter hours ln_wage, absorb(idcode year) nquantiles(20) method(binsreg) nograph) ///
        nbins(20) testname("nlswork: two-way FE")

    * nlswork: controls + two-way FE
    webuse nlswork, clear
    keep in 1/5000
    drop if missing(hours) | missing(ln_wage) | missing(tenure)
    compare_binsreg_bins, ///
        binsreg_cmd(binsreg hours ln_wage tenure, absorb(idcode year) nbins(20) dots(0 0) savedata(_binsreg_test) replace) ///
        cbins_cmd(cbinscatter hours ln_wage, controls(tenure) absorb(idcode year) nquantiles(20) method(binsreg) nograph) ///
        nbins(20) testname("nlswork: ctrl + two-way FE")

    * =====================================================================
    * SYNTHETIC DATA (controlled DGP, continuous X, no missing values)
    * =====================================================================

    * synthetic: controls only
    clear
    set seed 12345
    set obs 2000
    gen x = rnormal()
    gen w = 0.5 * x + rnormal()
    gen y = 2 * x + 0.8 * w + rnormal()

    compare_binsreg_bins, ///
        binsreg_cmd(binsreg y x w, nbins(20) dots(0 0) savedata(_binsreg_test) replace) ///
        cbins_cmd(cbinscatter y x, controls(w) nquantiles(20) method(binsreg) nograph) ///
        nbins(20) testname("synthetic: controls only")

    * synthetic: absorb only
    clear
    set seed 23456
    set obs 2000
    gen id = ceil(_n/200)
    gen x = rnormal()
    gen y = 2 * x + id * 0.5 + rnormal()

    compare_binsreg_bins, ///
        binsreg_cmd(binsreg y x, absorb(id) nbins(20) dots(0 0) savedata(_binsreg_test) replace) ///
        cbins_cmd(cbinscatter y x, absorb(id) nquantiles(20) method(binsreg) nograph) ///
        nbins(20) testname("synthetic: absorb only")

    * synthetic: controls + absorb
    clear
    set seed 34567
    set obs 2000
    gen id = ceil(_n/200)
    gen x = rnormal()
    gen w = 0.5 * x + rnormal()
    gen y = 2 * x + 0.8 * w + id * 0.5 + rnormal()

    compare_binsreg_bins, ///
        binsreg_cmd(binsreg y x w, absorb(id) nbins(20) dots(0 0) savedata(_binsreg_test) replace) ///
        cbins_cmd(cbinscatter y x, controls(w) absorb(id) nquantiles(20) method(binsreg) nograph) ///
        nbins(20) testname("synthetic: controls + absorb")

    * synthetic: multiple controls
    clear
    set seed 45678
    set obs 2000
    gen x = rnormal()
    gen w1 = 0.3 * x + rnormal()
    gen w2 = -0.2 * x + 0.5 * w1 + rnormal()
    gen w3 = rnormal()
    gen y = 2 * x + 0.8 * w1 - 0.5 * w2 + 0.3 * w3 + rnormal()

    compare_binsreg_bins, ///
        binsreg_cmd(binsreg y x w1 w2 w3, nbins(20) dots(0 0) savedata(_binsreg_test) replace) ///
        cbins_cmd(cbinscatter y x, controls(w1 w2 w3) nquantiles(20) method(binsreg) nograph) ///
        nbins(20) testname("synthetic: 3 controls")

    * synthetic: many FE levels (200)
    clear
    set seed 56789
    set obs 5000
    gen id = ceil(_n/25)
    gen x = rnormal()
    gen y = 2 * x + id * 0.1 + rnormal()

    compare_binsreg_bins, ///
        binsreg_cmd(binsreg y x, absorb(id) nbins(20) dots(0 0) savedata(_binsreg_test) replace) ///
        cbins_cmd(cbinscatter y x, absorb(id) nquantiles(20) method(binsreg) nograph) ///
        nbins(20) testname("synthetic: 200 FE levels")

    * synthetic: two-way FE
    clear
    set seed 98765
    set obs 2000
    gen id1 = ceil(_n/200)
    gen id2 = mod(_n - 1, 20) + 1
    gen x = rnormal()
    gen w = 0.5 * x + rnormal()
    gen y = 2 * x + 0.7 * w + id1 * 0.3 + id2 * 0.1 + rnormal()

    compare_binsreg_bins, ///
        binsreg_cmd(binsreg y x w, absorb(id1 id2) nbins(20) dots(0 0) savedata(_binsreg_test) replace) ///
        cbins_cmd(cbinscatter y x, controls(w) absorb(id1 id2) nquantiles(20) method(binsreg) nograph) ///
        nbins(20) testname("synthetic: ctrl + two-way FE")

    * synthetic: aweights
    clear
    set seed 67890
    set obs 2000
    gen x = rnormal()
    gen w = 0.5 * x + rnormal()
    gen y = 2 * x + 0.8 * w + rnormal()
    gen wt = abs(rnormal()) + 0.1

    compare_binsreg_bins, ///
        binsreg_cmd(binsreg y x w [aw=wt], nbins(20) dots(0 0) savedata(_binsreg_test) replace) ///
        cbins_cmd(cbinscatter y x [aw=wt], controls(w) nquantiles(20) method(binsreg) nograph) ///
        nbins(20) testname("synthetic: aw + ctrl")

    * synthetic: fweights + absorb
    clear
    set seed 89012
    set obs 1000
    gen id = ceil(_n/100)
    gen x = rnormal()
    gen y = 2 * x + id * 0.5 + rnormal()
    gen fw = ceil(abs(rnormal()) * 3) + 1

    compare_binsreg_bins, ///
        binsreg_cmd(binsreg y x [fw=fw], absorb(id) nbins(20) dots(0 0) savedata(_binsreg_test) replace) ///
        cbins_cmd(cbinscatter y x [fw=fw], absorb(id) nquantiles(20) method(binsreg) nograph) ///
        nbins(20) testname("synthetic: fw + absorb")

    * synthetic: if condition
    clear
    set seed 90123
    set obs 2000
    gen x = rnormal()
    gen w = 0.5 * x + rnormal()
    gen y = 2 * x + 0.8 * w + rnormal()

    compare_binsreg_bins, ///
        binsreg_cmd(binsreg y x w if x > 0, nbins(20) dots(0 0) savedata(_binsreg_test) replace) ///
        cbins_cmd(cbinscatter y x if x > 0, controls(w) nquantiles(20) method(binsreg) nograph) ///
        nbins(20) testname("synthetic: if condition")

    * synthetic: aweights + absorb
    clear
    set seed 13579
    set obs 2000
    gen id = ceil(_n/200)
    gen x = rnormal()
    gen y = 2 * x + id * 0.5 + rnormal()
    gen wt = abs(rnormal()) + 0.1

    compare_binsreg_bins, ///
        binsreg_cmd(binsreg y x [aw=wt], absorb(id) nbins(20) dots(0 0) savedata(_binsreg_test) replace) ///
        cbins_cmd(cbinscatter y x [aw=wt], absorb(id) nquantiles(20) method(binsreg) nograph) ///
        nbins(20) testname("synthetic: aw + absorb")

    * synthetic: aweights + controls + absorb
    clear
    set seed 24680
    set obs 2000
    gen id = ceil(_n/200)
    gen x = rnormal()
    gen w = 0.5 * x + rnormal()
    gen y = 2 * x + 0.8 * w + id * 0.5 + rnormal()
    gen wt = abs(rnormal()) + 0.1

    compare_binsreg_bins, ///
        binsreg_cmd(binsreg y x w [aw=wt], absorb(id) nbins(20) dots(0 0) savedata(_binsreg_test) replace) ///
        cbins_cmd(cbinscatter y x [aw=wt], controls(w) absorb(id) nquantiles(20) method(binsreg) nograph) ///
        nbins(20) testname("synthetic: aw + ctrl + absorb")

    * Clean up helper
    capture program drop compare_binsreg_bins
}
else {
    test_fail "binsreg comparison" "binsreg not installed - cannot validate"
}

/*******************************************************************************
 * SECTION 10: linetype option
 ******************************************************************************/
print_section "linetype Option"

sysuse auto, clear
cbinscatter price mpg, linetype(none) nograph
if e(N) > 0 {
    test_pass "linetype(none)"
}
else {
    test_fail "linetype(none)" "returned no observations"
}

sysuse auto, clear
cbinscatter price mpg, linetype(linear) nograph
capture confirm matrix e(coefs)
if _rc == 0 {
    test_pass "linetype(linear)"
}
else {
    test_fail "linetype(linear)" "no coefs matrix"
}

sysuse auto, clear
cbinscatter price mpg, linetype(qfit) nograph
capture confirm matrix e(coefs)
if _rc == 0 {
    test_pass "linetype(qfit)"
}
else {
    test_fail "linetype(qfit)" "no coefs matrix"
}

sysuse auto, clear
cbinscatter price mpg, linetype(cubic) nograph
capture confirm matrix e(coefs)
if _rc == 0 {
    test_pass "linetype(cubic)"
}
else {
    test_fail "linetype(cubic)" "no coefs matrix"
}

/*******************************************************************************
 * SECTION 11: Weights
 ******************************************************************************/
print_section "Weights"

sysuse auto, clear
capture cbinscatter price mpg [aw=weight], nograph
if _rc == 0 {
    capture confirm matrix e(bindata)
    if _rc == 0 & e(N) == _N {
        test_pass "aweight (N=`=e(N)')"
    }
    else {
        test_fail "aweight" "bindata missing or N=`=e(N)' expected `=_N'"
    }
}
else {
    test_fail "aweight" "rc=`=_rc'"
}

sysuse auto, clear
gen fw = ceil(mpg/5)
capture cbinscatter price mpg [fw=fw], nograph
if _rc == 0 {
    capture confirm matrix e(bindata)
    if _rc == 0 & e(N) > 0 {
        test_pass "fweight (N=`=e(N)')"
    }
    else {
        test_fail "fweight" "bindata missing or N=`=e(N)'"
    }
}
else {
    test_fail "fweight" "rc=`=_rc'"
}

sysuse auto, clear
capture cbinscatter price mpg [pw=weight], nograph
if _rc == 0 {
    capture confirm matrix e(bindata)
    if _rc == 0 & e(N) == _N {
        test_pass "pweight (N=`=e(N)')"
    }
    else {
        test_fail "pweight" "bindata missing or N=`=e(N)' expected `=_N'"
    }
}
else {
    test_fail "pweight" "rc=`=_rc'"
}

* Weights with controls
sysuse auto, clear
capture cbinscatter price mpg [aw=weight], controls(length) nograph
if _rc == 0 {
    if "`e(controls)'" == "length" & e(N) == _N {
        test_pass "aweight + controls"
    }
    else {
        test_fail "aweight + controls" "controls=`e(controls)' N=`=e(N)'"
    }
}
else {
    test_fail "aweight + controls" "rc=`=_rc'"
}

* Weights with absorb
sysuse auto, clear
capture cbinscatter price mpg [aw=weight], absorb(foreign) nograph
if _rc == 0 {
    if "`e(absorb)'" == "foreign" & e(N) == _N {
        test_pass "aweight + absorb"
    }
    else {
        test_fail "aweight + absorb" "absorb=`e(absorb)' N=`=e(N)'"
    }
}
else {
    test_fail "aweight + absorb" "rc=`=_rc'"
}

/*******************************************************************************
 * SECTION 12: savedata option
 ******************************************************************************/
print_section "savedata Option"

sysuse auto, clear
capture erase _cbins_test.dta
cbinscatter price mpg, savedata(_cbins_test) nograph

capture confirm file "_cbins_test.dta"
if _rc == 0 {
    test_pass "savedata creates file"

    * Check file contents
    preserve
    use _cbins_test, clear
    local nvars : word count `r(varlist)'
    local nobs = _N
    restore

    if `nobs' > 0 {
        test_pass "savedata file has data"
    }
    else {
        test_fail "savedata file" "empty"
    }
    cap erase _cbins_test.dta
}
else {
    test_fail "savedata" "file not created"
}

/*******************************************************************************
 * SECTION 13: if/in conditions
 ******************************************************************************/
print_section "if/in Conditions"

sysuse auto, clear
count if price > 5000
local expected_N = r(N)
cbinscatter price mpg if price > 5000, nograph
if e(N) == `expected_N' {
    test_pass "if condition: N=`=e(N)' matches"
}
else {
    test_fail "if condition" "N=`=e(N)' expected `expected_N'"
}

sysuse auto, clear
cbinscatter price mpg in 1/50, nograph
if e(N) == 50 {
    test_pass "in condition: N=50 matches"
}
else {
    test_fail "in condition" "N=`=e(N)' expected 50"
}

* Combined if and in
sysuse auto, clear
count if foreign == 0 in 1/60
local expected_N = r(N)
cbinscatter price mpg in 1/60 if foreign == 0, nograph
if e(N) == `expected_N' {
    test_pass "if + in combined: N=`=e(N)' matches"
}
else {
    test_fail "if + in combined" "N=`=e(N)' expected `expected_N'"
}

/*******************************************************************************
 * SECTION 14: Missing values
 ******************************************************************************/
print_section "Missing Values"

* Missing in y
clear
set seed 99
set obs 500
gen x = runiform()
gen y = 2*x + rnormal()
replace y = . if _n <= 50

cbinscatter y x, nograph
if e(N) == 450 & e(N_dropped) == 50 {
    test_pass "missing in y: handled correctly"
}
else {
    test_fail "missing in y" "N=`=e(N)' N_dropped=`=e(N_dropped)'"
}

* Missing in x
clear
set seed 100
set obs 500
gen x = runiform()
replace x = . if _n <= 50
gen y = 2*x + rnormal()

cbinscatter y x, nograph
if e(N) == 450 & e(N_dropped) >= 50 {
    test_pass "missing in x: handled correctly"
}
else {
    test_fail "missing in x" "N=`=e(N)' N_dropped=`=e(N_dropped)'"
}

* Missing in controls
clear
set seed 101
set obs 500
gen x = runiform()
gen w = runiform()
replace w = . if _n <= 50
gen y = 2*x + w + rnormal()

cbinscatter y x, controls(w) nograph
if e(N_dropped) >= 50 {
    test_pass "missing in controls: handled correctly"
}
else {
    test_fail "missing in controls" "N_dropped=`=e(N_dropped)'"
}

/*******************************************************************************
 * SECTION 15: Large datasets
 ******************************************************************************/
print_section "Large Datasets"

* 50K observations
clear
set seed 200
set obs 50000
gen x = runiform()
gen y = 2*x + rnormal()

cbinscatter y x, nograph
if e(N) == 50000 {
    test_pass "50K observations"
}
else {
    test_fail "50K observations" "N=`=e(N)'"
}

* 50K with controls
clear
set seed 201
set obs 50000
gen x = runiform()
gen w1 = runiform()
gen w2 = rnormal()
gen y = 2*x + w1 + w2 + rnormal()

cbinscatter y x, controls(w1 w2) nograph
if e(N) == 50000 {
    test_pass "50K with controls"
}
else {
    test_fail "50K with controls" "N=`=e(N)'"
}

* 50K with absorb
clear
set seed 202
set obs 50000
gen id = runiformint(1, 500)
gen x = runiform()
gen y = 2*x + id*0.01 + rnormal()

cbinscatter y x, absorb(id) nograph
if e(N) == 50000 {
    test_pass "50K with absorb (500 FE)"
}
else {
    test_fail "50K with absorb" "N=`=e(N)'"
}

/*******************************************************************************
 * SECTION 16: Panel data (nlswork)
 ******************************************************************************/
print_section "Panel Data (nlswork)"

webuse nlswork, clear
keep in 1/10000
cbinscatter ln_wage age, nograph
if e(N) > 0 {
    test_pass "nlswork basic"
}
else {
    test_fail "nlswork basic" "N=`=e(N)'"
}

webuse nlswork, clear
keep in 1/10000
cbinscatter ln_wage age, controls(tenure) nograph
if e(N) > 0 {
    test_pass "nlswork with controls"
}
else {
    test_fail "nlswork with controls" "N=`=e(N)'"
}

webuse nlswork, clear
keep in 1/10000
cbinscatter ln_wage age, absorb(idcode) nograph
if e(N) > 0 {
    test_pass "nlswork with individual FE"
}
else {
    test_fail "nlswork with individual FE" "N=`=e(N)'"
}

webuse nlswork, clear
keep in 1/10000
cbinscatter ln_wage age, absorb(idcode year) nograph
if e(N) > 0 {
    test_pass "nlswork with two-way FE"
}
else {
    test_fail "nlswork with two-way FE" "N=`=e(N)'"
}

/*******************************************************************************
 * SECTION 17: Stress tests - method(binsreg)
 ******************************************************************************/
print_section "Stress Tests - method(binsreg)"

* Multiple controls + absorb
clear
set seed 54321
set obs 2000
gen id1 = ceil(_n/200)
gen x = rnormal()
gen w1 = 0.3 * x + rnormal()
gen w2 = -0.2 * x + 0.5 * w1 + rnormal()
gen y = 2 * x + 0.8 * w1 - 0.5 * w2 + id1 * 0.3 + rnormal()

capture cbinscatter y x, controls(w1 w2) absorb(id1) nquantiles(15) method(binsreg) nograph
if _rc == 0 {
    mat _bd = e(bindata)
    local nrows = rowsof(_bd)
    if `nrows' == 15 & e(N) == 2000 & e(nquantiles) == 15 {
        test_pass "binsreg: multiple controls + absorb (bins=`nrows', N=`=e(N)')"
    }
    else {
        test_fail "binsreg: multiple controls + absorb" "bins=`nrows' expected 15, N=`=e(N)' expected 2000"
    }
}
else {
    test_fail "binsreg: multiple controls + absorb" "rc=`=_rc'"
}

* Multiple FE dimensions
clear
set seed 98765
set obs 2000
gen id1 = ceil(_n/200)
gen id2 = mod(_n - 1, 20) + 1
gen x = rnormal()
gen w = 0.5 * x + rnormal()
gen y = 2 * x + 0.7 * w + id1 * 0.3 + id2 * 0.1 + rnormal()

capture cbinscatter y x, controls(w) absorb(id1 id2) nquantiles(12) method(binsreg) nograph
if _rc == 0 {
    mat _bd = e(bindata)
    local nrows = rowsof(_bd)
    if `nrows' == 12 & e(N) == 2000 & e(nquantiles) == 12 {
        test_pass "binsreg: multiple FE dimensions (bins=`nrows', N=`=e(N)')"
    }
    else {
        test_fail "binsreg: multiple FE dimensions" "bins=`nrows' expected 12, N=`=e(N)' expected 2000"
    }
}
else {
    test_fail "binsreg: multiple FE dimensions" "rc=`=_rc'"
}

* Unbalanced FE groups
clear
set seed 11111
set obs 1500
gen id = 1 if _n <= 500
replace id = 2 if _n > 500 & _n <= 700
replace id = 3 if _n > 700 & _n <= 800
replace id = 4 if _n > 800 & _n <= 1200
replace id = 5 if _n > 1200
gen x = rnormal()
gen w = 0.4 * x + rnormal()
gen y = 1.5 * x + 0.6 * w + id * 0.4 + rnormal()

capture cbinscatter y x, controls(w) absorb(id) nquantiles(10) method(binsreg) nograph
if _rc == 0 {
    mat _bd = e(bindata)
    local nrows = rowsof(_bd)
    if `nrows' == 10 & e(N) == 1500 & e(nquantiles) == 10 {
        test_pass "binsreg: unbalanced FE groups (bins=`nrows', N=`=e(N)')"
    }
    else {
        test_fail "binsreg: unbalanced FE groups" "bins=`nrows' expected 10, N=`=e(N)' expected 1500"
    }
}
else {
    test_fail "binsreg: unbalanced FE groups" "rc=`=_rc'"
}

/*******************************************************************************
 * SECTION 18: Combination tests
 ******************************************************************************/
print_section "Option Combinations"

* discrete + by
sysuse auto, clear
capture cbinscatter price rep78, discrete by(foreign) nograph
if _rc == 0 {
    * Verify output has correct number of groups
    if e(num_groups) == 2 {
        * Check bindata has rows: discrete rep78 has 5 unique values, by(foreign) has 2 groups
        * bindata should have non-missing rows for each group
        mat _bd = e(bindata)
        local nrows = rowsof(_bd)
        if `nrows' >= 5 {
            test_pass "discrete + by (groups=`=e(num_groups)', rows=`nrows')"
        }
        else {
            test_fail "discrete + by" "bindata has only `nrows' rows, expected >= 5"
        }
    }
    else {
        test_fail "discrete + by" "num_groups=`=e(num_groups)' expected 2"
    }
}
else {
    test_fail "discrete + by" "rc=`=_rc'"
}

* by + controls + absorb
clear
set seed 300
set obs 2000
gen group = runiformint(1, 2)
gen id = runiformint(1, 50)
gen x = runiform()
gen w = runiform()
gen y = 2*x + w + id*0.1 + group + rnormal()

capture cbinscatter y x, controls(w) absorb(id) by(group) nograph
if _rc == 0 & e(num_groups) == 2 {
    test_pass "by + controls + absorb"
}
else {
    test_fail "by + controls + absorb" "rc=`=_rc' num_groups=`=e(num_groups)'"
}

* method(binsreg) + by
clear
set seed 301
set obs 2000
gen group = runiformint(1, 2)
gen id = runiformint(1, 50)
gen x = rnormal()
gen w = 0.5 * x + rnormal()
gen y = 2 * x + 0.8 * w + id * 0.1 + group + rnormal()

capture cbinscatter y x, controls(w) absorb(id) by(group) method(binsreg) nograph
if _rc == 0 & e(num_groups) == 2 {
    test_pass "method(binsreg) + by + controls + absorb"
}
else {
    test_fail "method(binsreg) + by" "rc=`=_rc'"
}

* weights + by
sysuse auto, clear
capture cbinscatter price mpg [aw=weight], by(foreign) nograph
if _rc == 0 {
    if e(num_groups) == 2 & e(N) == _N {
        test_pass "aweight + by (groups=`=e(num_groups)', N=`=e(N)')"
    }
    else {
        test_fail "aweight + by" "num_groups=`=e(num_groups)' expected 2, N=`=e(N)' expected `=_N'"
    }
}
else {
    test_fail "aweight + by" "rc=`=_rc'"
}

* discrete + controls
sysuse auto, clear
capture cbinscatter price rep78, discrete controls(weight) nograph
if _rc == 0 {
    * Verify e(controls) is set and bindata has correct discrete bins
    if "`e(controls)'" == "weight" {
        mat _bd = e(bindata)
        local nrows = rowsof(_bd)
        if `nrows' >= 5 {
            test_pass "discrete + controls (controls=`e(controls)', rows=`nrows')"
        }
        else {
            test_fail "discrete + controls" "bindata has only `nrows' rows, expected >= 5"
        }
    }
    else {
        test_fail "discrete + controls" "e(controls)=`e(controls)' expected weight"
    }
}
else {
    test_fail "discrete + controls" "rc=`=_rc'"
}

* linetype + controls + absorb
sysuse auto, clear
capture cbinscatter price mpg, controls(weight) absorb(foreign) linetype(qfit) nograph
if _rc == 0 {
    * Verify coefs matrix exists (qfit should produce polynomial coefficients)
    capture confirm matrix e(coefs)
    if _rc == 0 & "`e(controls)'" == "weight" & "`e(absorb)'" == "foreign" {
        test_pass "qfit + controls + absorb"
    }
    else {
        test_fail "qfit + controls + absorb" "coefs rc=`=_rc' controls=`e(controls)' absorb=`e(absorb)'"
    }
}
else {
    test_fail "qfit + controls + absorb" "rc=`=_rc'"
}

/*******************************************************************************
 * SECTION 19: Edge cases
 ******************************************************************************/
print_section "Edge Cases"

* Very few observations
clear
set obs 20
gen x = runiform()
gen y = 2*x + rnormal()

capture cbinscatter y x, nquantiles(5) nograph
if _rc == 0 {
    if e(N) == 20 & e(nquantiles) == 5 {
        mat _bd = e(bindata)
        local nrows = rowsof(_bd)
        if `nrows' == 5 {
            test_pass "very few observations (20 obs, 5 bins)"
        }
        else {
            test_fail "very few observations" "bindata rows=`nrows' expected 5"
        }
    }
    else {
        test_fail "very few observations" "N=`=e(N)' expected 20, nquantiles=`=e(nquantiles)' expected 5"
    }
}
else {
    test_fail "very few observations" "rc=`=_rc'"
}

* Many bins relative to observations
clear
set obs 100
gen x = runiform()
gen y = 2*x + rnormal()

capture cbinscatter y x, nquantiles(50) nograph
if _rc == 0 {
    if e(N) == 100 & e(nquantiles) == 50 {
        mat _bd = e(bindata)
        local nrows = rowsof(_bd)
        if `nrows' == 50 {
            test_pass "many bins (50 bins, 100 obs)"
        }
        else {
            test_fail "many bins" "bindata rows=`nrows' expected 50"
        }
    }
    else {
        test_fail "many bins" "N=`=e(N)' expected 100, nquantiles=`=e(nquantiles)' expected 50"
    }
}
else {
    test_fail "many bins" "rc=`=_rc'"
}

* Collinear control
clear
set seed 400
set obs 1000
gen x = runiform()
gen w1 = runiform()
gen w2 = 2 * w1  // Collinear
gen y = 2*x + w1 + rnormal()

capture cbinscatter y x, controls(w1 w2) nograph
if _rc == 0 {
    test_pass "collinear control (handled)"
}
else {
    test_fail "collinear control" "unexpected error rc=`=_rc'"
}

* Single FE group (absorb with 1 level)
clear
set obs 100
gen id = 1  // Single group
gen x = runiform()
gen y = 2*x + rnormal()

capture cbinscatter y x, absorb(id) nograph
if _rc == 0 | _rc == 2001 {
    test_pass "single FE group (rc=`=_rc')"
}
else {
    test_fail "single FE group" "unexpected rc=`=_rc'"
}

* Empty by-group after filtering (regression test for segfault fix)
* This used to crash when by() was used but filtering left only one group
sysuse auto, clear
capture cbinscatter price mpg if foreign == 0, by(foreign) nograph
if _rc == 0 & e(num_groups) == 1 {
    test_pass "empty by-group after filtering"
}
else {
    test_fail "empty by-group after filtering" "rc=`=_rc' num_groups=`=e(num_groups)'"
}

/*******************************************************************************
 * SECTION 20: verbose option
 ******************************************************************************/
print_section "verbose Option"

sysuse auto, clear
capture cbinscatter price mpg, verbose nograph
if _rc == 0 {
    test_pass "verbose option"
}
else {
    test_fail "verbose option" "rc=`=_rc'"
}

/*******************************************************************************
 * SECTION: Intentional Error Tests
 *
 * These tests verify that cbinscatter returns the same error codes as binscatter
 * when given invalid inputs or error conditions.
 * Note: binscatter is a user-written command (ssc install binscatter).
 * If binscatter is not installed, tests compare against expected behavior.
 ******************************************************************************/
print_section "Intentional Error Tests"

* Check if binscatter is installed
capture which binscatter
local binscatter_installed = (_rc == 0)

* Variable doesn't exist
sysuse auto, clear
if `binscatter_installed' {
    test_error_match, stata_cmd(binscatter price nonexistent_var, nograph) ctools_cmd(cbinscatter price nonexistent_var, nograph) testname("nonexistent variable")
}
else {
    capture cbinscatter price nonexistent_var, nograph
    if _rc != 0 {
        test_pass "[error] nonexistent variable (rc=`=_rc') [binscatter not installed]"
    }
    else {
        test_fail "[error] nonexistent variable" "should have errored"
    }
}

* String variable as y
sysuse auto, clear
if `binscatter_installed' {
    test_error_match, stata_cmd(binscatter make mpg, nograph) ctools_cmd(cbinscatter make mpg, nograph) testname("string y variable")
}
else {
    capture cbinscatter make mpg, nograph
    if _rc != 0 {
        test_pass "[error] string y variable (rc=`=_rc') [binscatter not installed]"
    }
    else {
        test_fail "[error] string y variable" "should have errored"
    }
}

* String variable as x
sysuse auto, clear
if `binscatter_installed' {
    test_error_match, stata_cmd(binscatter price make, nograph) ctools_cmd(cbinscatter price make, nograph) testname("string x variable")
}
else {
    capture cbinscatter price make, nograph
    if _rc != 0 {
        test_pass "[error] string x variable (rc=`=_rc') [binscatter not installed]"
    }
    else {
        test_fail "[error] string x variable" "should have errored"
    }
}

* Invalid nquantiles (0)
sysuse auto, clear
if `binscatter_installed' {
    test_error_match, stata_cmd(binscatter price mpg, nquantiles(0) nograph) ctools_cmd(cbinscatter price mpg, nquantiles(0) nograph) testname("nquantiles(0)")
}
else {
    capture cbinscatter price mpg, nquantiles(0) nograph
    if _rc != 0 {
        test_pass "[error] nquantiles(0) (rc=`=_rc') [binscatter not installed]"
    }
    else {
        test_fail "[error] nquantiles(0)" "should have errored"
    }
}

* Invalid nquantiles (negative)
sysuse auto, clear
if `binscatter_installed' {
    test_error_match, stata_cmd(binscatter price mpg, nquantiles(-5) nograph) ctools_cmd(cbinscatter price mpg, nquantiles(-5) nograph) testname("negative nquantiles")
}
else {
    capture cbinscatter price mpg, nquantiles(-5) nograph
    if _rc != 0 {
        test_pass "[error] negative nquantiles (rc=`=_rc') [binscatter not installed]"
    }
    else {
        test_fail "[error] negative nquantiles" "should have errored"
    }
}

* No observations after if
sysuse auto, clear
if `binscatter_installed' {
    test_error_match, stata_cmd(binscatter price mpg if price > 100000, nograph) ctools_cmd(cbinscatter price mpg if price > 100000, nograph) testname("no observations after if")
}
else {
    capture cbinscatter price mpg if price > 100000, nograph
    if _rc != 0 {
        test_pass "[error] no observations after if (rc=`=_rc') [binscatter not installed]"
    }
    else {
        test_fail "[error] no observations after if" "should have errored"
    }
}

* End of cbinscatter validation
noi print_summary "cbinscatter"
}
