
  ___  ____  ____  ____  ____ ®
 /__    /   ____/   /   ____/      StataNow 18.5
___/   /   /___/   /   /___/       MP—Parallel Edition

 Statistics and Data Science       Copyright 1985-2023 StataCorp LLC
                                   StataCorp
                                   4905 Lakeway Drive
                                   College Station, Texas 77845 USA
                                   800-782-8272        https://www.stata.com
                                   979-696-4600        service@stata.com

Stata license: Unlimited-user 16-core network, expiring  2 Jul 2026
Serial number: 501909320077
  Licensed to: Michael Droste
               Stanford University GSB

Notes:
      1. Stata is running in batch mode.
      2. Unicode is supported; see help unicode_advice.
      3. More than 2 billion observations are allowed; see help obs_advice.
      4. Maximum number of variables is set to 5,000 but can be increased;
          see help set_maxvar.


Running /Users/Mike/Documents/Stata/profile.do ...

. do validate_cimport.do 

. /****************************************************************************
> ***
>  * validate_cimport.do
>  *
>  * Comprehensive validation tests for cimport vs import delimited
>  * Tests CSV import functionality across various scenarios
>  ****************************************************************************
> **/
. 
. do "validate_setup.do"

. *============================================================================
> ===
. * PROGRAM: validate_setup.do
. * PURPOSE: Helper programs for validation
. *============================================================================
> ===
. 
. version 14.0

. clear all

. set more off

. set trace off

. 
. * Add build directory with ctools to adopath
. adopath + "../build"
  [1]  (BASE)      "/Applications/Stata/ado/base/"
  [2]  (SITE)      "/Applications/Stata/ado/site/"
  [3]              "."
  [4]  (PERSONAL)  "/Users/Mike/Documents/Stata/ado/personal/"
  [5]  (PLUS)      "/Users/Mike/Library/Application Support/Stata/ado/plus/"
  [6]  (OLDPLACE)  "~/ado/"
  [7]              "../build"

. 
. * Global counters
. global TESTS_PASSED = 0

. global TESTS_FAILED = 0

. global TESTS_TOTAL = 0

. 
. *----------------------------------------------------------------------------
> ---
. * Helper program to compare scalars with tolerance
. *----------------------------------------------------------------------------
> ---
. 
. capture program drop assert_scalar_equal

. program define assert_scalar_equal
  1.     args name val1 val2 tol testname
  2. 
.     if "`tol'" == "" local tol = 1e-6
  3. 
.     global TESTS_TOTAL = $TESTS_TOTAL + 1
  4. 
.     local diff = abs(`val1' - `val2')
  5.     * Handle exact match case (for integers like N)
.     if `diff' == 0 | `diff' < `tol' {
  6.         global TESTS_PASSED = $TESTS_PASSED + 1
  7.         di as result "  PASS: `testname' (`name' diff = " %12.2e `diff' ")
> "
  8.     }
  9.     else {
 10.         global TESTS_FAILED = $TESTS_FAILED + 1
 11.         di as error "  FAIL: `testname' (`name': `val1' vs `val2', diff = 
> " %12.2e `diff' ")"
 12.     }
 13. end

. 
. *----------------------------------------------------------------------------
> ---
. * Helper program to compare matrices
. *----------------------------------------------------------------------------
> ---
. 
. capture program drop assert_matrix_equal

. program define assert_matrix_equal
  1.     args mat1 mat2 tol testname
  2. 
.     if "`tol'" == "" local tol = 1e-6
  3. 
.     global TESTS_TOTAL = $TESTS_TOTAL + 1
  4. 
.     tempname diff
  5.     matrix `diff' = `mat1' - `mat2'
  6.     local maxdiff = 0
  7.     local rows = rowsof(`diff')
  8.     local cols = colsof(`diff')
  9.     forvalues i = 1/`rows' {
 10.         forvalues j = 1/`cols' {
 11.             local d = abs(`diff'[`i', `j'])
 12.             if `d' > `maxdiff' local maxdiff = `d'
 13.         }
 14.     }
 15. 
.     if `maxdiff' < `tol' {
 16.         global TESTS_PASSED = $TESTS_PASSED + 1
 17.         di as result "  PASS: `testname' (max diff = " %12.2e `maxdiff' ")
> "
 18.     }
 19.     else {
 20.         global TESTS_FAILED = $TESTS_FAILED + 1
 21.         di as error "  FAIL: `testname' (max diff = " %12.2e `maxdiff' ")"
 22.     }
 23. end

. 
. *----------------------------------------------------------------------------
> ---
. * Helper program to compare variables
. *----------------------------------------------------------------------------
> ---
. 
. capture program drop assert_var_equal

. program define assert_var_equal
  1.     args var1 var2 tol testname
  2. 
.     if "`tol'" == "" local tol = 1e-10
  3. 
.     global TESTS_TOTAL = $TESTS_TOTAL + 1
  4. 
.     quietly count if abs(`var1' - `var2') > `tol'
  5.     local ndiff = r(N)
  6. 
.     if `ndiff' == 0 {
  7.         global TESTS_PASSED = $TESTS_PASSED + 1
  8.         di as result "  PASS: `testname' (all values match)"
  9.     }
 10.     else {
 11.         global TESTS_FAILED = $TESTS_FAILED + 1
 12.         di as error "  FAIL: `testname' (`ndiff' values differ)"
 13.     }
 14. end

. 
. *----------------------------------------------------------------------------
> ---
. * Helper program to compare string variables
. *----------------------------------------------------------------------------
> ---
. 
. capture program drop assert_strvar_equal

. program define assert_strvar_equal
  1.     args var1 var2 testname
  2. 
.     global TESTS_TOTAL = $TESTS_TOTAL + 1
  3. 
.     quietly count if `var1' != `var2'
  4.     local ndiff = r(N)
  5. 
.     if `ndiff' == 0 {
  6.         global TESTS_PASSED = $TESTS_PASSED + 1
  7.         di as result "  PASS: `testname' (all values match)"
  8.     }
  9.     else {
 10.         global TESTS_FAILED = $TESTS_FAILED + 1
 11.         di as error "  FAIL: `testname' (`ndiff' values differ)"
 12.     }
 13. end

. 
. *----------------------------------------------------------------------------
> ---
. * Helper to check if two datasets are identical (with fallback to sorted comp
> arison)
. 
. *----------------------------------------------------------------------------
> ---
. 
. capture program drop assert_data_equal

. program define assert_data_equal
  1.     args file1 file2 testname
  2. 
.     global TESTS_TOTAL = $TESTS_TOTAL + 1
  3. 
.     preserve
  4.     capture quietly {
  5.         use "`file1'", clear
  6.         cf _all using "`file2'"
  7.     }
  8.     local rc = _rc
  9.     restore
 10. 
.     if `rc' == 0 {
 11.         global TESTS_PASSED = $TESTS_PASSED + 1
 12.         di as result "  PASS: `testname' (datasets identical)"
 13.     }
 14.     else {
 15.         * Try sorting both datasets by all variables before comparing
.         preserve
 16.         capture quietly {
 17.             use "`file1'", clear
 18.             ds
 19.             local allvars `r(varlist)'
 20.             sort `allvars'
 21.             tempfile sorted1
 22.             save `sorted1', replace
 23. 
.             use "`file2'", clear
 24.             sort `allvars'
 25.             cf _all using `sorted1'
 26.         }
 27.         local rc2 = _rc
 28.         restore
 29. 
.         if `rc2' == 0 {
 30.             global TESTS_PASSED = $TESTS_PASSED + 1
 31.             di as result "  PASS: `testname' (datasets identical after sor
> ting)"
 32.         }
 33.         else {
 34.             global TESTS_FAILED = $TESTS_FAILED + 1
 35.             di as error "  FAIL: `testname' (datasets differ even after so
> rting)"
 36.         }
 37.     }
 38. end

. 
. *----------------------------------------------------------------------------
> ---
. * Helper to compare datasets after sorting (merges where row order may differ
> )
. *----------------------------------------------------------------------------
> ---
. 
. capture program drop assert_data_equal_sorted

. program define assert_data_equal_sorted
  1.     args file1 file2 sortkey testname
  2. 
.     global TESTS_TOTAL = $TESTS_TOTAL + 1
  3. 
.     preserve
  4.     quietly {
  5.         * Load and sort first file
.         use "`file1'", clear
  6.         sort `sortkey', stable
  7.         tempfile sorted1
  8.         save `sorted1'
  9. 
.         * Load and sort second file
.         use "`file2'", clear
 10.         sort `sortkey', stable
 11.         tempfile sorted2
 12.         save `sorted2'
 13. 
.         * Compare
.         use `sorted1', clear
 14.         cf _all using `sorted2'
 15.     }
 16.     local rc = _rc
 17.     restore
 18. 
.     if `rc' == 0 {
 19.         global TESTS_PASSED = $TESTS_PASSED + 1
 20.         di as result "  PASS: `testname' (datasets identical after sorting
> )"
 21.     }
 22.     else {
 23.         global TESTS_FAILED = $TESTS_FAILED + 1
 24.         di as error "  FAIL: `testname' (datasets differ even after sortin
> g)"
 25.     }
 26. end

. 
. *----------------------------------------------------------------------------
> ---
. * Helper to compare merge counts (merges where row order may differ)
. *----------------------------------------------------------------------------
> ---
. 
. capture program drop assert_merge_counts_equal

. program define assert_merge_counts_equal
  1.     args file1 file2 testname
  2. 
.     global TESTS_TOTAL = $TESTS_TOTAL + 1
  3. 
.     preserve
  4.     quietly {
  5.         use "`file1'", clear
  6.         local n1 = _N
  7.         count if _merge == 1
  8.         local m1_1 = r(N)
  9.         count if _merge == 2
 10.         local m1_2 = r(N)
 11.         count if _merge == 3
 12.         local m1_3 = r(N)
 13. 
.         use "`file2'", clear
 14.         local n2 = _N
 15.         count if _merge == 1
 16.         local m2_1 = r(N)
 17.         count if _merge == 2
 18.         local m2_2 = r(N)
 19.         count if _merge == 3
 20.         local m2_3 = r(N)
 21.     }
 22.     restore
 23. 
.     local pass = (`n1' == `n2') & (`m1_1' == `m2_1') & (`m1_2' == `m2_2') & (
> `m1_3' == `m2_3')
 24. 
.     if `pass' {
 25.         global TESTS_PASSED = $TESTS_PASSED + 1
 26.         di as result "  PASS: `testname' (N=`n1', m1=`m1_1', m2=`m1_2', m3
> =`m1_3')"
 27.     }
 28.     else {
 29.         global TESTS_FAILED = $TESTS_FAILED + 1
 30.         di as error "  FAIL: `testname' counts differ"
 31.         di as error "    Stata: N=`n1', m1=`m1_1', m2=`m1_2', m3=`m1_3'"
 32.         di as error "    cmerge: N=`n2', m1=`m2_1', m2=`m2_2', m3=`m2_3'"
 33.     }
 34. end

. 
. *----------------------------------------------------------------------------
> ---
. * Helper program to print section header
. *----------------------------------------------------------------------------
> ---
. 
. capture program drop print_section

. program define print_section
  1.     args title
  2.     di as text ""
  3.     di as text "{hline 70}"
  4.     di as text "`title'"
  5.     di as text "{hline 70}"
  6. end

. 
. * Helper program to print test summary
. capture program drop print_summary

. program define print_summary
  1.     args component
  2.     di as text ""
  3.     di as text "{hline 70}"
  4.     di as text "SUMMARY: `component'"
  5.     di as text "{hline 70}"
  6.     di as text "Tests passed: " as result $TESTS_PASSED
  7.     di as text "Tests failed: " as result $TESTS_FAILED
  8.     di as text "Total tests:  " as result $TESTS_TOTAL
  9.     if $TESTS_FAILED > 0 {
 10.         di as error "VALIDATION FAILED"
 11.     }
 12.     else {
 13.         di as result "ALL TESTS PASSED"
 14.     }
 15.     di as text "{hline 70}"
 16. end

. 
. * Load benchmark helper programs
. do "benchmark_helpers.do"

. /****************************************************************************
> ***
>  * benchmark_helpers.do
>  *
>  * Benchmark helper programs for ctools validation test suite
>  * Each program runs both ctools and Stata native commands, compares results,
>  * and reports PASS/FAIL in a concise format.
>  *
>  * Usage:
>  *   benchmark_sort varlist [, options]
>  *   benchmark_merge mergetype keyvar using filename [, options]
>  *   benchmark_reghdfe depvar indepvars, absorb(varlist) [options]
>  *   benchmark_qreg depvar indepvars [, options]
>  *   benchmark_import using filename [, options]
>  *   benchmark_export using filename [, options]
>  ****************************************************************************
> **/
. 
. /****************************************************************************
> ***
>  * benchmark_sort
>  *
>  * Compare csort vs sort, stable
>  *
>  * Syntax: benchmark_sort varlist [, testname(string) algorithm(string)]
>  *
>  * Example:
>  *   sysuse auto, clear
>  *   benchmark_sort price
>  *   benchmark_sort foreign rep78, testname("multi-var sort")
>  *   benchmark_sort price, algorithm(msd)
>  *   benchmark_sort price, algorithm(timsort)
>  ****************************************************************************
> **/
. capture program drop benchmark_sort

. program define benchmark_sort
  1.     syntax varlist [, testname(string) ALGorithm(string)]
  2. 
.     if "`testname'" == "" local testname "sort `varlist'"
  3.     if "`algorithm'" != "" local testname "`testname' [alg=`algorithm']"
  4. 
.     global TESTS_TOTAL = $TESTS_TOTAL + 1
  5. 
.     preserve
  6. 
.     * Save original data
.     tempfile original
  7.     quietly save `original'
  8. 
.     * Run Stata sort, stable
.     sort `varlist', stable
  9.     tempfile stata_sorted
 10.     quietly save `stata_sorted'
 11. 
.     * Restore and run csort
.     use `original', clear
 12.     if "`algorithm'" != "" {
 13.         csort `varlist', algorithm(`algorithm')
 14.     }
 15.     else {
 16.         csort `varlist'
 17.     }
 18. 
.     * Compare datasets
.     capture quietly cf _all using `stata_sorted'
 19.     local rc = _rc
 20. 
.     restore
 21. 
.     if `rc' == 0 {
 22.         global TESTS_PASSED = $TESTS_PASSED + 1
 23.         di as result "[PASS] `testname'"
 24.     }
 25.     else {
 26.         global TESTS_FAILED = $TESTS_FAILED + 1
 27.         di as error "[FAIL] `testname'"
 28.     }
 29. end

. 
. /****************************************************************************
> ***
>  * benchmark_sort_all_algs
>  *
>  * Run benchmark_sort with all three algorithms (lsd, msd, timsort)
>  *
>  * Syntax: benchmark_sort_all_algs varlist [, testname(string)]
>  *
>  * Example:
>  *   benchmark_sort_all_algs price, testname("numeric sort")
>  ****************************************************************************
> **/
. capture program drop benchmark_sort_all_algs

. program define benchmark_sort_all_algs
  1.     syntax varlist [, testname(string)]
  2. 
.     if "`testname'" == "" local testname "sort `varlist'"
  3. 
.     * Test all three algorithms
.     benchmark_sort `varlist', testname("`testname'") algorithm(lsd)
  4.     benchmark_sort `varlist', testname("`testname'") algorithm(msd)
  5.     benchmark_sort `varlist', testname("`testname'") algorithm(timsort)
  6. end

. 
. /****************************************************************************
> ***
>  * benchmark_merge
>  *
>  * Compare cmerge vs merge
>  * Validates: (1) _merge counts match, (2) datasets are identical via cf _all
>  *
>  * Syntax: benchmark_merge mergetype keyvar using filename [, keep(string)
>  *         generate(string) nogenerate keepusing(varlist) testname(string)]
>  *
>  * Example:
>  *   benchmark_merge 1:1 id using mydata.dta
>  *   benchmark_merge m:1 foreign using lookup.dta, keep(match)
>  ****************************************************************************
> **/
. capture program drop benchmark_merge

. program define benchmark_merge
  1.     syntax anything using/, [keep(string) GENerate(name) NOGENerate KEEPUS
> ing(string) ///
>         testname(string) SORTed ASSert(string) UPDATE REPLACE FORCE NOLabel N
> ONotes]
  2. 
.     * Parse merge type and key vars
.     gettoken mergetype keyvars : anything
  3. 
.     if "`testname'" == "" local testname "merge `mergetype' `keyvars'"
  4. 
.     global TESTS_TOTAL = $TESTS_TOTAL + 1
  5. 
.     * Build option string
.     local opts ""
  6.     if "`keep'" != "" local opts "`opts' keep(`keep')"
  7.     if "`generate'" != "" local opts "`opts' generate(`generate')"
  8.     if "`nogenerate'" != "" local opts "`opts' nogenerate"
  9.     if "`keepusing'" != "" local opts "`opts' keepusing(`keepusing')"
 10.     if "`sorted'" != "" local opts "`opts' sorted"
 11.     if "`assert'" != "" local opts "`opts' assert(`assert')"
 12.     if "`update'" != "" local opts "`opts' update"
 13.     if "`replace'" != "" local opts "`opts' replace"
 14.     if "`force'" != "" local opts "`opts' force"
 15.     if "`nolabel'" != "" local opts "`opts' nolabel"
 16.     if "`nonotes'" != "" local opts "`opts' nonotes"
 17. 
.     preserve
 18. 
.     * Save original data
.     tempfile original
 19.     quietly save `original'
 20. 
.     * Run Stata merge
.     merge `mergetype' `keyvars' using `using', `opts'
 21. 
.     * Get _merge counts from Stata
.     capture confirm variable _merge
 22.     if _rc == 0 {
 23.         quietly count if _merge == 1
 24.         local stata_m1 = r(N)
 25.         quietly count if _merge == 2
 26.         local stata_m2 = r(N)
 27.         quietly count if _merge == 3
 28.         local stata_m3 = r(N)
 29.     }
 30.     else {
 31.         local stata_m1 = .
 32.         local stata_m2 = .
 33.         local stata_m3 = .
 34.     }
 35. 
.     * Save unsorted for first comparison
.     tempfile stata_merged_unsorted
 36.     quietly save `stata_merged_unsorted'
 37. 
.     * Sort by ALL variables for deterministic comparison
.     * (keyvars alone may leave order undefined within key groups)
.     qui ds
 38.     local allvars `r(varlist)'
 39.     sort `allvars'
 40.     tempfile stata_merged_sorted
 41.     quietly save `stata_merged_sorted'
 42. 
.     * Restore and run cmerge
.     use `original', clear
 43.     cmerge `mergetype' `keyvars' using `using', `opts'
 44. 
.     * Get _merge counts from cmerge
.     capture confirm variable _merge
 45.     if _rc == 0 {
 46.         quietly count if _merge == 1
 47.         local cmerge_m1 = r(N)
 48.         quietly count if _merge == 2
 49.         local cmerge_m2 = r(N)
 50.         quietly count if _merge == 3
 51.         local cmerge_m3 = r(N)
 52.     }
 53.     else {
 54.         local cmerge_m1 = .
 55.         local cmerge_m2 = .
 56.         local cmerge_m3 = .
 57.     }
 58. 
.     * Check 1: _merge counts match
.     local counts_match = 1
 59.     if `stata_m1' != `cmerge_m1' | `stata_m2' != `cmerge_m2' | `stata_m3' 
> != `cmerge_m3' {
 60.         local counts_match = 0
 61.     }
 62. 
.     * Check 2a: cf _all BEFORE sorting (tests if order is identical too)
.     capture quietly cf _all using `stata_merged_unsorted'
 63.     local cf_unsorted_rc = _rc
 64. 
.     * Check 2b: cf _all AFTER sorting by ALL variables (tests content only)
.     qui ds
 65.     local allvars `r(varlist)'
 66.     sort `allvars'
 67.     capture quietly cf _all using `stata_merged_sorted'
 68.     local cf_sorted_rc = _rc
 69. 
.     restore
 70. 
.     * Report results
.     if `counts_match' & `cf_sorted_rc' == 0 {
 71.         global TESTS_PASSED = $TESTS_PASSED + 1
 72.         if `cf_unsorted_rc' == 0 {
 73.             di as result "[PASS] `testname'"
 74.         }
 75.         else {
 76.             di as result "[PASS] `testname' (sort order differs)"
 77.         }
 78.     }
 79.     else {
 80.         global TESTS_FAILED = $TESTS_FAILED + 1
 81.         if !`counts_match' {
 82.             di as error "[FAIL] `testname' (_merge counts: m1:`stata_m1'!=
> `cmerge_m1' m2:`stata_m2'!=`cmerge_m2' m3:`stata_m3'!=`cmerge_m3')"
 83.         }
 84.         else {
 85.             di as error "[FAIL] `testname' (cf _all: datasets differ even 
> after sorting)"
 86.         }
 87.     }
 88. end

. 
. /****************************************************************************
> ***
>  * benchmark_reghdfe
>  *
>  * Compare creghdfe vs reghdfe
>  *
>  * Syntax: benchmark_reghdfe depvar indepvars [weight], absorb(varlist)
>  *         [vce(string) testname(string) tol(real)]
>  *
>  * Example:
>  *   benchmark_reghdfe price mpg weight, absorb(foreign)
>  *   benchmark_reghdfe y x1 x2 [aw=w], absorb(firm year) vce(cluster firm)
>  ****************************************************************************
> **/
. capture program drop benchmark_reghdfe

. program define benchmark_reghdfe
  1.     syntax varlist(min=2 fv) [aw fw pw] [if] [in], Absorb(varlist) [vce(st
> ring) testname(string) tol(real 1e-6)]
  2. 
.     gettoken depvar indepvars : varlist
  3. 
.     if "`testname'" == "" local testname "reghdfe `depvar' ... , absorb(`abso
> rb')"
  4. 
.     global TESTS_TOTAL = $TESTS_TOTAL + 1
  5. 
.     * Build weight string
.     local wtexp ""
  6.     if "`weight'" != "" local wtexp "[`weight'`exp']"
  7. 
.     * Build vce option
.     local vceopt ""
  8.     if "`vce'" != "" local vceopt "vce(`vce')"
  9. 
.     preserve
 10. 
.     * Run reghdfe
.     quietly reghdfe `depvar' `indepvars' `wtexp' `if' `in', absorb(`absorb') 
> `vceopt'
 11.     matrix reghdfe_b = e(b)
 12.     local reghdfe_N = e(N)
 13. 
.     * Run creghdfe
.     quietly creghdfe `depvar' `indepvars' `wtexp' `if' `in', absorb(`absorb')
>  `vceopt'
 14.     matrix creghdfe_b = e(b)
 15.     local creghdfe_N = e(N)
 16. 
.     restore
 17. 
.     * Compare N
.     if `reghdfe_N' != `creghdfe_N' {
 18.         global TESTS_FAILED = $TESTS_FAILED + 1
 19.         di as error "[FAIL] `testname' (N: `reghdfe_N' != `creghdfe_N')"
 20.         exit
 21.     }
 22. 
.     * Compare coefficients
.     tempname diff
 23.     matrix `diff' = reghdfe_b - creghdfe_b
 24.     local cols = colsof(`diff')
 25.     local maxdiff = 0
 26.     forvalues j = 1/`cols' {
 27.         local d = abs(`diff'[1, `j'])
 28.         if `d' > `maxdiff' local maxdiff = `d'
 29.     }
 30. 
.     if `maxdiff' < `tol' {
 31.         global TESTS_PASSED = $TESTS_PASSED + 1
 32.         di as result "[PASS] `testname'"
 33.     }
 34.     else {
 35.         global TESTS_FAILED = $TESTS_FAILED + 1
 36.         di as error "[FAIL] `testname' (max coef diff: " %9.2e `maxdiff' "
> )"
 37.     }
 38. end

. 
. /****************************************************************************
> ***
>  * benchmark_qreg
>  *
>  * Compare cqreg vs qreg
>  *
>  * Syntax: benchmark_qreg depvar indepvars [, quantile(real) vce(string)
>  *         testname(string) tol(real)]
>  *
>  * Example:
>  *   benchmark_qreg price mpg weight
>  *   benchmark_qreg price mpg weight, quantile(0.25)
>  ****************************************************************************
> **/
. capture program drop benchmark_qreg

. program define benchmark_qreg
  1.     syntax varlist(min=2 fv) [if] [in], [Quantile(real 0.5) vce(string) te
> stname(string) tol(real 1e-6)]
  2. 
.     gettoken depvar indepvars : varlist
  3. 
.     if "`testname'" == "" local testname "qreg `depvar' ... , q(`quantile')"
  4. 
.     global TESTS_TOTAL = $TESTS_TOTAL + 1
  5. 
.     * Build vce option
.     local vceopt ""
  6.     if "`vce'" != "" local vceopt "vce(`vce')"
  7. 
.     preserve
  8. 
.     * Run qreg
.     quietly qreg `depvar' `indepvars' `if' `in', quantile(`quantile') `vceopt
> '
  9.     matrix qreg_b = e(b)
 10.     local qreg_N = e(N)
 11. 
.     * Run cqreg
.     quietly cqreg `depvar' `indepvars' `if' `in', quantile(`quantile') `vceop
> t'
 12.     matrix cqreg_b = e(b)
 13.     local cqreg_N = e(N)
 14. 
.     restore
 15. 
.     * Compare N
.     if `qreg_N' != `cqreg_N' {
 16.         global TESTS_FAILED = $TESTS_FAILED + 1
 17.         di as error "[FAIL] `testname' (N: `qreg_N' != `cqreg_N')"
 18.         exit
 19.     }
 20. 
.     * Compare coefficients
.     tempname diff
 21.     matrix `diff' = qreg_b - cqreg_b
 22.     local cols = colsof(`diff')
 23.     local maxdiff = 0
 24.     forvalues j = 1/`cols' {
 25.         local d = abs(`diff'[1, `j'])
 26.         if `d' > `maxdiff' local maxdiff = `d'
 27.     }
 28. 
.     if `maxdiff' < `tol' {
 29.         global TESTS_PASSED = $TESTS_PASSED + 1
 30.         di as result "[PASS] `testname'"
 31.     }
 32.     else {
 33.         global TESTS_FAILED = $TESTS_FAILED + 1
 34.         di as error "[FAIL] `testname' (max coef diff: " %9.2e `maxdiff' "
> )"
 35.     }
 36. end

. 
. /****************************************************************************
> ***
>  * benchmark_import
>  *
>  * Compare cimport delimited vs import delimited
>  *
>  * Syntax: benchmark_import using filename [, delimiters(string) varnames(str
> ing)
>  *         case(string) rowrange(string) testname(string)]
>  *
>  * Example:
>  *   benchmark_import using "data.csv"
>  *   benchmark_import using "data.tsv", delimiters(tab)
>  ****************************************************************************
> **/
. capture program drop benchmark_import

. program define benchmark_import
  1.     syntax using/, [DELIMiters(string) VARNames(string) CASE(string) ROWRa
> nge(string) testname(string) clear]
  2. 
.     if "`testname'" == "" local testname "import `using'"
  3. 
.     global TESTS_TOTAL = $TESTS_TOTAL + 1
  4. 
.     * Build option string
.     local opts "clear"
  5.     if "`delimiters'" != "" local opts "`opts' delimiters(`delimiters')"
  6.     if "`varnames'" != "" local opts "`opts' varnames(`varnames')"
  7.     if "`case'" != "" local opts "`opts' case(`case')"
  8.     if "`rowrange'" != "" local opts "`opts' rowrange(`rowrange')"
  9. 
.     preserve
 10. 
.     * Run Stata import
.     import delimited `using', `opts'
 11.     local stata_n = _N
 12.     local stata_k = c(k)
 13.     tempfile stata_import
 14.     quietly save `stata_import'
 15. 
.     * Run cimport
.     cimport delimited `using', `opts'
 16.     local cimport_n = _N
 17.     local cimport_k = c(k)
 18. 
.     restore
 19. 
.     * Compare dimensions
.     if `stata_n' == `cimport_n' & `stata_k' == `cimport_k' {
 20.         global TESTS_PASSED = $TESTS_PASSED + 1
 21.         di as result "[PASS] `testname' (N=`stata_n', K=`stata_k')"
 22.     }
 23.     else {
 24.         global TESTS_FAILED = $TESTS_FAILED + 1
 25.         di as error "[FAIL] `testname' (N: `stata_n'!=`cimport_n', K: `sta
> ta_k'!=`cimport_k')"
 26.     }
 27. end

. 
. /****************************************************************************
> ***
>  * benchmark_export
>  *
>  * Compare cexport delimited vs export delimited
>  *
>  * Syntax: benchmark_export [varlist] using filename [, delimiter(string)
>  *         novarnames quote testname(string)]
>  *
>  * Example:
>  *   benchmark_export using "output.csv", replace
>  *   benchmark_export price mpg using "output.csv", replace
>  ****************************************************************************
> **/
. capture program drop benchmark_export

. program define benchmark_export
  1.     syntax [varlist] using/, [DELIMiter(string) NOVARNames QUOTE replace t
> estname(string)]
  2. 
.     if "`testname'" == "" local testname "export `using'"
  3. 
.     global TESTS_TOTAL = $TESTS_TOTAL + 1
  4. 
.     * Build option string
.     local opts "replace"
  5.     if "`delimiter'" != "" local opts "`opts' delimiter(`delimiter')"
  6.     if "`novarnames'" != "" local opts "`opts' novarnames"
  7.     if "`quote'" != "" local opts "`opts' quote"
  8. 
.     preserve
  9. 
.     * Generate temp filenames
.     tempfile stata_export cexport_export
 10.     local stata_csv = subinstr("`stata_export'", ".dta", ".csv", .)
 11.     local cexport_csv = subinstr("`cexport_export'", ".dta", ".csv", .)
 12. 
.     * Run Stata export
.     if "`varlist'" != "" {
 13.         export delimited `varlist' using "`stata_csv'", `opts'
 14.     }
 15.     else {
 16.         export delimited using "`stata_csv'", `opts'
 17.     }
 18. 
.     * Run cexport
.     if "`varlist'" != "" {
 19.         cexport delimited `varlist' using "`cexport_csv'", `opts'
 20.     }
 21.     else {
 22.         cexport delimited using "`cexport_csv'", `opts'
 23.     }
 24. 
.     * Reimport and compare
.     import delimited using "`stata_csv'", clear
 25.     local stata_n = _N
 26.     local stata_k = c(k)
 27. 
.     import delimited using "`cexport_csv'", clear
 28.     local cexport_n = _N
 29.     local cexport_k = c(k)
 30. 
.     * Cleanup temp files
.     capture erase "`stata_csv'"
 31.     capture erase "`cexport_csv'"
 32. 
.     restore
 33. 
.     * Compare dimensions
.     if `stata_n' == `cexport_n' & `stata_k' == `cexport_k' {
 34.         global TESTS_PASSED = $TESTS_PASSED + 1
 35.         di as result "[PASS] `testname' (N=`stata_n', K=`cexport_k')"
 36.     }
 37.     else {
 38.         global TESTS_FAILED = $TESTS_FAILED + 1
 39.         di as error "[FAIL] `testname' (N: `stata_n'!=`cexport_n', K: `sta
> ta_k'!=`cexport_k')"
 40.     }
 41. end

. 
. /****************************************************************************
> ***
>  * benchmark_binscatter (for cbinscatter validation)
>  *
>  * Compare cbinscatter vs binscatter (if installed)
>  *
>  * Syntax: benchmark_binscatter yvar xvar [, controls(varlist) absorb(varlist
> )
>  *         by(varname) nquantiles(int) testname(string)]
>  ****************************************************************************
> **/
. capture program drop benchmark_binscatter

. program define benchmark_binscatter
  1.     syntax varlist(min=2 max=2) [if] [in] [aw fw pw], [controls(varlist) A
> bsorb(varlist) BY(varname) NQuantiles(integer 20) testname(string) nograph]
  2. 
.     gettoken yvar xvar : varlist
  3. 
.     if "`testname'" == "" local testname "binscatter `yvar' `xvar'"
  4. 
.     global TESTS_TOTAL = $TESTS_TOTAL + 1
  5. 
.     * Build option string
.     local opts "nquantiles(`nquantiles') nograph"
  6.     if "`controls'" != "" local opts "`opts' controls(`controls')"
  7.     if "`absorb'" != "" local opts "`opts' absorb(`absorb')"
  8.     if "`by'" != "" local opts "`opts' by(`by')"
  9. 
.     * Build weight string
.     local wtexp ""
 10.     if "`weight'" != "" local wtexp "[`weight'`exp']"
 11. 
.     preserve
 12. 
.     * Run cbinscatter
.     quietly cbinscatter `yvar' `xvar' `wtexp' `if' `in', `opts'
 13.     local cbin_N = e(N)
 14.     local cbin_nq = e(nquantiles)
 15.     matrix cbin_data = e(bindata)
 16. 
.     restore
 17. 
.     * Verify cbinscatter produced valid results
.     if `cbin_N' > 0 & `cbin_nq' == `nquantiles' {
 18.         global TESTS_PASSED = $TESTS_PASSED + 1
 19.         di as result "[PASS] `testname' (N=`cbin_N', bins=`cbin_nq')"
 20.     }
 21.     else {
 22.         global TESTS_FAILED = $TESTS_FAILED + 1
 23.         di as error "[FAIL] `testname' (N=`cbin_N', bins=`cbin_nq')"
 24.     }
 25. end

. 
. di as text "Benchmark helper programs loaded"
Benchmark helper programs loaded

. 
end of do-file

. 
. di as text ""


. di as text "ctools validation framework loaded"
ctools validation framework loaded

. di as text ""


. 
end of do-file

. 
. di as text ""


. di as text "=================================================================
> ====="
======================================================================

. di as text "              CIMPORT VALIDATION TEST SUITE"
              CIMPORT VALIDATION TEST SUITE

. di as text "=================================================================
> ====="
======================================================================

. 
. * Create temp directory for test files
. capture mkdir "temp"

. 
. /****************************************************************************
> ***
>  * Create test CSV files
>  ****************************************************************************
> **/
. print_section "Creating test files"

----------------------------------------------------------------------
Creating test files
----------------------------------------------------------------------

. 
. * Test file 1: Basic CSV with mixed types
. capture file close _all

. file open csvfile using "temp/basic.csv", write replace
(file temp/basic.csv not found)

. file write csvfile "id,name,value,price" _n

. file write csvfile "1,Alpha,100,10.5" _n

. file write csvfile "2,Beta,200,20.75" _n

. file write csvfile "3,Gamma,300,30.125" _n

. file write csvfile "4,Delta,400,40.0" _n

. file write csvfile "5,Epsilon,500,50.99" _n

. file close csvfile

. 
. * Test file 2: Tab-delimited
. file open tsvfile using "temp/basic.tsv", write replace
(file temp/basic.tsv not found)

. file write tsvfile "id" _tab "name" _tab "value" _n

. file write tsvfile "1" _tab "Apple" _tab "1.5" _n

. file write tsvfile "2" _tab "Banana" _tab "2.5" _n

. file write tsvfile "3" _tab "Cherry" _tab "3.5" _n

. file close tsvfile

. 
. * Test file 3: CSV with missing values
. file open csvfile using "temp/missing.csv", write replace
(file temp/missing.csv not found)

. file write csvfile "id,name,value,score" _n

. file write csvfile "1,A,100,95" _n

. file write csvfile "2,B,,85" _n

. file write csvfile "3,,300," _n

. file write csvfile "4,D,400,75" _n

. file write csvfile "5,E,," _n

. file close csvfile

. 
. * Test file 4: CSV with quoted fields
. file open csvfile using "temp/quoted.csv", write replace
(file temp/quoted.csv not found)

. file write csvfile `"id,name,description"' _n

. file write csvfile `"1,"Smith, John","A person with comma""' _n

. file write csvfile `"2,"Doe, Jane","Another person""' _n

. file write csvfile `"3,Simple,No quotes needed"' _n

. file close csvfile

. 
. * Test file 5: CSV without header
. file open csvfile using "temp/noheader.csv", write replace
(file temp/noheader.csv not found)

. file write csvfile "1,Alpha,100" _n

. file write csvfile "2,Beta,200" _n

. file write csvfile "3,Gamma,300" _n

. file close csvfile

. 
. * Test file 6: CSV with various numeric formats
. file open csvfile using "temp/numeric.csv", write replace
(file temp/numeric.csv not found)

. file write csvfile "integer,decimal,scientific,negative" _n

. file write csvfile "1,1.5,1e10,-100" _n

. file write csvfile "100,0.001,2.5e-5,-0.5" _n

. file write csvfile "999999,123.456789,1e-10,-999999" _n

. file close csvfile

. 
. * Test file 7: Large CSV
. file open csvfile using "temp/large.csv", write replace
(file temp/large.csv not found)

. file write csvfile "id,group,value1,value2,label" _n

. forvalues i = 1/5000 {
  2.     local g = mod(`i', 100) + 1
  3.     local v1 = `i' * 1.5
  4.     local v2 = runiform() * 1000
  5.     file write csvfile "`i',`g',`v1',`v2',item`i'" _n
  6. }

. file close csvfile

. 
. * Test file 8: CSV with UPPER case headers
. file open csvfile using "temp/uppercase.csv", write replace
(file temp/uppercase.csv not found)

. file write csvfile "ID,NAME,VALUE" _n

. file write csvfile "1,Test,100" _n

. file write csvfile "2,Data,200" _n

. file close csvfile

. 
. di as result "[DONE] Test files created"
[DONE] Test files created

. 
. /****************************************************************************
> ***
>  * Basic import tests
>  ****************************************************************************
> **/
. print_section "Basic import tests"

----------------------------------------------------------------------
Basic import tests
----------------------------------------------------------------------

. 
. benchmark_import using "temp/basic.csv", testname("basic CSV")
(encoding automatically selected: ISO-8859-1)
(4 vars, 5 obs)
Scanned 5 rows, 4 columns
Loaded 5 observations
(           5 observations read)
[PASS] basic CSV (N=5, K=4)

. 
. benchmark_import using "temp/basic.tsv", delimiters(tab) testname("tab-delimi
> ted")
(encoding automatically selected: ISO-8859-1)
(3 vars, 3 obs)
Scanned 3 rows, 3 columns
Loaded 3 observations
(           3 observations read)
[PASS] tab-delimited (N=3, K=3)

. 
. benchmark_import using "temp/missing.csv", testname("with missing values")
(encoding automatically selected: ISO-8859-1)
(4 vars, 5 obs)
Scanned 5 rows, 4 columns
Loaded 5 observations
(           5 observations read)
[PASS] with missing values (N=5, K=4)

. 
. benchmark_import using "temp/quoted.csv", testname("quoted fields")
(encoding automatically selected: ISO-8859-1)
(3 vars, 3 obs)
Scanned 3 rows, 3 columns
Loaded 3 observations
(           3 observations read)
[PASS] quoted fields (N=3, K=3)

. 
. benchmark_import using "temp/noheader.csv", varnames(nonames) testname("no he
> ader")
(encoding automatically selected: ISO-8859-1)
(3 vars, 3 obs)
Scanned 3 rows, 3 columns
Loaded 3 observations
(           3 observations read)
[PASS] no header (N=3, K=3)

. 
. benchmark_import using "temp/uppercase.csv", case(lower) testname("case(lower
> )")
(encoding automatically selected: ISO-8859-1)
(3 vars, 2 obs)
Scanned 2 rows, 3 columns
Loaded 2 observations
(           2 observations read)
[PASS] case(lower) (N=2, K=3)

. 
. benchmark_import using "temp/numeric.csv", testname("numeric formats")
(encoding automatically selected: ISO-8859-1)
(4 vars, 3 obs)
Scanned 3 rows, 4 columns
Loaded 3 observations
(           3 observations read)
[PASS] numeric formats (N=3, K=4)

. 
. benchmark_import using "temp/large.csv", testname("large file (5K rows)")
(encoding automatically selected: ISO-8859-1)
(5 vars, 5,000 obs)
Scanned 5000 rows, 5 columns
Loaded 5000 observations
(       5,000 observations read)
[PASS] large file (5K rows) (N=5000, K=5)

. 
. /****************************************************************************
> ***
>  * case() option tests
>  ****************************************************************************
> **/
. print_section "case() option tests"

----------------------------------------------------------------------
case() option tests
----------------------------------------------------------------------

. 
. benchmark_import using "temp/uppercase.csv", case(upper) testname("case(upper
> )")
(encoding automatically selected: ISO-8859-1)
(3 vars, 2 obs)
Scanned 2 rows, 3 columns
Loaded 2 observations
(           2 observations read)
[PASS] case(upper) (N=2, K=3)

. 
. benchmark_import using "temp/uppercase.csv", case(preserve) testname("case(pr
> eserve)")
(encoding automatically selected: ISO-8859-1)
(3 vars, 2 obs)
Scanned 2 rows, 3 columns
Loaded 2 observations
(           2 observations read)
[PASS] case(preserve) (N=2, K=3)

. 
. /****************************************************************************
> ***
>  * NOTE: rowrange() option is parsed but not yet implemented in cimport
>  * Tests skipped until feature is implemented
>  ****************************************************************************
> **/
. 
. /****************************************************************************
> ***
>  * bindquotes() option tests
>  ****************************************************************************
> **/
. print_section "bindquotes() option tests"

----------------------------------------------------------------------
bindquotes() option tests
----------------------------------------------------------------------

. 
. * Create a test file with embedded quotes
. capture file close _all

. file open csvfile using "temp/bindquotes_test.csv", write replace
(file temp/bindquotes_test.csv not found)

. file write csvfile `"id,name,value"' _n

. file write csvfile `"1,"Simple Name",100"' _n

. file write csvfile `"2,"Name with ""quotes""",200"' _n

. file write csvfile `"3,NoQuotes,300"' _n

. file close csvfile

. 
. benchmark_import using "temp/bindquotes_test.csv", testname("bindquotes defau
> lt (strict)")
(encoding automatically selected: ISO-8859-2)
(3 vars, 3 obs)
Scanned 3 rows, 3 columns
Loaded 3 observations
(           3 observations read)
[PASS] bindquotes default (strict) (N=3, K=3)

. 
. * Comprehensive quote binding edge case test
. capture file close _all

. file open csvfile using "temp/quote_edge_cases.csv", write replace
(file temp/quote_edge_cases.csv not found)

. file write csvfile `"a,b,c"' _n

. file write csvfile `""normal","field","here""' _n

. file write csvfile `""has""embedded""quotes","more""quotes","end""' _n

. file write csvfile `""comma,inside","another,comma","ok""' _n

. file write csvfile `""",empty,"""' _n

. file write csvfile `"unquoted,"then quoted","back unquoted""' _n

. file write csvfile `""spaces  ","  spaces","  both  ""' _n

. file close csvfile

. 
. * Test comprehensive quote binding
. import delimited using "temp/quote_edge_cases.csv", clear varnames(1) bindquo
> tes(strict)
(encoding automatically selected: ISO-8859-1)
(3 vars, 6 obs)

. rename (a b c) (a_stata b_stata c_stata)

. tempfile stata_quote_data

. save `stata_quote_data'
file /var/folders/5l/0w9hn2t9637147hqnm7bgk000000gn/T//St39645.000001 saved
    as .dta format

. 
. cimport delimited using "temp/quote_edge_cases.csv", clear varnames(1)
Scanned 6 rows, 3 columns
Loaded 6 observations
(           6 observations read)

. merge 1:1 _n using `stata_quote_data', nogen

    Result                      Number of obs
    -----------------------------------------
    Not matched                             0
    Matched                                 6  
    -----------------------------------------

. 
. gen match_a = (a == a_stata)

. gen match_b = (b == b_stata)

. gen match_c = (c == c_stata)

. 
. qui count if match_a == 1 & match_b == 1 & match_c == 1

. local all_match = r(N)

. local total_rows = _N

. 
. global TESTS_TOTAL = $TESTS_TOTAL + 1

. if `all_match' == `total_rows' {
.     global TESTS_PASSED = $TESTS_PASSED + 1
.     di as result "[PASS] quote binding edge cases (`all_match'/`total_rows' r
> ows)"
[PASS] quote binding edge cases (6/6 rows)
. }

. else {
.     global TESTS_FAILED = $TESTS_FAILED + 1
.     di as error "[FAIL] quote binding edge cases (`all_match'/`total_rows' ro
> ws match)"
. }

. 
. /****************************************************************************
> ***
>  * Round-trip tests (export then reimport)
>  ****************************************************************************
> **/
. print_section "Round-trip tests"

----------------------------------------------------------------------
Round-trip tests
----------------------------------------------------------------------

. 
. sysuse auto, clear
(1978 automobile data)

. export delimited using "temp/auto_export.csv", replace
(file temp/auto_export.csv not found)
file temp/auto_export.csv saved

. benchmark_import using "temp/auto_export.csv", testname("auto round-trip")
(encoding automatically selected: ISO-8859-1)
(12 vars, 74 obs)
Scanned 74 rows, 12 columns
Loaded 74 observations
(          74 observations read)
[PASS] auto round-trip (N=74, K=12)

. 
. sysuse census, clear
(1980 Census data by state)

. export delimited using "temp/census_export.csv", replace
(file temp/census_export.csv not found)
file temp/census_export.csv saved

. benchmark_import using "temp/census_export.csv", testname("census round-trip"
> )
(encoding automatically selected: ISO-8859-2)
(13 vars, 50 obs)
Scanned 50 rows, 13 columns
Loaded 50 observations
(          50 observations read)
[PASS] census round-trip (N=50, K=13)

. 
. /****************************************************************************
> ***
>  * Detailed comparison tests
>  ****************************************************************************
> **/
. print_section "Detailed comparison tests"

----------------------------------------------------------------------
Detailed comparison tests
----------------------------------------------------------------------

. 
. * String variable types
. import delimited using "temp/basic.csv", clear
(encoding automatically selected: ISO-8859-1)
(4 vars, 5 obs)

. local stata_type : type name

. 
. cimport delimited using "temp/basic.csv", clear
Scanned 5 rows, 4 columns
Loaded 5 observations
(           5 observations read)

. local cimport_type : type name

. 
. global TESTS_TOTAL = $TESTS_TOTAL + 1

. if substr("`stata_type'", 1, 3) == "str" & substr("`cimport_type'", 1, 3) == 
> "str" {
.     global TESTS_PASSED = $TESTS_PASSED + 1
.     di as result "[PASS] string type inference"
[PASS] string type inference
. }

. else {
.     global TESTS_FAILED = $TESTS_FAILED + 1
.     di as error "[FAIL] string type inference"
. }

. 
. * Numeric type inference
. import delimited using "temp/basic.csv", clear
(encoding automatically selected: ISO-8859-1)
(4 vars, 5 obs)

. local stata_id_type : type id

. local stata_value_type : type value

. 
. cimport delimited using "temp/basic.csv", clear
Scanned 5 rows, 4 columns
Loaded 5 observations
(           5 observations read)

. local cimport_id_type : type id

. local cimport_value_type : type value

. 
. local id_numeric = ("`stata_id_type'" != "str" & "`cimport_id_type'" != "str"
> )

. local value_numeric = ("`stata_value_type'" != "str" & "`cimport_value_type'"
>  != "str")

. 
. global TESTS_TOTAL = $TESTS_TOTAL + 1

. if `id_numeric' & `value_numeric' {
.     global TESTS_PASSED = $TESTS_PASSED + 1
.     di as result "[PASS] numeric type inference"
[PASS] numeric type inference
. }

. else {
.     global TESTS_FAILED = $TESTS_FAILED + 1
.     di as error "[FAIL] numeric type inference"
. }

. 
. * Missing value counts
. import delimited using "temp/missing.csv", clear
(encoding automatically selected: ISO-8859-1)
(4 vars, 5 obs)

. quietly count if missing(value)

. local stata_miss = r(N)

. 
. cimport delimited using "temp/missing.csv", clear
Scanned 5 rows, 4 columns
Loaded 5 observations
(           5 observations read)

. quietly count if missing(value)

. local cimport_miss = r(N)

. 
. global TESTS_TOTAL = $TESTS_TOTAL + 1

. if `stata_miss' == `cimport_miss' {
.     global TESTS_PASSED = $TESTS_PASSED + 1
.     di as result "[PASS] missing value handling"
[PASS] missing value handling
. }

. else {
.     global TESTS_FAILED = $TESTS_FAILED + 1
.     di as error "[FAIL] missing value handling"
. }

. 
. * Large file statistics
. import delimited using "temp/large.csv", clear
(encoding automatically selected: ISO-8859-1)
(5 vars, 5,000 obs)

. quietly summarize value1

. local stata_mean = r(mean)

. local stata_n = _N

. 
. cimport delimited using "temp/large.csv", clear
Scanned 5000 rows, 5 columns
Loaded 5000 observations
(       5,000 observations read)

. quietly summarize value1

. local cimport_mean = r(mean)

. local cimport_n = _N

. 
. global TESTS_TOTAL = $TESTS_TOTAL + 1

. if `stata_n' == `cimport_n' & abs(`stata_mean' - `cimport_mean') < 1e-6 {
.     global TESTS_PASSED = $TESTS_PASSED + 1
.     di as result "[PASS] large file statistics"
[PASS] large file statistics
. }

. else {
.     global TESTS_FAILED = $TESTS_FAILED + 1
.     di as error "[FAIL] large file statistics"
. }

. 
. /****************************************************************************
> ***
>  * Cleanup temp files
>  ****************************************************************************
> **/
. capture erase "temp/basic.csv"

. capture erase "temp/basic.tsv"

. capture erase "temp/missing.csv"

. capture erase "temp/quoted.csv"

. capture erase "temp/noheader.csv"

. capture erase "temp/numeric.csv"

. capture erase "temp/large.csv"

. capture erase "temp/uppercase.csv"

. capture erase "temp/auto_export.csv"

. capture erase "temp/census_export.csv"

. capture erase "temp/bindquotes_test.csv"

. capture erase "temp/quote_edge_cases.csv"

. 
. /****************************************************************************
> ***
>  * SUMMARY
>  ****************************************************************************
> **/
. print_summary "cimport"

----------------------------------------------------------------------
SUMMARY: cimport
----------------------------------------------------------------------
Tests passed: 18
Tests failed: 0
Total tests:  18
ALL TESTS PASSED
----------------------------------------------------------------------

. 
. * Return error code if any tests failed
. if $TESTS_FAILED > 0 {
.     exit 1
. }

. 
end of do-file
