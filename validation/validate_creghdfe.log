
  ___  ____  ____  ____  ____ ®
 /__    /   ____/   /   ____/      StataNow 18.5
___/   /   /___/   /   /___/       MP—Parallel Edition

 Statistics and Data Science       Copyright 1985-2023 StataCorp LLC
                                   StataCorp
                                   4905 Lakeway Drive
                                   College Station, Texas 77845 USA
                                   800-782-8272        https://www.stata.com
                                   979-696-4600        service@stata.com

Stata license: Unlimited-user 16-core network, expiring  2 Jul 2026
Serial number: 501909320077
  Licensed to: Michael Droste
               Stanford University GSB

Notes:
      1. Stata is running in batch mode.
      2. Unicode is supported; see help unicode_advice.
      3. More than 2 billion observations are allowed; see help obs_advice.
      4. Maximum number of variables is set to 5,000 but can be increased;
          see help set_maxvar.


Running /Users/Mike/Documents/Stata/profile.do ...

. do validate_creghdfe.do 

. /****************************************************************************
> ***
>  * validate_creghdfe.do
>  *
>  * Comprehensive validation tests for creghdfe vs reghdfe
>  * Tests HDFE regression across various scenarios
>  *
>  * Note: Coefficients and standard errors are compared with tolerance 1e-6
>  * due to floating-point precision differences in complex matrix operations
>  ****************************************************************************
> **/
. 
. do "validate_setup.do"

. *============================================================================
> ===
. * PROGRAM: validate_setup.do
. * PURPOSE: Helper programs for validation
. *============================================================================
> ===
. 
. version 14.0

. clear all

. set more off

. set trace off

. 
. * Add build directory with ctools to adopath
. adopath + "../build"
  [1]  (BASE)      "/Applications/Stata/ado/base/"
  [2]  (SITE)      "/Applications/Stata/ado/site/"
  [3]              "."
  [4]  (PERSONAL)  "/Users/Mike/Documents/Stata/ado/personal/"
  [5]  (PLUS)      "/Users/Mike/Library/Application Support/Stata/ado/plus/"
  [6]  (OLDPLACE)  "~/ado/"
  [7]              "../build"

. 
. * Global counters
. global TESTS_PASSED = 0

. global TESTS_FAILED = 0

. global TESTS_TOTAL = 0

. 
. *----------------------------------------------------------------------------
> ---
. * Helper program to compare scalars with tolerance
. *----------------------------------------------------------------------------
> ---
. 
. capture program drop assert_scalar_equal

. program define assert_scalar_equal
  1.     args name val1 val2 tol testname
  2. 
.     if "`tol'" == "" local tol = 1e-6
  3. 
.     global TESTS_TOTAL = $TESTS_TOTAL + 1
  4. 
.     local diff = abs(`val1' - `val2')
  5.     * Handle exact match case (for integers like N)
.     if `diff' == 0 | `diff' < `tol' {
  6.         global TESTS_PASSED = $TESTS_PASSED + 1
  7.         di as result "  PASS: `testname' (`name' diff = " %12.2e `diff' ")
> "
  8.     }
  9.     else {
 10.         global TESTS_FAILED = $TESTS_FAILED + 1
 11.         di as error "  FAIL: `testname' (`name': `val1' vs `val2', diff = 
> " %12.2e `diff' ")"
 12.     }
 13. end

. 
. *----------------------------------------------------------------------------
> ---
. * Helper program to compare matrices
. *----------------------------------------------------------------------------
> ---
. 
. capture program drop assert_matrix_equal

. program define assert_matrix_equal
  1.     args mat1 mat2 tol testname
  2. 
.     if "`tol'" == "" local tol = 1e-6
  3. 
.     global TESTS_TOTAL = $TESTS_TOTAL + 1
  4. 
.     tempname diff
  5.     matrix `diff' = `mat1' - `mat2'
  6.     local maxdiff = 0
  7.     local rows = rowsof(`diff')
  8.     local cols = colsof(`diff')
  9.     forvalues i = 1/`rows' {
 10.         forvalues j = 1/`cols' {
 11.             local d = abs(`diff'[`i', `j'])
 12.             if `d' > `maxdiff' local maxdiff = `d'
 13.         }
 14.     }
 15. 
.     if `maxdiff' < `tol' {
 16.         global TESTS_PASSED = $TESTS_PASSED + 1
 17.         di as result "  PASS: `testname' (max diff = " %12.2e `maxdiff' ")
> "
 18.     }
 19.     else {
 20.         global TESTS_FAILED = $TESTS_FAILED + 1
 21.         di as error "  FAIL: `testname' (max diff = " %12.2e `maxdiff' ")"
 22.     }
 23. end

. 
. *----------------------------------------------------------------------------
> ---
. * Helper program to compare variables
. *----------------------------------------------------------------------------
> ---
. 
. capture program drop assert_var_equal

. program define assert_var_equal
  1.     args var1 var2 tol testname
  2. 
.     if "`tol'" == "" local tol = 1e-10
  3. 
.     global TESTS_TOTAL = $TESTS_TOTAL + 1
  4. 
.     quietly count if abs(`var1' - `var2') > `tol'
  5.     local ndiff = r(N)
  6. 
.     if `ndiff' == 0 {
  7.         global TESTS_PASSED = $TESTS_PASSED + 1
  8.         di as result "  PASS: `testname' (all values match)"
  9.     }
 10.     else {
 11.         global TESTS_FAILED = $TESTS_FAILED + 1
 12.         di as error "  FAIL: `testname' (`ndiff' values differ)"
 13.     }
 14. end

. 
. *----------------------------------------------------------------------------
> ---
. * Helper program to compare string variables
. *----------------------------------------------------------------------------
> ---
. 
. capture program drop assert_strvar_equal

. program define assert_strvar_equal
  1.     args var1 var2 testname
  2. 
.     global TESTS_TOTAL = $TESTS_TOTAL + 1
  3. 
.     quietly count if `var1' != `var2'
  4.     local ndiff = r(N)
  5. 
.     if `ndiff' == 0 {
  6.         global TESTS_PASSED = $TESTS_PASSED + 1
  7.         di as result "  PASS: `testname' (all values match)"
  8.     }
  9.     else {
 10.         global TESTS_FAILED = $TESTS_FAILED + 1
 11.         di as error "  FAIL: `testname' (`ndiff' values differ)"
 12.     }
 13. end

. 
. *----------------------------------------------------------------------------
> ---
. * Helper to check if two datasets are identical (with fallback to sorted comp
> arison)
. 
. *----------------------------------------------------------------------------
> ---
. 
. capture program drop assert_data_equal

. program define assert_data_equal
  1.     args file1 file2 testname
  2. 
.     global TESTS_TOTAL = $TESTS_TOTAL + 1
  3. 
.     preserve
  4.     capture quietly {
  5.         use "`file1'", clear
  6.         cf _all using "`file2'"
  7.     }
  8.     local rc = _rc
  9.     restore
 10. 
.     if `rc' == 0 {
 11.         global TESTS_PASSED = $TESTS_PASSED + 1
 12.         di as result "  PASS: `testname' (datasets identical)"
 13.     }
 14.     else {
 15.         * Try sorting both datasets by all variables before comparing
.         preserve
 16.         capture quietly {
 17.             use "`file1'", clear
 18.             ds
 19.             local allvars `r(varlist)'
 20.             sort `allvars'
 21.             tempfile sorted1
 22.             save `sorted1', replace
 23. 
.             use "`file2'", clear
 24.             sort `allvars'
 25.             cf _all using `sorted1'
 26.         }
 27.         local rc2 = _rc
 28.         restore
 29. 
.         if `rc2' == 0 {
 30.             global TESTS_PASSED = $TESTS_PASSED + 1
 31.             di as result "  PASS: `testname' (datasets identical after sor
> ting)"
 32.         }
 33.         else {
 34.             global TESTS_FAILED = $TESTS_FAILED + 1
 35.             di as error "  FAIL: `testname' (datasets differ even after so
> rting)"
 36.         }
 37.     }
 38. end

. 
. *----------------------------------------------------------------------------
> ---
. * Helper to compare datasets after sorting (merges where row order may differ
> )
. *----------------------------------------------------------------------------
> ---
. 
. capture program drop assert_data_equal_sorted

. program define assert_data_equal_sorted
  1.     args file1 file2 sortkey testname
  2. 
.     global TESTS_TOTAL = $TESTS_TOTAL + 1
  3. 
.     preserve
  4.     quietly {
  5.         * Load and sort first file
.         use "`file1'", clear
  6.         sort `sortkey', stable
  7.         tempfile sorted1
  8.         save `sorted1'
  9. 
.         * Load and sort second file
.         use "`file2'", clear
 10.         sort `sortkey', stable
 11.         tempfile sorted2
 12.         save `sorted2'
 13. 
.         * Compare
.         use `sorted1', clear
 14.         cf _all using `sorted2'
 15.     }
 16.     local rc = _rc
 17.     restore
 18. 
.     if `rc' == 0 {
 19.         global TESTS_PASSED = $TESTS_PASSED + 1
 20.         di as result "  PASS: `testname' (datasets identical after sorting
> )"
 21.     }
 22.     else {
 23.         global TESTS_FAILED = $TESTS_FAILED + 1
 24.         di as error "  FAIL: `testname' (datasets differ even after sortin
> g)"
 25.     }
 26. end

. 
. *----------------------------------------------------------------------------
> ---
. * Helper to compare merge counts (merges where row order may differ)
. *----------------------------------------------------------------------------
> ---
. 
. capture program drop assert_merge_counts_equal

. program define assert_merge_counts_equal
  1.     args file1 file2 testname
  2. 
.     global TESTS_TOTAL = $TESTS_TOTAL + 1
  3. 
.     preserve
  4.     quietly {
  5.         use "`file1'", clear
  6.         local n1 = _N
  7.         count if _merge == 1
  8.         local m1_1 = r(N)
  9.         count if _merge == 2
 10.         local m1_2 = r(N)
 11.         count if _merge == 3
 12.         local m1_3 = r(N)
 13. 
.         use "`file2'", clear
 14.         local n2 = _N
 15.         count if _merge == 1
 16.         local m2_1 = r(N)
 17.         count if _merge == 2
 18.         local m2_2 = r(N)
 19.         count if _merge == 3
 20.         local m2_3 = r(N)
 21.     }
 22.     restore
 23. 
.     local pass = (`n1' == `n2') & (`m1_1' == `m2_1') & (`m1_2' == `m2_2') & (
> `m1_3' == `m2_3')
 24. 
.     if `pass' {
 25.         global TESTS_PASSED = $TESTS_PASSED + 1
 26.         di as result "  PASS: `testname' (N=`n1', m1=`m1_1', m2=`m1_2', m3
> =`m1_3')"
 27.     }
 28.     else {
 29.         global TESTS_FAILED = $TESTS_FAILED + 1
 30.         di as error "  FAIL: `testname' counts differ"
 31.         di as error "    Stata: N=`n1', m1=`m1_1', m2=`m1_2', m3=`m1_3'"
 32.         di as error "    cmerge: N=`n2', m1=`m2_1', m2=`m2_2', m3=`m2_3'"
 33.     }
 34. end

. 
. *----------------------------------------------------------------------------
> ---
. * Helper program to print section header
. *----------------------------------------------------------------------------
> ---
. 
. capture program drop print_section

. program define print_section
  1.     args title
  2.     di as text ""
  3.     di as text "{hline 70}"
  4.     di as text "`title'"
  5.     di as text "{hline 70}"
  6. end

. 
. * Helper program to print test summary
. capture program drop print_summary

. program define print_summary
  1.     args component
  2.     di as text ""
  3.     di as text "{hline 70}"
  4.     di as text "SUMMARY: `component'"
  5.     di as text "{hline 70}"
  6.     di as text "Tests passed: " as result $TESTS_PASSED
  7.     di as text "Tests failed: " as result $TESTS_FAILED
  8.     di as text "Total tests:  " as result $TESTS_TOTAL
  9.     if $TESTS_FAILED > 0 {
 10.         di as error "VALIDATION FAILED"
 11.     }
 12.     else {
 13.         di as result "ALL TESTS PASSED"
 14.     }
 15.     di as text "{hline 70}"
 16. end

. 
. * Load benchmark helper programs
. do "benchmark_helpers.do"

. /****************************************************************************
> ***
>  * benchmark_helpers.do
>  *
>  * Benchmark helper programs for ctools validation test suite
>  * Each program runs both ctools and Stata native commands, compares results,
>  * and reports PASS/FAIL in a concise format.
>  *
>  * Usage:
>  *   benchmark_sort varlist [, options]
>  *   benchmark_merge mergetype keyvar using filename [, options]
>  *   benchmark_reghdfe depvar indepvars, absorb(varlist) [options]
>  *   benchmark_qreg depvar indepvars [, options]
>  *   benchmark_import using filename [, options]
>  *   benchmark_export using filename [, options]
>  ****************************************************************************
> **/
. 
. /****************************************************************************
> ***
>  * benchmark_sort
>  *
>  * Compare csort vs sort, stable
>  *
>  * Syntax: benchmark_sort varlist [, testname(string) algorithm(string)]
>  *
>  * Example:
>  *   sysuse auto, clear
>  *   benchmark_sort price
>  *   benchmark_sort foreign rep78, testname("multi-var sort")
>  *   benchmark_sort price, algorithm(msd)
>  *   benchmark_sort price, algorithm(timsort)
>  ****************************************************************************
> **/
. capture program drop benchmark_sort

. program define benchmark_sort
  1.     syntax varlist [, testname(string) ALGorithm(string)]
  2. 
.     if "`testname'" == "" local testname "sort `varlist'"
  3.     if "`algorithm'" != "" local testname "`testname' [alg=`algorithm']"
  4. 
.     global TESTS_TOTAL = $TESTS_TOTAL + 1
  5. 
.     preserve
  6. 
.     * Save original data
.     tempfile original
  7.     quietly save `original'
  8. 
.     * Run Stata sort, stable
.     sort `varlist', stable
  9.     tempfile stata_sorted
 10.     quietly save `stata_sorted'
 11. 
.     * Restore and run csort
.     use `original', clear
 12.     if "`algorithm'" != "" {
 13.         csort `varlist', algorithm(`algorithm')
 14.     }
 15.     else {
 16.         csort `varlist'
 17.     }
 18. 
.     * Compare datasets
.     capture quietly cf _all using `stata_sorted'
 19.     local rc = _rc
 20. 
.     restore
 21. 
.     if `rc' == 0 {
 22.         global TESTS_PASSED = $TESTS_PASSED + 1
 23.         di as result "[PASS] `testname'"
 24.     }
 25.     else {
 26.         global TESTS_FAILED = $TESTS_FAILED + 1
 27.         di as error "[FAIL] `testname'"
 28.     }
 29. end

. 
. /****************************************************************************
> ***
>  * benchmark_sort_all_algs
>  *
>  * Run benchmark_sort with all three algorithms (lsd, msd, timsort)
>  *
>  * Syntax: benchmark_sort_all_algs varlist [, testname(string)]
>  *
>  * Example:
>  *   benchmark_sort_all_algs price, testname("numeric sort")
>  ****************************************************************************
> **/
. capture program drop benchmark_sort_all_algs

. program define benchmark_sort_all_algs
  1.     syntax varlist [, testname(string)]
  2. 
.     if "`testname'" == "" local testname "sort `varlist'"
  3. 
.     * Test all three algorithms
.     benchmark_sort `varlist', testname("`testname'") algorithm(lsd)
  4.     benchmark_sort `varlist', testname("`testname'") algorithm(msd)
  5.     benchmark_sort `varlist', testname("`testname'") algorithm(timsort)
  6. end

. 
. /****************************************************************************
> ***
>  * benchmark_merge
>  *
>  * Compare cmerge vs merge
>  * Validates: (1) _merge counts match, (2) datasets are identical via cf _all
>  *
>  * Syntax: benchmark_merge mergetype keyvar using filename [, keep(string)
>  *         generate(string) nogenerate keepusing(varlist) testname(string)]
>  *
>  * Example:
>  *   benchmark_merge 1:1 id using mydata.dta
>  *   benchmark_merge m:1 foreign using lookup.dta, keep(match)
>  ****************************************************************************
> **/
. capture program drop benchmark_merge

. program define benchmark_merge
  1.     syntax anything using/, [keep(string) GENerate(name) NOGENerate KEEPUS
> ing(string) ///
>         testname(string) SORTed ASSert(string) UPDATE REPLACE FORCE NOLabel N
> ONotes]
  2. 
.     * Parse merge type and key vars
.     gettoken mergetype keyvars : anything
  3. 
.     if "`testname'" == "" local testname "merge `mergetype' `keyvars'"
  4. 
.     global TESTS_TOTAL = $TESTS_TOTAL + 1
  5. 
.     * Build option string
.     local opts ""
  6.     if "`keep'" != "" local opts "`opts' keep(`keep')"
  7.     if "`generate'" != "" local opts "`opts' generate(`generate')"
  8.     if "`nogenerate'" != "" local opts "`opts' nogenerate"
  9.     if "`keepusing'" != "" local opts "`opts' keepusing(`keepusing')"
 10.     if "`sorted'" != "" local opts "`opts' sorted"
 11.     if "`assert'" != "" local opts "`opts' assert(`assert')"
 12.     if "`update'" != "" local opts "`opts' update"
 13.     if "`replace'" != "" local opts "`opts' replace"
 14.     if "`force'" != "" local opts "`opts' force"
 15.     if "`nolabel'" != "" local opts "`opts' nolabel"
 16.     if "`nonotes'" != "" local opts "`opts' nonotes"
 17. 
.     preserve
 18. 
.     * Save original data
.     tempfile original
 19.     quietly save `original'
 20. 
.     * Run Stata merge
.     merge `mergetype' `keyvars' using `using', `opts'
 21. 
.     * Get _merge counts from Stata
.     capture confirm variable _merge
 22.     if _rc == 0 {
 23.         quietly count if _merge == 1
 24.         local stata_m1 = r(N)
 25.         quietly count if _merge == 2
 26.         local stata_m2 = r(N)
 27.         quietly count if _merge == 3
 28.         local stata_m3 = r(N)
 29.     }
 30.     else {
 31.         local stata_m1 = .
 32.         local stata_m2 = .
 33.         local stata_m3 = .
 34.     }
 35. 
.     * Save unsorted for first comparison
.     tempfile stata_merged_unsorted
 36.     quietly save `stata_merged_unsorted'
 37. 
.     * Sort by ALL variables for deterministic comparison
.     * (keyvars alone may leave order undefined within key groups)
.     qui ds
 38.     local allvars `r(varlist)'
 39.     sort `allvars'
 40.     tempfile stata_merged_sorted
 41.     quietly save `stata_merged_sorted'
 42. 
.     * Restore and run cmerge
.     use `original', clear
 43.     cmerge `mergetype' `keyvars' using `using', `opts'
 44. 
.     * Get _merge counts from cmerge
.     capture confirm variable _merge
 45.     if _rc == 0 {
 46.         quietly count if _merge == 1
 47.         local cmerge_m1 = r(N)
 48.         quietly count if _merge == 2
 49.         local cmerge_m2 = r(N)
 50.         quietly count if _merge == 3
 51.         local cmerge_m3 = r(N)
 52.     }
 53.     else {
 54.         local cmerge_m1 = .
 55.         local cmerge_m2 = .
 56.         local cmerge_m3 = .
 57.     }
 58. 
.     * Check 1: _merge counts match
.     local counts_match = 1
 59.     if `stata_m1' != `cmerge_m1' | `stata_m2' != `cmerge_m2' | `stata_m3' 
> != `cmerge_m3' {
 60.         local counts_match = 0
 61.     }
 62. 
.     * Check 2a: cf _all BEFORE sorting (tests if order is identical too)
.     capture quietly cf _all using `stata_merged_unsorted'
 63.     local cf_unsorted_rc = _rc
 64. 
.     * Check 2b: cf _all AFTER sorting by ALL variables (tests content only)
.     qui ds
 65.     local allvars `r(varlist)'
 66.     sort `allvars'
 67.     capture quietly cf _all using `stata_merged_sorted'
 68.     local cf_sorted_rc = _rc
 69. 
.     restore
 70. 
.     * Report results
.     if `counts_match' & `cf_sorted_rc' == 0 {
 71.         global TESTS_PASSED = $TESTS_PASSED + 1
 72.         if `cf_unsorted_rc' == 0 {
 73.             di as result "[PASS] `testname'"
 74.         }
 75.         else {
 76.             di as result "[PASS] `testname' (sort order differs)"
 77.         }
 78.     }
 79.     else {
 80.         global TESTS_FAILED = $TESTS_FAILED + 1
 81.         if !`counts_match' {
 82.             di as error "[FAIL] `testname' (_merge counts: m1:`stata_m1'!=
> `cmerge_m1' m2:`stata_m2'!=`cmerge_m2' m3:`stata_m3'!=`cmerge_m3')"
 83.         }
 84.         else {
 85.             di as error "[FAIL] `testname' (cf _all: datasets differ even 
> after sorting)"
 86.         }
 87.     }
 88. end

. 
. /****************************************************************************
> ***
>  * benchmark_reghdfe
>  *
>  * Compare creghdfe vs reghdfe
>  *
>  * Syntax: benchmark_reghdfe depvar indepvars [weight], absorb(varlist)
>  *         [vce(string) testname(string) tol(real)]
>  *
>  * Example:
>  *   benchmark_reghdfe price mpg weight, absorb(foreign)
>  *   benchmark_reghdfe y x1 x2 [aw=w], absorb(firm year) vce(cluster firm)
>  ****************************************************************************
> **/
. capture program drop benchmark_reghdfe

. program define benchmark_reghdfe
  1.     syntax varlist(min=2 fv) [aw fw pw] [if] [in], Absorb(varlist) [vce(st
> ring) testname(string) tol(real 1e-6)]
  2. 
.     gettoken depvar indepvars : varlist
  3. 
.     if "`testname'" == "" local testname "reghdfe `depvar' ... , absorb(`abso
> rb')"
  4. 
.     global TESTS_TOTAL = $TESTS_TOTAL + 1
  5. 
.     * Build weight string
.     local wtexp ""
  6.     if "`weight'" != "" local wtexp "[`weight'`exp']"
  7. 
.     * Build vce option
.     local vceopt ""
  8.     if "`vce'" != "" local vceopt "vce(`vce')"
  9. 
.     preserve
 10. 
.     * Run reghdfe
.     quietly reghdfe `depvar' `indepvars' `wtexp' `if' `in', absorb(`absorb') 
> `vceopt'
 11.     matrix reghdfe_b = e(b)
 12.     local reghdfe_N = e(N)
 13. 
.     * Run creghdfe
.     quietly creghdfe `depvar' `indepvars' `wtexp' `if' `in', absorb(`absorb')
>  `vceopt'
 14.     matrix creghdfe_b = e(b)
 15.     local creghdfe_N = e(N)
 16. 
.     restore
 17. 
.     * Compare N
.     if `reghdfe_N' != `creghdfe_N' {
 18.         global TESTS_FAILED = $TESTS_FAILED + 1
 19.         di as error "[FAIL] `testname' (N: `reghdfe_N' != `creghdfe_N')"
 20.         exit
 21.     }
 22. 
.     * Compare coefficients
.     tempname diff
 23.     matrix `diff' = reghdfe_b - creghdfe_b
 24.     local cols = colsof(`diff')
 25.     local maxdiff = 0
 26.     forvalues j = 1/`cols' {
 27.         local d = abs(`diff'[1, `j'])
 28.         if `d' > `maxdiff' local maxdiff = `d'
 29.     }
 30. 
.     if `maxdiff' < `tol' {
 31.         global TESTS_PASSED = $TESTS_PASSED + 1
 32.         di as result "[PASS] `testname'"
 33.     }
 34.     else {
 35.         global TESTS_FAILED = $TESTS_FAILED + 1
 36.         di as error "[FAIL] `testname' (max coef diff: " %9.2e `maxdiff' "
> )"
 37.     }
 38. end

. 
. /****************************************************************************
> ***
>  * benchmark_qreg
>  *
>  * Compare cqreg vs qreg
>  *
>  * Syntax: benchmark_qreg depvar indepvars [, quantile(real) vce(string)
>  *         testname(string) tol(real)]
>  *
>  * Example:
>  *   benchmark_qreg price mpg weight
>  *   benchmark_qreg price mpg weight, quantile(0.25)
>  ****************************************************************************
> **/
. capture program drop benchmark_qreg

. program define benchmark_qreg
  1.     syntax varlist(min=2 fv) [if] [in], [Quantile(real 0.5) vce(string) te
> stname(string) tol(real 1e-6)]
  2. 
.     gettoken depvar indepvars : varlist
  3. 
.     if "`testname'" == "" local testname "qreg `depvar' ... , q(`quantile')"
  4. 
.     global TESTS_TOTAL = $TESTS_TOTAL + 1
  5. 
.     * Build vce option
.     local vceopt ""
  6.     if "`vce'" != "" local vceopt "vce(`vce')"
  7. 
.     preserve
  8. 
.     * Run qreg
.     quietly qreg `depvar' `indepvars' `if' `in', quantile(`quantile') `vceopt
> '
  9.     matrix qreg_b = e(b)
 10.     local qreg_N = e(N)
 11. 
.     * Run cqreg
.     quietly cqreg `depvar' `indepvars' `if' `in', quantile(`quantile') `vceop
> t'
 12.     matrix cqreg_b = e(b)
 13.     local cqreg_N = e(N)
 14. 
.     restore
 15. 
.     * Compare N
.     if `qreg_N' != `cqreg_N' {
 16.         global TESTS_FAILED = $TESTS_FAILED + 1
 17.         di as error "[FAIL] `testname' (N: `qreg_N' != `cqreg_N')"
 18.         exit
 19.     }
 20. 
.     * Compare coefficients
.     tempname diff
 21.     matrix `diff' = qreg_b - cqreg_b
 22.     local cols = colsof(`diff')
 23.     local maxdiff = 0
 24.     forvalues j = 1/`cols' {
 25.         local d = abs(`diff'[1, `j'])
 26.         if `d' > `maxdiff' local maxdiff = `d'
 27.     }
 28. 
.     if `maxdiff' < `tol' {
 29.         global TESTS_PASSED = $TESTS_PASSED + 1
 30.         di as result "[PASS] `testname'"
 31.     }
 32.     else {
 33.         global TESTS_FAILED = $TESTS_FAILED + 1
 34.         di as error "[FAIL] `testname' (max coef diff: " %9.2e `maxdiff' "
> )"
 35.     }
 36. end

. 
. /****************************************************************************
> ***
>  * benchmark_import
>  *
>  * Compare cimport delimited vs import delimited
>  *
>  * Syntax: benchmark_import using filename [, delimiters(string) varnames(str
> ing)
>  *         case(string) rowrange(string) testname(string)]
>  *
>  * Example:
>  *   benchmark_import using "data.csv"
>  *   benchmark_import using "data.tsv", delimiters(tab)
>  ****************************************************************************
> **/
. capture program drop benchmark_import

. program define benchmark_import
  1.     syntax using/, [DELIMiters(string) VARNames(string) CASE(string) ROWRa
> nge(string) testname(string) clear]
  2. 
.     if "`testname'" == "" local testname "import `using'"
  3. 
.     global TESTS_TOTAL = $TESTS_TOTAL + 1
  4. 
.     * Build option string
.     local opts "clear"
  5.     if "`delimiters'" != "" local opts "`opts' delimiters(`delimiters')"
  6.     if "`varnames'" != "" local opts "`opts' varnames(`varnames')"
  7.     if "`case'" != "" local opts "`opts' case(`case')"
  8.     if "`rowrange'" != "" local opts "`opts' rowrange(`rowrange')"
  9. 
.     preserve
 10. 
.     * Run Stata import
.     import delimited `using', `opts'
 11.     local stata_n = _N
 12.     local stata_k = c(k)
 13.     tempfile stata_import
 14.     quietly save `stata_import'
 15. 
.     * Run cimport
.     cimport delimited `using', `opts'
 16.     local cimport_n = _N
 17.     local cimport_k = c(k)
 18. 
.     restore
 19. 
.     * Compare dimensions
.     if `stata_n' == `cimport_n' & `stata_k' == `cimport_k' {
 20.         global TESTS_PASSED = $TESTS_PASSED + 1
 21.         di as result "[PASS] `testname' (N=`stata_n', K=`stata_k')"
 22.     }
 23.     else {
 24.         global TESTS_FAILED = $TESTS_FAILED + 1
 25.         di as error "[FAIL] `testname' (N: `stata_n'!=`cimport_n', K: `sta
> ta_k'!=`cimport_k')"
 26.     }
 27. end

. 
. /****************************************************************************
> ***
>  * benchmark_export
>  *
>  * Compare cexport delimited vs export delimited
>  *
>  * Syntax: benchmark_export [varlist] using filename [, delimiter(string)
>  *         novarnames quote testname(string)]
>  *
>  * Example:
>  *   benchmark_export using "output.csv", replace
>  *   benchmark_export price mpg using "output.csv", replace
>  ****************************************************************************
> **/
. capture program drop benchmark_export

. program define benchmark_export
  1.     syntax [varlist] using/, [DELIMiter(string) NOVARNames QUOTE replace t
> estname(string)]
  2. 
.     if "`testname'" == "" local testname "export `using'"
  3. 
.     global TESTS_TOTAL = $TESTS_TOTAL + 1
  4. 
.     * Build option string
.     local opts "replace"
  5.     if "`delimiter'" != "" local opts "`opts' delimiter(`delimiter')"
  6.     if "`novarnames'" != "" local opts "`opts' novarnames"
  7.     if "`quote'" != "" local opts "`opts' quote"
  8. 
.     preserve
  9. 
.     * Generate temp filenames
.     tempfile stata_export cexport_export
 10.     local stata_csv = subinstr("`stata_export'", ".dta", ".csv", .)
 11.     local cexport_csv = subinstr("`cexport_export'", ".dta", ".csv", .)
 12. 
.     * Run Stata export
.     if "`varlist'" != "" {
 13.         export delimited `varlist' using "`stata_csv'", `opts'
 14.     }
 15.     else {
 16.         export delimited using "`stata_csv'", `opts'
 17.     }
 18. 
.     * Run cexport
.     if "`varlist'" != "" {
 19.         cexport delimited `varlist' using "`cexport_csv'", `opts'
 20.     }
 21.     else {
 22.         cexport delimited using "`cexport_csv'", `opts'
 23.     }
 24. 
.     * Reimport and compare
.     import delimited using "`stata_csv'", clear
 25.     local stata_n = _N
 26.     local stata_k = c(k)
 27. 
.     import delimited using "`cexport_csv'", clear
 28.     local cexport_n = _N
 29.     local cexport_k = c(k)
 30. 
.     * Cleanup temp files
.     capture erase "`stata_csv'"
 31.     capture erase "`cexport_csv'"
 32. 
.     restore
 33. 
.     * Compare dimensions
.     if `stata_n' == `cexport_n' & `stata_k' == `cexport_k' {
 34.         global TESTS_PASSED = $TESTS_PASSED + 1
 35.         di as result "[PASS] `testname' (N=`stata_n', K=`cexport_k')"
 36.     }
 37.     else {
 38.         global TESTS_FAILED = $TESTS_FAILED + 1
 39.         di as error "[FAIL] `testname' (N: `stata_n'!=`cexport_n', K: `sta
> ta_k'!=`cexport_k')"
 40.     }
 41. end

. 
. /****************************************************************************
> ***
>  * benchmark_binscatter (for cbinscatter validation)
>  *
>  * Compare cbinscatter vs binscatter (if installed)
>  *
>  * Syntax: benchmark_binscatter yvar xvar [, controls(varlist) absorb(varlist
> )
>  *         by(varname) nquantiles(int) testname(string)]
>  ****************************************************************************
> **/
. capture program drop benchmark_binscatter

. program define benchmark_binscatter
  1.     syntax varlist(min=2 max=2) [if] [in] [aw fw pw], [controls(varlist) A
> bsorb(varlist) BY(varname) NQuantiles(integer 20) testname(string) nograph]
  2. 
.     gettoken yvar xvar : varlist
  3. 
.     if "`testname'" == "" local testname "binscatter `yvar' `xvar'"
  4. 
.     global TESTS_TOTAL = $TESTS_TOTAL + 1
  5. 
.     * Build option string
.     local opts "nquantiles(`nquantiles') nograph"
  6.     if "`controls'" != "" local opts "`opts' controls(`controls')"
  7.     if "`absorb'" != "" local opts "`opts' absorb(`absorb')"
  8.     if "`by'" != "" local opts "`opts' by(`by')"
  9. 
.     * Build weight string
.     local wtexp ""
 10.     if "`weight'" != "" local wtexp "[`weight'`exp']"
 11. 
.     preserve
 12. 
.     * Run cbinscatter
.     quietly cbinscatter `yvar' `xvar' `wtexp' `if' `in', `opts'
 13.     local cbin_N = e(N)
 14.     local cbin_nq = e(nquantiles)
 15.     matrix cbin_data = e(bindata)
 16. 
.     restore
 17. 
.     * Verify cbinscatter produced valid results
.     if `cbin_N' > 0 & `cbin_nq' == `nquantiles' {
 18.         global TESTS_PASSED = $TESTS_PASSED + 1
 19.         di as result "[PASS] `testname' (N=`cbin_N', bins=`cbin_nq')"
 20.     }
 21.     else {
 22.         global TESTS_FAILED = $TESTS_FAILED + 1
 23.         di as error "[FAIL] `testname' (N=`cbin_N', bins=`cbin_nq')"
 24.     }
 25. end

. 
. di as text "Benchmark helper programs loaded"
Benchmark helper programs loaded

. 
end of do-file

. 
. di as text ""


. di as text "ctools validation framework loaded"
ctools validation framework loaded

. di as text ""


. 
end of do-file

. 
. di as text ""


. di as text "=================================================================
> ====="
======================================================================

. di as text "              CREGHDFE VALIDATION TEST SUITE"
              CREGHDFE VALIDATION TEST SUITE

. di as text "=================================================================
> ====="
======================================================================

. 
. /****************************************************************************
> ***
>  * Auto dataset - basic tests
>  ****************************************************************************
> **/
. print_section "Auto dataset - basic"

----------------------------------------------------------------------
Auto dataset - basic
----------------------------------------------------------------------

. 
. sysuse auto, clear
(1978 automobile data)

. benchmark_reghdfe price mpg weight, absorb(foreign) testname("single FE")
[PASS] single FE

. 
. sysuse auto, clear
(1978 automobile data)

. benchmark_reghdfe price mpg weight, absorb(foreign rep78) testname("two-way F
> E")
[PASS] two-way FE

. 
. sysuse auto, clear
(1978 automobile data)

. benchmark_reghdfe price mpg, absorb(foreign) testname("single covariate")
[PASS] single covariate

. 
. sysuse auto, clear
(1978 automobile data)

. benchmark_reghdfe price mpg weight length turn displacement, absorb(foreign) 
> testname("many covariates")
[PASS] many covariates

. 
. /****************************************************************************
> ***
>  * VCE options
>  ****************************************************************************
> **/
. print_section "VCE options"

----------------------------------------------------------------------
VCE options
----------------------------------------------------------------------

. 
. sysuse auto, clear
(1978 automobile data)

. benchmark_reghdfe price mpg weight, absorb(foreign) vce(robust) testname("rob
> ust VCE")
[PASS] robust VCE

. 
. sysuse auto, clear
(1978 automobile data)

. benchmark_reghdfe price mpg weight, absorb(foreign) vce(cluster foreign) test
> name("cluster VCE")
[PASS] cluster VCE

. 
. sysuse auto, clear
(1978 automobile data)

. benchmark_reghdfe price mpg weight, absorb(foreign rep78) vce(robust) testnam
> e("two-way FE + robust")
[PASS] two-way FE + robust

. 
. /****************************************************************************
> ***
>  * Weights
>  ****************************************************************************
> **/
. print_section "Weight options"

----------------------------------------------------------------------
Weight options
----------------------------------------------------------------------

. 
. sysuse auto, clear
(1978 automobile data)

. gen w = rep78
(5 missing values generated)

. replace w = 3 if missing(w)
(5 real changes made)

. benchmark_reghdfe price mpg weight [aw=w], absorb(foreign) testname("aweight"
> )
[PASS] aweight

. 
. sysuse auto, clear
(1978 automobile data)

. drop if missing(rep78)
(5 observations deleted)

. benchmark_reghdfe price mpg weight [fw=rep78], absorb(foreign) testname("fwei
> ght")
[PASS] fweight

. 
. sysuse auto, clear
(1978 automobile data)

. gen w = rep78
(5 missing values generated)

. replace w = 3 if missing(w)
(5 real changes made)

. benchmark_reghdfe price mpg weight [pw=w], absorb(foreign) testname("pweight"
> )
[PASS] pweight

. 
. * aweight with robust
. sysuse auto, clear
(1978 automobile data)

. gen w = rep78
(5 missing values generated)

. replace w = 3 if missing(w)
(5 real changes made)

. benchmark_reghdfe price mpg weight [aw=w], absorb(foreign) vce(robust) testna
> me("aweight + robust")
[PASS] aweight + robust

. 
. * aweight with cluster
. sysuse auto, clear
(1978 automobile data)

. gen w = rep78
(5 missing values generated)

. replace w = 3 if missing(w)
(5 real changes made)

. benchmark_reghdfe price mpg weight [aw=w], absorb(foreign) vce(cluster foreig
> n) testname("aweight + cluster")
[PASS] aweight + cluster

. 
. /****************************************************************************
> ***
>  * Panel data (nlswork)
>  ****************************************************************************
> **/
. print_section "Panel data (nlswork)"

----------------------------------------------------------------------
Panel data (nlswork)
----------------------------------------------------------------------

. 
. webuse nlswork, clear
(National Longitudinal Survey of Young Women, 14-24 years old in 1968)

. keep in 1/5000
(23,534 observations deleted)

. benchmark_reghdfe ln_wage age ttl_exp tenure, absorb(idcode) testname("indivi
> dual FE")
[PASS] individual FE

. 
. webuse nlswork, clear
(National Longitudinal Survey of Young Women, 14-24 years old in 1968)

. keep in 1/5000
(23,534 observations deleted)

. benchmark_reghdfe ln_wage age ttl_exp tenure, absorb(idcode year) testname("t
> wo-way panel FE")
[PASS] two-way panel FE

. 
. webuse nlswork, clear
(National Longitudinal Survey of Young Women, 14-24 years old in 1968)

. keep in 1/5000
(23,534 observations deleted)

. benchmark_reghdfe ln_wage age ttl_exp tenure, absorb(idcode year) vce(cluster
>  idcode) testname("panel + cluster")
[PASS] panel + cluster

. 
. webuse nlswork, clear
(National Longitudinal Survey of Young Women, 14-24 years old in 1968)

. keep in 1/5000
(23,534 observations deleted)

. benchmark_reghdfe ln_wage age ttl_exp tenure, absorb(idcode) vce(robust) test
> name("individual FE + robust")
[PASS] individual FE + robust

. 
. /****************************************************************************
> ***
>  * Census dataset
>  ****************************************************************************
> **/
. print_section "Census dataset"

----------------------------------------------------------------------
Census dataset
----------------------------------------------------------------------

. 
. sysuse census, clear
(1980 Census data by state)

. benchmark_reghdfe pop medage death marriage, absorb(region) testname("region 
> FE")
[PASS] region FE

. 
. sysuse census, clear
(1980 Census data by state)

. benchmark_reghdfe pop medage, absorb(region) testname("region FE - simple")
[PASS] region FE - simple

. 
. /****************************************************************************
> ***
>  * Synthetic data
>  ****************************************************************************
> **/
. print_section "Synthetic data"

----------------------------------------------------------------------
Synthetic data
----------------------------------------------------------------------

. 
. * 20K observations
. clear

. set seed 98765

. set obs 20000
Number of observations (_N) was 0, now 20,000.

. gen firm = runiformint(1, 500)

. gen year = runiformint(2000, 2020)

. gen x1 = rnormal()

. gen x2 = rnormal() * 2

. gen y = 1 + 0.5*x1 - 0.3*x2 + rnormal() * 0.5

. 
. benchmark_reghdfe y x1 x2, absorb(firm year) testname("20K two-way FE")
[PASS] 20K two-way FE

. 
. * 50K observations
. clear

. set seed 11111

. set obs 50000
Number of observations (_N) was 0, now 50,000.

. gen firm = runiformint(1, 1000)

. gen year = runiformint(2000, 2020)

. gen x1 = rnormal()

. gen x2 = rnormal() * 2

. gen x3 = rnormal()

. gen y = 1 + 0.5*x1 - 0.3*x2 + 0.2*x3 + rnormal() * 0.5

. 
. benchmark_reghdfe y x1 x2 x3, absorb(firm) testname("50K firm FE")
[PASS] 50K firm FE

. 
. clear

. set seed 11111

. set obs 50000
Number of observations (_N) was 0, now 50,000.

. gen firm = runiformint(1, 1000)

. gen year = runiformint(2000, 2020)

. gen x1 = rnormal()

. gen x2 = rnormal() * 2

. gen x3 = rnormal()

. gen y = 1 + 0.5*x1 - 0.3*x2 + 0.2*x3 + rnormal() * 0.5

. 
. benchmark_reghdfe y x1 x2 x3, absorb(firm year) testname("50K two-way FE")
[PASS] 50K two-way FE

. 
. /****************************************************************************
> ***
>  * High-dimensional FE
>  ****************************************************************************
> **/
. print_section "High-dimensional FE"

----------------------------------------------------------------------
High-dimensional FE
----------------------------------------------------------------------

. 
. webuse nlswork, clear
(National Longitudinal Survey of Young Women, 14-24 years old in 1968)

. keep in 1/10000
(18,534 observations deleted)

. benchmark_reghdfe ln_wage age ttl_exp, absorb(idcode) testname("many FE level
> s (idcode)")
[PASS] many FE levels (idcode)

. 
. webuse nlswork, clear
(National Longitudinal Survey of Young Women, 14-24 years old in 1968)

. keep in 1/10000
(18,534 observations deleted)

. benchmark_reghdfe ln_wage age ttl_exp, absorb(idcode year) testname("many FE 
> levels (idcode year)")
[PASS] many FE levels (idcode year)

. 
. /****************************************************************************
> ***
>  * Edge cases
>  ****************************************************************************
> **/
. print_section "Edge cases"

----------------------------------------------------------------------
Edge cases
----------------------------------------------------------------------

. 
. * weights=1 should match unweighted
. sysuse auto, clear
(1978 automobile data)

. gen w1 = 1

. quietly creghdfe price mpg weight, absorb(foreign)

. local unweighted_b = _b[mpg]

. quietly creghdfe price mpg weight [aw=w1], absorb(foreign)

. local weighted1_b = _b[mpg]

. 
. global TESTS_TOTAL = $TESTS_TOTAL + 1

. if abs(`unweighted_b' - `weighted1_b') < 1e-6 {
.     global TESTS_PASSED = $TESTS_PASSED + 1
.     di as result "[PASS] weights=1 matches unweighted"
[PASS] weights=1 matches unweighted
. }

. else {
.     global TESTS_FAILED = $TESTS_FAILED + 1
.     di as error "[FAIL] weights=1 differs from unweighted"
. }

. 
. * Single observation per FE group - verify it works
. clear

. set obs 100
Number of observations (_N) was 0, now 100.

. gen fe = _n

. gen x = rnormal()

. gen y = x + rnormal()

. capture benchmark_reghdfe y x, absorb(fe) testname("one obs per FE group")

. 
. /****************************************************************************
> ***
>  * Stored results check
>  ****************************************************************************
> **/
. print_section "Stored results"

----------------------------------------------------------------------
Stored results
----------------------------------------------------------------------

. 
. sysuse auto, clear
(1978 automobile data)

. 
. * Run both commands
. quietly reghdfe price mpg weight, absorb(foreign)

. matrix reghdfe_b = e(b)

. matrix reghdfe_V = e(V)

. local reghdfe_N = e(N)

. local reghdfe_df_r = e(df_r)

. 
. quietly creghdfe price mpg weight, absorb(foreign)

. matrix creghdfe_b = e(b)

. matrix creghdfe_V = e(V)

. local creghdfe_N = e(N)

. local creghdfe_df_r = e(df_r)

. 
. * Compare e(b)
. tempname diff

. matrix `diff' = reghdfe_b - creghdfe_b

. local cols = colsof(`diff')

. local maxdiff = 0

. forvalues j = 1/`cols' {
  2.     local d = abs(`diff'[1, `j'])
  3.     if `d' > `maxdiff' local maxdiff = `d'
  4. }

. 
. global TESTS_TOTAL = $TESTS_TOTAL + 1

. if `maxdiff' < 1e-6 {
.     global TESTS_PASSED = $TESTS_PASSED + 1
.     di as result "[PASS] e(b) matches"
[PASS] e(b) matches
. }

. else {
.     global TESTS_FAILED = $TESTS_FAILED + 1
.     di as error "[FAIL] e(b) differs (max: " %9.2e `maxdiff' ")"
. }

. 
. * Compare e(V)
. matrix `diff' = reghdfe_V - creghdfe_V

. local rows = rowsof(`diff')

. local cols = colsof(`diff')

. local maxdiff = 0

. forvalues i = 1/`rows' {
  2.     forvalues j = 1/`cols' {
  3.         local d = abs(`diff'[`i', `j'])
  4.         if `d' > `maxdiff' local maxdiff = `d'
  5.     }
  6. }

. 
. global TESTS_TOTAL = $TESTS_TOTAL + 1

. if `maxdiff' < 1e-6 {
.     global TESTS_PASSED = $TESTS_PASSED + 1
.     di as result "[PASS] e(V) matches"
[PASS] e(V) matches
. }

. else {
.     global TESTS_FAILED = $TESTS_FAILED + 1
.     di as error "[FAIL] e(V) differs (max: " %9.2e `maxdiff' ")"
. }

. 
. * Compare df_r
. global TESTS_TOTAL = $TESTS_TOTAL + 1

. if `reghdfe_df_r' == `creghdfe_df_r' {
.     global TESTS_PASSED = $TESTS_PASSED + 1
.     di as result "[PASS] e(df_r) matches"
[PASS] e(df_r) matches
. }

. else {
.     global TESTS_FAILED = $TESTS_FAILED + 1
.     di as error "[FAIL] e(df_r) differs (`reghdfe_df_r' vs `creghdfe_df_r')"
. }

. 
. /****************************************************************************
> ***
>  * SUMMARY
>  ****************************************************************************
> **/
. print_summary "creghdfe"

----------------------------------------------------------------------
SUMMARY: creghdfe
----------------------------------------------------------------------
Tests passed: 27
Tests failed: 0
Total tests:  28
ALL TESTS PASSED
----------------------------------------------------------------------

. 
. * Return error code if any tests failed
. if $TESTS_FAILED > 0 {
.     exit 1
. }

. 
end of do-file
