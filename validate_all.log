
  ___  ____  ____  ____  ____ ®
 /__    /   ____/   /   ____/      StataNow 18.5
___/   /   /___/   /   /___/       MP—Parallel Edition

 Statistics and Data Science       Copyright 1985-2023 StataCorp LLC
                                   StataCorp
                                   4905 Lakeway Drive
                                   College Station, Texas 77845 USA
                                   800-782-8272        https://www.stata.com
                                   979-696-4600        service@stata.com

Stata license: Unlimited-user 16-core network, expiring  2 Jul 2026
Serial number: 501909320077
  Licensed to: Michael Droste
               Stanford University GSB

Notes:
      1. Stata is running in batch mode.
      2. Unicode is supported; see help unicode_advice.
      3. More than 2 billion observations are allowed; see help obs_advice.
      4. Maximum number of variables is set to 5,000 but can be increased;
          see help set_maxvar.


Running /Users/Mike/Documents/Stata/profile.do ...

. do validation/validate_all.do 

. /****************************************************************************
> ***
>  * validate_all.do
>  *
>  * Master test runner for ctools validation suite
>  * Runs all individual validation tests and provides summary
>  *
>  * Usage:
>  *   stata -b do validation/validate_all.do
>  *
>  * Individual tests can also be run separately:
>  *   stata -b do validation/validate_csort.do
>  *   stata -b do validation/validate_cmerge.do
>  *   etc.
>  ****************************************************************************
> **/
. 
. version 14.0

. clear all

. set more off

. set trace off

. 
. di as text ""


. di as text "#################################################################
> #####"
######################################################################

. di as text "#                                                                
>     #"
#                                                                    #

. di as text "#               CTOOLS VALIDATION TEST SUITE                     
>     #"
#               CTOOLS VALIDATION TEST SUITE                         #

. di as text "#                                                                
>     #"
#                                                                    #

. di as text "#################################################################
> #####"
######################################################################

. di as text ""


. di as text "Running comprehensive validation tests for all ctools commands."
Running comprehensive validation tests for all ctools commands.

. di as text "Each command is compared against its native Stata equivalent."
Each command is compared against its native Stata equivalent.

. di as text ""


. di as text "Date: " c(current_date) " " c(current_time)
Date:  8 Jan 2026 20:04:11

. di as text "Stata version: " c(stata_version)
Stata version: 18.5

. di as text "Platform: " c(os) " " c(machine_type)
Platform: Unix Mac (Apple Silicon)

. di as text ""


. 
. * Track overall results
. local total_passed = 0

. local total_failed = 0

. local total_tests = 0

. 
. * Create temp directory
. capture mkdir "validation/temp"

. 
. /****************************************************************************
> ***
>  * RUN CSORT VALIDATION
>  ****************************************************************************
> **/
. di as text ""


. di as text "=================================================================
> ====="
======================================================================

. di as text "  Running: csort validation tests"
  Running: csort validation tests

. di as text "=================================================================
> ====="
======================================================================

. 
. capture noisily do "validation/validate_csort.do"

. /****************************************************************************
> ***
>  * validate_csort.do
>  *
>  * Comprehensive validation tests for csort vs native sort
>  * Tests sorting functionality across various data types and scenarios
>  *
>  * Note: csort uses inherently stable radix sort, so we compare against
>  * Stata's "sort, stable" for exact matches.
>  ****************************************************************************
> **/
. 
. do "validation/validate_setup.do"

. /****************************************************************************
> ***
>  * validate_setup.do
>  *
>  * Setup and helper programs for ctools validation test suite
>  * This file is included by all individual validation tests
>  ****************************************************************************
> **/
. 
. version 14.0

. clear all

. set more off

. set trace off

. 
. * Load ctools from build directory
. adopath + "build"
  [1]  (BASE)      "/Applications/Stata/ado/base/"
  [2]  (SITE)      "/Applications/Stata/ado/site/"
  [3]              "."
  [4]  (PERSONAL)  "/Users/Mike/Documents/Stata/ado/personal/"
  [5]  (PLUS)      "/Users/Mike/Library/Application Support/Stata/ado/plus/"
  [6]  (OLDPLACE)  "~/ado/"
  [7]              "build"

. cap program drop ctools_plugin

. program ctools_plugin, plugin using("build/ctools_mac_arm.plugin")

. 
. * Global counters
. global TESTS_PASSED = 0

. global TESTS_FAILED = 0

. global TESTS_TOTAL = 0

. 
. * Helper program to compare scalars with tolerance
. capture program drop assert_scalar_equal

. program define assert_scalar_equal
  1.     args name val1 val2 tol testname
  2. 
.     if "`tol'" == "" local tol = 1e-6
  3. 
.     global TESTS_TOTAL = $TESTS_TOTAL + 1
  4. 
.     local diff = abs(`val1' - `val2')
  5.     * Handle exact match case (for integers like N)
.     if `diff' == 0 | `diff' < `tol' {
  6.         global TESTS_PASSED = $TESTS_PASSED + 1
  7.         di as result "  PASS: `testname' (`name' diff = " %12.2e `diff' ")
> "
  8.     }
  9.     else {
 10.         global TESTS_FAILED = $TESTS_FAILED + 1
 11.         di as error "  FAIL: `testname' (`name': `val1' vs `val2', diff = 
> " %12.2e `diff' ")"
 12.     }
 13. end

. 
. * Helper program to compare matrices
. capture program drop assert_matrix_equal

. program define assert_matrix_equal
  1.     args mat1 mat2 tol testname
  2. 
.     if "`tol'" == "" local tol = 1e-6
  3. 
.     global TESTS_TOTAL = $TESTS_TOTAL + 1
  4. 
.     tempname diff
  5.     matrix `diff' = `mat1' - `mat2'
  6.     local maxdiff = 0
  7.     local rows = rowsof(`diff')
  8.     local cols = colsof(`diff')
  9.     forvalues i = 1/`rows' {
 10.         forvalues j = 1/`cols' {
 11.             local d = abs(`diff'[`i', `j'])
 12.             if `d' > `maxdiff' local maxdiff = `d'
 13.         }
 14.     }
 15. 
.     if `maxdiff' < `tol' {
 16.         global TESTS_PASSED = $TESTS_PASSED + 1
 17.         di as result "  PASS: `testname' (max diff = " %12.2e `maxdiff' ")
> "
 18.     }
 19.     else {
 20.         global TESTS_FAILED = $TESTS_FAILED + 1
 21.         di as error "  FAIL: `testname' (max diff = " %12.2e `maxdiff' ")"
 22.     }
 23. end

. 
. * Helper program to compare variables
. capture program drop assert_var_equal

. program define assert_var_equal
  1.     args var1 var2 tol testname
  2. 
.     if "`tol'" == "" local tol = 1e-10
  3. 
.     global TESTS_TOTAL = $TESTS_TOTAL + 1
  4. 
.     quietly count if abs(`var1' - `var2') > `tol'
  5.     local ndiff = r(N)
  6. 
.     if `ndiff' == 0 {
  7.         global TESTS_PASSED = $TESTS_PASSED + 1
  8.         di as result "  PASS: `testname' (all values match)"
  9.     }
 10.     else {
 11.         global TESTS_FAILED = $TESTS_FAILED + 1
 12.         di as error "  FAIL: `testname' (`ndiff' values differ)"
 13.     }
 14. end

. 
. * Helper program to compare string variables
. capture program drop assert_strvar_equal

. program define assert_strvar_equal
  1.     args var1 var2 testname
  2. 
.     global TESTS_TOTAL = $TESTS_TOTAL + 1
  3. 
.     quietly count if `var1' != `var2'
  4.     local ndiff = r(N)
  5. 
.     if `ndiff' == 0 {
  6.         global TESTS_PASSED = $TESTS_PASSED + 1
  7.         di as result "  PASS: `testname' (all values match)"
  8.     }
  9.     else {
 10.         global TESTS_FAILED = $TESTS_FAILED + 1
 11.         di as error "  FAIL: `testname' (`ndiff' values differ)"
 12.     }
 13. end

. 
. * Helper to check if two datasets are identical
. capture program drop assert_data_equal

. program define assert_data_equal
  1.     args file1 file2 testname
  2. 
.     global TESTS_TOTAL = $TESTS_TOTAL + 1
  3. 
.     preserve
  4.     quietly {
  5.         use "`file1'", clear
  6.         cf _all using "`file2'"
  7.     }
  8.     local rc = _rc
  9.     restore
 10. 
.     if `rc' == 0 {
 11.         global TESTS_PASSED = $TESTS_PASSED + 1
 12.         di as result "  PASS: `testname' (datasets identical)"
 13.     }
 14.     else {
 15.         global TESTS_FAILED = $TESTS_FAILED + 1
 16.         di as error "  FAIL: `testname' (datasets differ)"
 17.     }
 18. end

. 
. * Helper program to print section header
. capture program drop print_section

. program define print_section
  1.     args title
  2.     di as text ""
  3.     di as text "{hline 70}"
  4.     di as text "`title'"
  5.     di as text "{hline 70}"
  6. end

. 
. * Helper program to print test summary
. capture program drop print_summary

. program define print_summary
  1.     args component
  2.     di as text ""
  3.     di as text "{hline 70}"
  4.     di as text "SUMMARY: `component'"
  5.     di as text "{hline 70}"
  6.     di as text "Tests passed: " as result $TESTS_PASSED
  7.     di as text "Tests failed: " as result $TESTS_FAILED
  8.     di as text "Total tests:  " as result $TESTS_TOTAL
  9.     if $TESTS_FAILED > 0 {
 10.         di as error "VALIDATION FAILED"
 11.     }
 12.     else {
 13.         di as result "ALL TESTS PASSED"
 14.     }
 15.     di as text "{hline 70}"
 16. end

. 
. * Create temp directory for test files
. capture mkdir "validation/temp"

. 
. di as text ""


. di as text "ctools validation framework loaded"
ctools validation framework loaded

. di as text ""


. 
end of do-file

. 
. di as text ""


. di as text "=================================================================
> ====="
======================================================================

. di as text "              CSORT VALIDATION TEST SUITE"
              CSORT VALIDATION TEST SUITE

. di as text "=================================================================
> ====="
======================================================================

. 
. /****************************************************************************
> ***
>  * First, test if csort works at all
>  ****************************************************************************
> **/
. print_section "Preliminary: Check if csort plugin works"

----------------------------------------------------------------------
Preliminary: Check if csort plugin works
----------------------------------------------------------------------

. 
. sysuse auto, clear
(1978 automobile data)

. capture noisily csort price

. local csort_works = (_rc == 0)

. 
. if !`csort_works' {
.     di as error "  csort plugin is not functioning (rc=`=_rc')"
.     di as error "  Skipping all csort tests"
.     di as text ""
.     di as text "{hline 70}"
.     di as text "SUMMARY: csort"
.     di as text "{hline 70}"
.     di as text "Tests passed: 0"
.     di as text "Tests failed: 1"
.     di as text "Total tests:  1"
.     di as error "VALIDATION FAILED - csort plugin not working"
.     di as text "{hline 70}"
.     global TESTS_PASSED = 0
.     global TESTS_FAILED = 1
.     global TESTS_TOTAL = 1
.     exit 1
. }

. 
. di as result "  csort plugin is functional"
  csort plugin is functional

. global TESTS_PASSED = $TESTS_PASSED + 1

. global TESTS_TOTAL = $TESTS_TOTAL + 1

. 
. /****************************************************************************
> ***
>  * TEST 1: Single numeric variable sort (auto dataset)
>  ****************************************************************************
> **/
. print_section "Test 1: Single numeric variable sort"

----------------------------------------------------------------------
Test 1: Single numeric variable sort
----------------------------------------------------------------------

. 
. sysuse auto, clear
(1978 automobile data)

. preserve

. sort price, stable

. tempfile stata_sorted

. quietly save `stata_sorted'

. restore

. 
. preserve

. csort price

. tempfile csort_sorted

. quietly save `csort_sorted'

. restore

. 
. assert_data_equal `stata_sorted' `csort_sorted' "Single numeric sort (price)"
  PASS: Single numeric sort (price) (datasets identical)

. 
. /****************************************************************************
> ***
>  * TEST 2: Single string variable sort
>  ****************************************************************************
> **/
. print_section "Test 2: Single string variable sort"

----------------------------------------------------------------------
Test 2: Single string variable sort
----------------------------------------------------------------------

. 
. sysuse auto, clear
(1978 automobile data)

. preserve

. sort make, stable

. tempfile stata_sorted

. quietly save `stata_sorted'

. restore

. 
. preserve

. csort make

. tempfile csort_sorted

. quietly save `csort_sorted'

. restore

. 
. assert_data_equal `stata_sorted' `csort_sorted' "Single string sort (make)"
  PASS: Single string sort (make) (datasets identical)

. 
. /****************************************************************************
> ***
>  * TEST 3: Multiple variable sort
>  ****************************************************************************
> **/
. print_section "Test 3: Multiple variable sort"

----------------------------------------------------------------------
Test 3: Multiple variable sort
----------------------------------------------------------------------

. 
. sysuse auto, clear
(1978 automobile data)

. preserve

. sort foreign rep78 price, stable

. tempfile stata_sorted

. quietly save `stata_sorted'

. restore

. 
. preserve

. csort foreign rep78 price

. tempfile csort_sorted

. quietly save `csort_sorted'

. restore

. 
. assert_data_equal `stata_sorted' `csort_sorted' "Multi-variable sort (foreign
>  rep78 price)"
  PASS: Multi-variable sort (foreign rep78 price) (datasets identical)

. 
. /****************************************************************************
> ***
>  * TEST 4: Sort with missing values
>  ****************************************************************************
> **/
. print_section "Test 4: Sort with missing values"

----------------------------------------------------------------------
Test 4: Sort with missing values
----------------------------------------------------------------------

. 
. sysuse auto, clear
(1978 automobile data)

. * rep78 has missing values
. preserve

. sort rep78, stable

. tempfile stata_sorted

. quietly save `stata_sorted'

. restore

. 
. preserve

. csort rep78

. tempfile csort_sorted

. quietly save `csort_sorted'

. restore

. 
. assert_data_equal `stata_sorted' `csort_sorted' "Sort with missing values (re
> p78)"
  PASS: Sort with missing values (rep78) (datasets identical)

. 
. /****************************************************************************
> ***
>  * TEST 5: Sort with duplicates
>  ****************************************************************************
> **/
. print_section "Test 5: Sort with duplicates"

----------------------------------------------------------------------
Test 5: Sort with duplicates
----------------------------------------------------------------------

. 
. sysuse auto, clear
(1978 automobile data)

. * foreign has many duplicates (0 and 1)
. preserve

. sort foreign, stable

. tempfile stata_sorted

. quietly save `stata_sorted'

. restore

. 
. preserve

. csort foreign

. tempfile csort_sorted

. quietly save `csort_sorted'

. restore

. 
. * Check that all foreign=0 come before foreign=1
. use `csort_sorted', clear
(1978 automobile data)

. gen _order = _n

. quietly summarize _order if foreign == 0

. local max_domestic = r(max)

. quietly summarize _order if foreign == 1

. local min_foreign = r(min)

. 
. if `max_domestic' < `min_foreign' {
.     di as result "  PASS: Duplicates sorted correctly (domestic before foreig
> n)"
  PASS: Duplicates sorted correctly (domestic before foreign)
.     global TESTS_PASSED = $TESTS_PASSED + 1
. }

. else {
.     di as error "  FAIL: Duplicates not sorted correctly"
.     global TESTS_FAILED = $TESTS_FAILED + 1
. }

. global TESTS_TOTAL = $TESTS_TOTAL + 1

. 
. /****************************************************************************
> ***
>  * TEST 6: Large synthetic dataset
>  ****************************************************************************
> **/
. print_section "Test 6: Large synthetic dataset (10,000 obs)"

----------------------------------------------------------------------
Test 6: Large synthetic dataset (10,000 obs)
----------------------------------------------------------------------

. 
. clear

. set seed 12345

. set obs 10000
Number of observations (_N) was 0, now 10,000.

. gen id = _n

. gen group = runiformint(1, 100)

. gen value = runiform()

. 
. * Sort by group and value
. preserve

. sort group value, stable

. tempfile stata_sorted

. quietly save `stata_sorted'

. restore

. 
. preserve

. csort group value

. tempfile csort_sorted

. quietly save `csort_sorted'

. restore

. 
. assert_data_equal `stata_sorted' `csort_sorted' "Large dataset sort (10K obs)
> "
  PASS: Large dataset sort (10K obs) (datasets identical)

. 
. /****************************************************************************
> ***
>  * TEST 7: Negative numbers
>  ****************************************************************************
> **/
. print_section "Test 7: Negative numbers"

----------------------------------------------------------------------
Test 7: Negative numbers
----------------------------------------------------------------------

. 
. clear

. set obs 1000
Number of observations (_N) was 0, now 1,000.

. gen x = runiform() * 200 - 100  // Range -100 to 100

. 
. preserve

. sort x, stable

. tempfile stata_sorted

. quietly save `stata_sorted'

. restore

. 
. preserve

. csort x

. tempfile csort_sorted

. quietly save `csort_sorted'

. restore

. 
. assert_data_equal `stata_sorted' `csort_sorted' "Negative numbers sort"
  PASS: Negative numbers sort (datasets identical)

. 
. /****************************************************************************
> ***
>  * TEST 8: Census dataset
>  ****************************************************************************
> **/
. print_section "Test 8: Census dataset"

----------------------------------------------------------------------
Test 8: Census dataset
----------------------------------------------------------------------

. 
. sysuse census, clear
(1980 Census data by state)

. 
. preserve

. sort state, stable

. tempfile stata_sorted

. quietly save `stata_sorted'

. restore

. 
. preserve

. csort state

. tempfile csort_sorted

. quietly save `csort_sorted'

. restore

. 
. assert_data_equal `stata_sorted' `csort_sorted' "Census state sort"
  PASS: Census state sort (datasets identical)

. 
. /****************************************************************************
> ***
>  * SUMMARY
>  ****************************************************************************
> **/
. print_summary "csort"

----------------------------------------------------------------------
SUMMARY: csort
----------------------------------------------------------------------
Tests passed: 9
Tests failed: 0
Total tests:  9
ALL TESTS PASSED
----------------------------------------------------------------------

. 
. * Return error code if any tests failed
. if $TESTS_FAILED > 0 {
.     exit 1
. }

. 
end of do-file

. local csort_rc = _rc

. 
. if `csort_rc' == 0 {
.     di as result "csort: ALL TESTS PASSED"
csort: ALL TESTS PASSED
. }

. else {
.     di as error "csort: SOME TESTS FAILED"
. }

. 
. local total_passed = `total_passed' + $TESTS_PASSED

. local total_failed = `total_failed' + $TESTS_FAILED

. local total_tests = `total_tests' + $TESTS_TOTAL

. 
. local csort_passed = $TESTS_PASSED

. local csort_failed = $TESTS_FAILED

. local csort_total = $TESTS_TOTAL

. 
. /****************************************************************************
> ***
>  * RUN CMERGE VALIDATION
>  ****************************************************************************
> **/
. di as text ""


. di as text "=================================================================
> ====="
======================================================================

. di as text "  Running: cmerge validation tests"
  Running: cmerge validation tests

. di as text "=================================================================
> ====="
======================================================================

. 
. capture noisily do "validation/validate_cmerge.do"

. /****************************************************************************
> ***
>  * validate_cmerge.do
>  *
>  * Comprehensive validation tests for cmerge vs native merge
>  * Tests all merge types and options
>  ****************************************************************************
> **/
. 
. do "validation/validate_setup.do"

. /****************************************************************************
> ***
>  * validate_setup.do
>  *
>  * Setup and helper programs for ctools validation test suite
>  * This file is included by all individual validation tests
>  ****************************************************************************
> **/
. 
. version 14.0

. clear all

. set more off

. set trace off

. 
. * Load ctools from build directory
. adopath + "build"
  [1]  (BASE)      "/Applications/Stata/ado/base/"
  [2]  (SITE)      "/Applications/Stata/ado/site/"
  [3]              "."
  [4]  (PERSONAL)  "/Users/Mike/Documents/Stata/ado/personal/"
  [5]  (PLUS)      "/Users/Mike/Library/Application Support/Stata/ado/plus/"
  [6]  (OLDPLACE)  "~/ado/"
  [7]              "build"

. cap program drop ctools_plugin

. program ctools_plugin, plugin using("build/ctools_mac_arm.plugin")

. 
. * Global counters
. global TESTS_PASSED = 0

. global TESTS_FAILED = 0

. global TESTS_TOTAL = 0

. 
. * Helper program to compare scalars with tolerance
. capture program drop assert_scalar_equal

. program define assert_scalar_equal
  1.     args name val1 val2 tol testname
  2. 
.     if "`tol'" == "" local tol = 1e-6
  3. 
.     global TESTS_TOTAL = $TESTS_TOTAL + 1
  4. 
.     local diff = abs(`val1' - `val2')
  5.     * Handle exact match case (for integers like N)
.     if `diff' == 0 | `diff' < `tol' {
  6.         global TESTS_PASSED = $TESTS_PASSED + 1
  7.         di as result "  PASS: `testname' (`name' diff = " %12.2e `diff' ")
> "
  8.     }
  9.     else {
 10.         global TESTS_FAILED = $TESTS_FAILED + 1
 11.         di as error "  FAIL: `testname' (`name': `val1' vs `val2', diff = 
> " %12.2e `diff' ")"
 12.     }
 13. end

. 
. * Helper program to compare matrices
. capture program drop assert_matrix_equal

. program define assert_matrix_equal
  1.     args mat1 mat2 tol testname
  2. 
.     if "`tol'" == "" local tol = 1e-6
  3. 
.     global TESTS_TOTAL = $TESTS_TOTAL + 1
  4. 
.     tempname diff
  5.     matrix `diff' = `mat1' - `mat2'
  6.     local maxdiff = 0
  7.     local rows = rowsof(`diff')
  8.     local cols = colsof(`diff')
  9.     forvalues i = 1/`rows' {
 10.         forvalues j = 1/`cols' {
 11.             local d = abs(`diff'[`i', `j'])
 12.             if `d' > `maxdiff' local maxdiff = `d'
 13.         }
 14.     }
 15. 
.     if `maxdiff' < `tol' {
 16.         global TESTS_PASSED = $TESTS_PASSED + 1
 17.         di as result "  PASS: `testname' (max diff = " %12.2e `maxdiff' ")
> "
 18.     }
 19.     else {
 20.         global TESTS_FAILED = $TESTS_FAILED + 1
 21.         di as error "  FAIL: `testname' (max diff = " %12.2e `maxdiff' ")"
 22.     }
 23. end

. 
. * Helper program to compare variables
. capture program drop assert_var_equal

. program define assert_var_equal
  1.     args var1 var2 tol testname
  2. 
.     if "`tol'" == "" local tol = 1e-10
  3. 
.     global TESTS_TOTAL = $TESTS_TOTAL + 1
  4. 
.     quietly count if abs(`var1' - `var2') > `tol'
  5.     local ndiff = r(N)
  6. 
.     if `ndiff' == 0 {
  7.         global TESTS_PASSED = $TESTS_PASSED + 1
  8.         di as result "  PASS: `testname' (all values match)"
  9.     }
 10.     else {
 11.         global TESTS_FAILED = $TESTS_FAILED + 1
 12.         di as error "  FAIL: `testname' (`ndiff' values differ)"
 13.     }
 14. end

. 
. * Helper program to compare string variables
. capture program drop assert_strvar_equal

. program define assert_strvar_equal
  1.     args var1 var2 testname
  2. 
.     global TESTS_TOTAL = $TESTS_TOTAL + 1
  3. 
.     quietly count if `var1' != `var2'
  4.     local ndiff = r(N)
  5. 
.     if `ndiff' == 0 {
  6.         global TESTS_PASSED = $TESTS_PASSED + 1
  7.         di as result "  PASS: `testname' (all values match)"
  8.     }
  9.     else {
 10.         global TESTS_FAILED = $TESTS_FAILED + 1
 11.         di as error "  FAIL: `testname' (`ndiff' values differ)"
 12.     }
 13. end

. 
. * Helper to check if two datasets are identical
. capture program drop assert_data_equal

. program define assert_data_equal
  1.     args file1 file2 testname
  2. 
.     global TESTS_TOTAL = $TESTS_TOTAL + 1
  3. 
.     preserve
  4.     quietly {
  5.         use "`file1'", clear
  6.         cf _all using "`file2'"
  7.     }
  8.     local rc = _rc
  9.     restore
 10. 
.     if `rc' == 0 {
 11.         global TESTS_PASSED = $TESTS_PASSED + 1
 12.         di as result "  PASS: `testname' (datasets identical)"
 13.     }
 14.     else {
 15.         global TESTS_FAILED = $TESTS_FAILED + 1
 16.         di as error "  FAIL: `testname' (datasets differ)"
 17.     }
 18. end

. 
. * Helper program to print section header
. capture program drop print_section

. program define print_section
  1.     args title
  2.     di as text ""
  3.     di as text "{hline 70}"
  4.     di as text "`title'"
  5.     di as text "{hline 70}"
  6. end

. 
. * Helper program to print test summary
. capture program drop print_summary

. program define print_summary
  1.     args component
  2.     di as text ""
  3.     di as text "{hline 70}"
  4.     di as text "SUMMARY: `component'"
  5.     di as text "{hline 70}"
  6.     di as text "Tests passed: " as result $TESTS_PASSED
  7.     di as text "Tests failed: " as result $TESTS_FAILED
  8.     di as text "Total tests:  " as result $TESTS_TOTAL
  9.     if $TESTS_FAILED > 0 {
 10.         di as error "VALIDATION FAILED"
 11.     }
 12.     else {
 13.         di as result "ALL TESTS PASSED"
 14.     }
 15.     di as text "{hline 70}"
 16. end

. 
. * Create temp directory for test files
. capture mkdir "validation/temp"

. 
. di as text ""


. di as text "ctools validation framework loaded"
ctools validation framework loaded

. di as text ""


. 
end of do-file

. 
. di as text ""


. di as text "=================================================================
> ====="
======================================================================

. di as text "              CMERGE VALIDATION TEST SUITE"
              CMERGE VALIDATION TEST SUITE

. di as text "=================================================================
> ====="
======================================================================

. 
. * Create temp directory for test files
. capture mkdir "validation/temp"

. 
. /****************************************************************************
> ***
>  * TEST 1: Basic 1:1 merge
>  ****************************************************************************
> **/
. print_section "Test 1: Basic 1:1 merge"

----------------------------------------------------------------------
Test 1: Basic 1:1 merge
----------------------------------------------------------------------

. 
. * Create master dataset
. sysuse auto, clear
(1978 automobile data)

. keep make price mpg

. gen id = _n

. order id

. tempfile master

. quietly save `master'

. 
. * Create using dataset with unique id
. sysuse auto, clear
(1978 automobile data)

. keep make weight length

. gen id = _n

. order id

. tempfile using_data

. quietly save `using_data'

. 
. * Stata merge
. use `master', clear
(1978 automobile data)

. merge 1:1 id using `using_data'

    Result                      Number of obs
    -----------------------------------------
    Not matched                             0
    Matched                                74  (_merge==3)
    -----------------------------------------

. tempfile stata_merged

. quietly save `stata_merged'

. 
. * ctools merge
. use `master', clear
(1978 automobile data)

. cmerge 1:1 id using `using_data'

    Result                             Number of obs
    -----------------------------------------------
    Not matched                                      0

    Matched                                         74  (_merge==3)
    -----------------------------------------------

. tempfile cmerge_merged

. quietly save `cmerge_merged'

. 
. assert_data_equal `stata_merged' `cmerge_merged' "Basic 1:1 merge"
r(9);

end of do-file

. local cmerge_rc = _rc

. 
. if `cmerge_rc' == 0 {
.     di as result "cmerge: ALL TESTS PASSED"
. }

. else {
.     di as error "cmerge: SOME TESTS FAILED"
cmerge: SOME TESTS FAILED
. }

. 
. local total_passed = `total_passed' + $TESTS_PASSED

. local total_failed = `total_failed' + $TESTS_FAILED

. local total_tests = `total_tests' + $TESTS_TOTAL

. 
. local cmerge_passed = $TESTS_PASSED

. local cmerge_failed = $TESTS_FAILED

. local cmerge_total = $TESTS_TOTAL

. 
. /****************************************************************************
> ***
>  * RUN CIMPORT VALIDATION
>  ****************************************************************************
> **/
. di as text ""


. di as text "=================================================================
> ====="
======================================================================

. di as text "  Running: cimport validation tests"
  Running: cimport validation tests

. di as text "=================================================================
> ====="
======================================================================

. 
. capture noisily do "validation/validate_cimport.do"

. /****************************************************************************
> ***
>  * validate_cimport.do
>  *
>  * Comprehensive validation tests for cimport vs import delimited
>  * Tests CSV import functionality across various scenarios
>  ****************************************************************************
> **/
. 
. do "validation/validate_setup.do"

. /****************************************************************************
> ***
>  * validate_setup.do
>  *
>  * Setup and helper programs for ctools validation test suite
>  * This file is included by all individual validation tests
>  ****************************************************************************
> **/
. 
. version 14.0

. clear all

. set more off

. set trace off

. 
. * Load ctools from build directory
. adopath + "build"
  [1]  (BASE)      "/Applications/Stata/ado/base/"
  [2]  (SITE)      "/Applications/Stata/ado/site/"
  [3]              "."
  [4]  (PERSONAL)  "/Users/Mike/Documents/Stata/ado/personal/"
  [5]  (PLUS)      "/Users/Mike/Library/Application Support/Stata/ado/plus/"
  [6]  (OLDPLACE)  "~/ado/"
  [7]              "build"

. cap program drop ctools_plugin

. program ctools_plugin, plugin using("build/ctools_mac_arm.plugin")

. 
. * Global counters
. global TESTS_PASSED = 0

. global TESTS_FAILED = 0

. global TESTS_TOTAL = 0

. 
. * Helper program to compare scalars with tolerance
. capture program drop assert_scalar_equal

. program define assert_scalar_equal
  1.     args name val1 val2 tol testname
  2. 
.     if "`tol'" == "" local tol = 1e-6
  3. 
.     global TESTS_TOTAL = $TESTS_TOTAL + 1
  4. 
.     local diff = abs(`val1' - `val2')
  5.     * Handle exact match case (for integers like N)
.     if `diff' == 0 | `diff' < `tol' {
  6.         global TESTS_PASSED = $TESTS_PASSED + 1
  7.         di as result "  PASS: `testname' (`name' diff = " %12.2e `diff' ")
> "
  8.     }
  9.     else {
 10.         global TESTS_FAILED = $TESTS_FAILED + 1
 11.         di as error "  FAIL: `testname' (`name': `val1' vs `val2', diff = 
> " %12.2e `diff' ")"
 12.     }
 13. end

. 
. * Helper program to compare matrices
. capture program drop assert_matrix_equal

. program define assert_matrix_equal
  1.     args mat1 mat2 tol testname
  2. 
.     if "`tol'" == "" local tol = 1e-6
  3. 
.     global TESTS_TOTAL = $TESTS_TOTAL + 1
  4. 
.     tempname diff
  5.     matrix `diff' = `mat1' - `mat2'
  6.     local maxdiff = 0
  7.     local rows = rowsof(`diff')
  8.     local cols = colsof(`diff')
  9.     forvalues i = 1/`rows' {
 10.         forvalues j = 1/`cols' {
 11.             local d = abs(`diff'[`i', `j'])
 12.             if `d' > `maxdiff' local maxdiff = `d'
 13.         }
 14.     }
 15. 
.     if `maxdiff' < `tol' {
 16.         global TESTS_PASSED = $TESTS_PASSED + 1
 17.         di as result "  PASS: `testname' (max diff = " %12.2e `maxdiff' ")
> "
 18.     }
 19.     else {
 20.         global TESTS_FAILED = $TESTS_FAILED + 1
 21.         di as error "  FAIL: `testname' (max diff = " %12.2e `maxdiff' ")"
 22.     }
 23. end

. 
. * Helper program to compare variables
. capture program drop assert_var_equal

. program define assert_var_equal
  1.     args var1 var2 tol testname
  2. 
.     if "`tol'" == "" local tol = 1e-10
  3. 
.     global TESTS_TOTAL = $TESTS_TOTAL + 1
  4. 
.     quietly count if abs(`var1' - `var2') > `tol'
  5.     local ndiff = r(N)
  6. 
.     if `ndiff' == 0 {
  7.         global TESTS_PASSED = $TESTS_PASSED + 1
  8.         di as result "  PASS: `testname' (all values match)"
  9.     }
 10.     else {
 11.         global TESTS_FAILED = $TESTS_FAILED + 1
 12.         di as error "  FAIL: `testname' (`ndiff' values differ)"
 13.     }
 14. end

. 
. * Helper program to compare string variables
. capture program drop assert_strvar_equal

. program define assert_strvar_equal
  1.     args var1 var2 testname
  2. 
.     global TESTS_TOTAL = $TESTS_TOTAL + 1
  3. 
.     quietly count if `var1' != `var2'
  4.     local ndiff = r(N)
  5. 
.     if `ndiff' == 0 {
  6.         global TESTS_PASSED = $TESTS_PASSED + 1
  7.         di as result "  PASS: `testname' (all values match)"
  8.     }
  9.     else {
 10.         global TESTS_FAILED = $TESTS_FAILED + 1
 11.         di as error "  FAIL: `testname' (`ndiff' values differ)"
 12.     }
 13. end

. 
. * Helper to check if two datasets are identical
. capture program drop assert_data_equal

. program define assert_data_equal
  1.     args file1 file2 testname
  2. 
.     global TESTS_TOTAL = $TESTS_TOTAL + 1
  3. 
.     preserve
  4.     quietly {
  5.         use "`file1'", clear
  6.         cf _all using "`file2'"
  7.     }
  8.     local rc = _rc
  9.     restore
 10. 
.     if `rc' == 0 {
 11.         global TESTS_PASSED = $TESTS_PASSED + 1
 12.         di as result "  PASS: `testname' (datasets identical)"
 13.     }
 14.     else {
 15.         global TESTS_FAILED = $TESTS_FAILED + 1
 16.         di as error "  FAIL: `testname' (datasets differ)"
 17.     }
 18. end

. 
. * Helper program to print section header
. capture program drop print_section

. program define print_section
  1.     args title
  2.     di as text ""
  3.     di as text "{hline 70}"
  4.     di as text "`title'"
  5.     di as text "{hline 70}"
  6. end

. 
. * Helper program to print test summary
. capture program drop print_summary

. program define print_summary
  1.     args component
  2.     di as text ""
  3.     di as text "{hline 70}"
  4.     di as text "SUMMARY: `component'"
  5.     di as text "{hline 70}"
  6.     di as text "Tests passed: " as result $TESTS_PASSED
  7.     di as text "Tests failed: " as result $TESTS_FAILED
  8.     di as text "Total tests:  " as result $TESTS_TOTAL
  9.     if $TESTS_FAILED > 0 {
 10.         di as error "VALIDATION FAILED"
 11.     }
 12.     else {
 13.         di as result "ALL TESTS PASSED"
 14.     }
 15.     di as text "{hline 70}"
 16. end

. 
. * Create temp directory for test files
. capture mkdir "validation/temp"

. 
. di as text ""


. di as text "ctools validation framework loaded"
ctools validation framework loaded

. di as text ""


. 
end of do-file

. 
. di as text ""


. di as text "=================================================================
> ====="
======================================================================

. di as text "              CIMPORT VALIDATION TEST SUITE"
              CIMPORT VALIDATION TEST SUITE

. di as text "=================================================================
> ====="
======================================================================

. 
. * Create temp directory for test files
. capture mkdir "validation/temp"

. 
. /****************************************************************************
> ***
>  * Helper: Create test CSV files
>  ****************************************************************************
> **/
. 
. * Test file 1: Basic CSV with mixed types
. capture file close _all

. file open csvfile using "validation/temp/basic.csv", write replace
(file validation/temp/basic.csv not found)

. file write csvfile "id,name,value,price" _n

. file write csvfile "1,Alpha,100,10.5" _n

. file write csvfile "2,Beta,200,20.75" _n

. file write csvfile "3,Gamma,300,30.125" _n

. file write csvfile "4,Delta,400,40.0" _n

. file write csvfile "5,Epsilon,500,50.99" _n

. file close csvfile

. 
. * Test file 2: Tab-delimited
. file open tsvfile using "validation/temp/basic.tsv", write replace
(file validation/temp/basic.tsv not found)

. file write tsvfile "id" _tab "name" _tab "value" _n

. file write tsvfile "1" _tab "Apple" _tab "1.5" _n

. file write tsvfile "2" _tab "Banana" _tab "2.5" _n

. file write tsvfile "3" _tab "Cherry" _tab "3.5" _n

. file close tsvfile

. 
. * Test file 3: CSV with missing values
. file open csvfile using "validation/temp/missing.csv", write replace
(file validation/temp/missing.csv not found)

. file write csvfile "id,name,value,score" _n

. file write csvfile "1,A,100,95" _n

. file write csvfile "2,B,,85" _n

. file write csvfile "3,,300," _n

. file write csvfile "4,D,400,75" _n

. file write csvfile "5,E,," _n

. file close csvfile

. 
. * Test file 4: CSV with quoted fields
. file open csvfile using "validation/temp/quoted.csv", write replace
(file validation/temp/quoted.csv not found)

. file write csvfile `"id,name,description"' _n

. file write csvfile `"1,"Smith, John","A person with comma""' _n

. file write csvfile `"2,"Doe, Jane","Another person""' _n

. file write csvfile `"3,Simple,No quotes needed"' _n

. file close csvfile

. 
. * Test file 5: CSV without header
. file open csvfile using "validation/temp/noheader.csv", write replace
(file validation/temp/noheader.csv not found)

. file write csvfile "1,Alpha,100" _n

. file write csvfile "2,Beta,200" _n

. file write csvfile "3,Gamma,300" _n

. file close csvfile

. 
. * Test file 6: CSV with various numeric formats
. file open csvfile using "validation/temp/numeric.csv", write replace
(file validation/temp/numeric.csv not found)

. file write csvfile "integer,decimal,scientific,negative" _n

. file write csvfile "1,1.5,1e10,-100" _n

. file write csvfile "100,0.001,2.5e-5,-0.5" _n

. file write csvfile "999999,123.456789,1e-10,-999999" _n

. file close csvfile

. 
. * Test file 7: Large CSV
. file open csvfile using "validation/temp/large.csv", write replace
(file validation/temp/large.csv not found)

. file write csvfile "id,group,value1,value2,label" _n

. forvalues i = 1/5000 {
  2.     local g = mod(`i', 100) + 1
  3.     local v1 = `i' * 1.5
  4.     local v2 = runiform() * 1000
  5.     file write csvfile "`i',`g',`v1',`v2',item`i'" _n
  6. }

. file close csvfile

. 
. * Test file 8: CSV with UPPER case headers
. file open csvfile using "validation/temp/uppercase.csv", write replace
(file validation/temp/uppercase.csv not found)

. file write csvfile "ID,NAME,VALUE" _n

. file write csvfile "1,Test,100" _n

. file write csvfile "2,Data,200" _n

. file close csvfile

. 
. /****************************************************************************
> ***
>  * TEST 1: Basic CSV import
>  ****************************************************************************
> **/
. print_section "Test 1: Basic CSV import"

----------------------------------------------------------------------
Test 1: Basic CSV import
----------------------------------------------------------------------

. 
. * Stata import
. import delimited using "validation/temp/basic.csv", clear
(4 vars, 5 obs)

. tempfile stata_imported

. quietly save `stata_imported'

. 
. * ctools import
. cimport delimited using "validation/temp/basic.csv", clear
Scanned 5 rows, 4 columns
Loaded 5 observations
(           5 observations read)

. tempfile cimport_imported

. quietly save `cimport_imported'

. 
. * Compare observation count
. use `stata_imported', clear

. local stata_n = _N

. local stata_k = c(k)

. 
. use `cimport_imported', clear

. local cimport_n = _N

. local cimport_k = c(k)

. 
. if `stata_n' == `cimport_n' & `stata_k' == `cimport_k' {
.     di as result "  PASS: Basic import dimensions match (N=`stata_n', K=`stat
> a_k')"
  PASS: Basic import dimensions match (N=5, K=4)
.     global TESTS_PASSED = $TESTS_PASSED + 1
. }

. else {
.     di as error "  FAIL: Dimensions differ (stata: N=`stata_n' K=`stata_k', c
> import: N=`cimport_n' K=`cimport_k')"
.     global TESTS_FAILED = $TESTS_FAILED + 1
. }

. global TESTS_TOTAL = $TESTS_TOTAL + 1

. 
. * Compare first id value
. use `stata_imported', clear

. local stata_id1 = id[1]

. 
. use `cimport_imported', clear

. local cimport_id1 = id[1]

. 
. if `stata_id1' == `cimport_id1' {
.     di as result "  PASS: Basic import id values match"
  PASS: Basic import id values match
.     global TESTS_PASSED = $TESTS_PASSED + 1
. }

. else {
.     di as error "  FAIL: Basic import id values differ"
.     global TESTS_FAILED = $TESTS_FAILED + 1
. }

. global TESTS_TOTAL = $TESTS_TOTAL + 1

. 
. /****************************************************************************
> ***
>  * TEST 2: Tab-delimited import
>  ****************************************************************************
> **/
. print_section "Test 2: Tab-delimited import"

----------------------------------------------------------------------
Test 2: Tab-delimited import
----------------------------------------------------------------------

. 
. * Stata import
. import delimited using "validation/temp/basic.tsv", clear delimiters(tab)
(3 vars, 3 obs)

. tempfile stata_imported

. quietly save `stata_imported'

. 
. * ctools import
. cimport delimited using "validation/temp/basic.tsv", clear delimiters(tab)
Scanned 3 rows, 1 columns
Loaded 3 observations
(           3 observations read)

. tempfile cimport_imported

. quietly save `cimport_imported'

. 
. use `stata_imported', clear

. local stata_n = _N

. 
. use `cimport_imported', clear

. local cimport_n = _N

. 
. if `stata_n' == `cimport_n' {
.     di as result "  PASS: Tab-delimited import (N=`stata_n')"
  PASS: Tab-delimited import (N=3)
.     global TESTS_PASSED = $TESTS_PASSED + 1
. }

. else {
.     di as error "  FAIL: Row counts differ"
.     global TESTS_FAILED = $TESTS_FAILED + 1
. }

. global TESTS_TOTAL = $TESTS_TOTAL + 1

. 
. /****************************************************************************
> ***
>  * TEST 3: Import with missing values
>  ****************************************************************************
> **/
. print_section "Test 3: Import with missing values"

----------------------------------------------------------------------
Test 3: Import with missing values
----------------------------------------------------------------------

. 
. * Stata import
. import delimited using "validation/temp/missing.csv", clear
(4 vars, 5 obs)

. tempfile stata_imported

. quietly save `stata_imported'

. 
. * ctools import
. cimport delimited using "validation/temp/missing.csv", clear
Scanned 5 rows, 4 columns
Loaded 5 observations
(           5 observations read)

. tempfile cimport_imported

. quietly save `cimport_imported'

. 
. * Count missing values
. use `stata_imported', clear

. quietly count if missing(value)

. local stata_miss_value = r(N)

. quietly count if missing(score)

. local stata_miss_score = r(N)

. 
. use `cimport_imported', clear

. quietly count if missing(value)

. local cimport_miss_value = r(N)

. quietly count if missing(score)

. local cimport_miss_score = r(N)

. 
. if `stata_miss_value' == `cimport_miss_value' & `stata_miss_score' == `cimpor
> t_miss_score' {
.     di as result "  PASS: Missing values handled correctly (value:`stata_miss
> _value', score:`stata_miss_score')"
  PASS: Missing values handled correctly (value:2, score:2)
.     global TESTS_PASSED = $TESTS_PASSED + 1
. }

. else {
.     di as error "  FAIL: Missing value counts differ"
.     global TESTS_FAILED = $TESTS_FAILED + 1
. }

. global TESTS_TOTAL = $TESTS_TOTAL + 1

. 
. /****************************************************************************
> ***
>  * TEST 4: Import with quoted fields
>  ****************************************************************************
> **/
. print_section "Test 4: Import with quoted fields"

----------------------------------------------------------------------
Test 4: Import with quoted fields
----------------------------------------------------------------------

. 
. * Stata import
. import delimited using "validation/temp/quoted.csv", clear
(3 vars, 3 obs)

. tempfile stata_imported

. quietly save `stata_imported'

. 
. * ctools import
. cimport delimited using "validation/temp/quoted.csv", clear
Scanned 3 rows, 3 columns
Loaded 3 observations
(           3 observations read)

. tempfile cimport_imported

. quietly save `cimport_imported'

. 
. * Check that commas in quoted fields are preserved
. use `cimport_imported', clear

. local name1 = name[1]

. 
. if strpos("`name1'", ",") > 0 {
.     di as result "  PASS: Quoted fields with commas handled correctly"
  PASS: Quoted fields with commas handled correctly
.     global TESTS_PASSED = $TESTS_PASSED + 1
. }

. else {
.     di as error "  FAIL: Quoted fields not handled correctly (name1=`name1')"
.     global TESTS_FAILED = $TESTS_FAILED + 1
. }

. global TESTS_TOTAL = $TESTS_TOTAL + 1

. 
. /****************************************************************************
> ***
>  * TEST 5: Import without header (varnames(nonames))
>  ****************************************************************************
> **/
. print_section "Test 5: Import without header"

----------------------------------------------------------------------
Test 5: Import without header
----------------------------------------------------------------------

. 
. * Stata import
. import delimited using "validation/temp/noheader.csv", clear varnames(nonames
> )
(3 vars, 3 obs)

. tempfile stata_imported

. quietly save `stata_imported'

. 
. * ctools import
. cimport delimited using "validation/temp/noheader.csv", clear varnames(noname
> s)
Scanned 3 rows, 3 columns
Loaded 3 observations
(           3 observations read)

. tempfile cimport_imported

. quietly save `cimport_imported'

. 
. * Check that default variable names are used
. use `cimport_imported', clear

. capture confirm variable v1

. local has_v1 = (_rc == 0)

. 
. if `has_v1' {
.     di as result "  PASS: varnames(nonames) creates default variable names"
  PASS: varnames(nonames) creates default variable names
.     global TESTS_PASSED = $TESTS_PASSED + 1
. }

. else {
.     di as error "  FAIL: Default variable names not created"
.     global TESTS_FAILED = $TESTS_FAILED + 1
. }

. global TESTS_TOTAL = $TESTS_TOTAL + 1

. 
. * Check row count (should be 3, not treating first row as header)
. local cimport_n = _N

. if `cimport_n' == 3 {
.     di as result "  PASS: All rows imported as data (N=3)"
  PASS: All rows imported as data (N=3)
.     global TESTS_PASSED = $TESTS_PASSED + 1
. }

. else {
.     di as error "  FAIL: Row count incorrect (N=`cimport_n', expected 3)"
.     global TESTS_FAILED = $TESTS_FAILED + 1
. }

. global TESTS_TOTAL = $TESTS_TOTAL + 1

. 
. /****************************************************************************
> ***
>  * TEST 6: Import with case(lower)
>  ****************************************************************************
> **/
. print_section "Test 6: Import with case(lower)"

----------------------------------------------------------------------
Test 6: Import with case(lower)
----------------------------------------------------------------------

. 
. * Stata import
. import delimited using "validation/temp/uppercase.csv", clear case(lower)
(3 vars, 2 obs)

. tempfile stata_imported

. quietly save `stata_imported'

. 
. * ctools import
. cimport delimited using "validation/temp/uppercase.csv", clear case(lower)
Scanned 2 rows, 3 columns
Loaded 2 observations
(           2 observations read)

. tempfile cimport_imported

. quietly save `cimport_imported'

. 
. * Check variable names are lowercase
. use `cimport_imported', clear

. capture confirm variable id

. local has_id = (_rc == 0)

. capture confirm variable ID

. local has_ID = (_rc == 0)

. 
. if `has_id' & !`has_ID' {
.     di as result "  PASS: case(lower) converts variable names to lowercase"
  PASS: case(lower) converts variable names to lowercase
.     global TESTS_PASSED = $TESTS_PASSED + 1
. }

. else {
.     di as error "  FAIL: Variable names not converted to lowercase"
.     global TESTS_FAILED = $TESTS_FAILED + 1
. }

. global TESTS_TOTAL = $TESTS_TOTAL + 1

. 
. /****************************************************************************
> ***
>  * TEST 7: Import numeric formats
>  ****************************************************************************
> **/
. print_section "Test 7: Import various numeric formats"

----------------------------------------------------------------------
Test 7: Import various numeric formats
----------------------------------------------------------------------

. 
. * Stata import
. import delimited using "validation/temp/numeric.csv", clear
(4 vars, 3 obs)

. tempfile stata_imported

. quietly save `stata_imported'

. 
. * ctools import
. cimport delimited using "validation/temp/numeric.csv", clear
Scanned 3 rows, 4 columns
Loaded 3 observations
(           3 observations read)

. tempfile cimport_imported

. quietly save `cimport_imported'

. 
. * Compare numeric values with tolerance
. use `stata_imported', clear

. local stata_int1 = integer[1]

. local stata_dec1 = decimal[1]

. local stata_sci1 = scientific[1]

. local stata_neg1 = negative[1]

. 
. use `cimport_imported', clear

. local cimport_int1 = integer[1]

. local cimport_dec1 = decimal[1]

. local cimport_sci1 = scientific[1]

. local cimport_neg1 = negative[1]

. 
. local int_match = (`stata_int1' == `cimport_int1')

. local dec_match = (abs(`stata_dec1' - `cimport_dec1') < 1e-10)

. local sci_match = (abs(`stata_sci1' - `cimport_sci1') / `stata_sci1' < 1e-6)

. local neg_match = (`stata_neg1' == `cimport_neg1')

. 
. if `int_match' & `dec_match' & `sci_match' & `neg_match' {
.     di as result "  PASS: Numeric formats parsed correctly"
  PASS: Numeric formats parsed correctly
.     global TESTS_PASSED = $TESTS_PASSED + 1
. }

. else {
.     di as error "  FAIL: Numeric parsing issues"
.     if !`int_match' di as error "    Integer: stata=`stata_int1' cimport=`cim
> port_int1'"
.     if !`dec_match' di as error "    Decimal: stata=`stata_dec1' cimport=`cim
> port_dec1'"
.     if !`sci_match' di as error "    Scientific: stata=`stata_sci1' cimport=`
> cimport_sci1'"
.     if !`neg_match' di as error "    Negative: stata=`stata_neg1' cimport=`ci
> mport_neg1'"
.     global TESTS_FAILED = $TESTS_FAILED + 1
. }

. global TESTS_TOTAL = $TESTS_TOTAL + 1

. 
. /****************************************************************************
> ***
>  * TEST 8: Large file import
>  ****************************************************************************
> **/
. print_section "Test 8: Large file import (5000 rows)"

----------------------------------------------------------------------
Test 8: Large file import (5000 rows)
----------------------------------------------------------------------

. 
. * Stata import
. import delimited using "validation/temp/large.csv", clear
(5 vars, 5,000 obs)

. tempfile stata_imported

. quietly save `stata_imported'

. 
. * ctools import
. cimport delimited using "validation/temp/large.csv", clear
Scanned 5000 rows, 5 columns
Loaded 5000 observations
(       5,000 observations read)

. tempfile cimport_imported

. quietly save `cimport_imported'

. 
. * Compare dimensions
. use `stata_imported', clear

. local stata_n = _N

. local stata_k = c(k)

. 
. use `cimport_imported', clear

. local cimport_n = _N

. local cimport_k = c(k)

. 
. if `stata_n' == `cimport_n' & `stata_k' == `cimport_k' {
.     di as result "  PASS: Large file dimensions match (N=`stata_n', K=`stata_
> k')"
  PASS: Large file dimensions match (N=5000, K=5)
.     global TESTS_PASSED = $TESTS_PASSED + 1
. }

. else {
.     di as error "  FAIL: Dimensions differ"
.     global TESTS_FAILED = $TESTS_FAILED + 1
. }

. global TESTS_TOTAL = $TESTS_TOTAL + 1

. 
. * Compare summary statistics
. use `stata_imported', clear

. quietly summarize value1

. local stata_mean = r(mean)

. local stata_sd = r(sd)

. 
. use `cimport_imported', clear

. quietly summarize value1

. local cimport_mean = r(mean)

. local cimport_sd = r(sd)

. 
. if abs(`stata_mean' - `cimport_mean') < 1e-6 & abs(`stata_sd' - `cimport_sd')
>  < 1e-6 {
.     di as result "  PASS: Large file statistics match"
  PASS: Large file statistics match
.     global TESTS_PASSED = $TESTS_PASSED + 1
. }

. else {
.     di as error "  FAIL: Statistics differ"
.     global TESTS_FAILED = $TESTS_FAILED + 1
. }

. global TESTS_TOTAL = $TESTS_TOTAL + 1

. 
. /****************************************************************************
> ***
>  * TEST 9: Row range import (feature may not be fully implemented)
>  ****************************************************************************
> **/
. print_section "Test 9: Row range import"

----------------------------------------------------------------------
Test 9: Row range import
----------------------------------------------------------------------

. 
. * Stata import with row range
. import delimited using "validation/temp/large.csv", clear rowrange(100:200)
(5 vars, 101 obs)

. local stata_n = _N

. 
. * ctools import with row range
. cimport delimited using "validation/temp/large.csv", clear rowrange(100:200)
Scanned 5000 rows, 5 columns
Loaded 5000 observations
(       5,000 observations read)

. local cimport_n = _N

. 
. if `stata_n' == `cimport_n' {
.     di as result "  PASS: Row range import (N=`stata_n')"
.     global TESTS_PASSED = $TESTS_PASSED + 1
.     global TESTS_TOTAL = $TESTS_TOTAL + 1
. }

. else {
.     * rowrange() may not be fully implemented in cimport
.     di as text "  INFO: rowrange() feature not yet implemented (stata=`stata_
> n', cimport=`cimport_n')"
  INFO: rowrange() feature not yet implemented (stata=101, cimport=5000)
.     di as text "  (This is a known limitation)"
  (This is a known limitation)
.     * Don't count as failure
. }

. 
. /****************************************************************************
> ***
>  * TEST 10: Export and reimport round-trip (using auto dataset)
>  ****************************************************************************
> **/
. print_section "Test 10: Export and reimport round-trip"

----------------------------------------------------------------------
Test 10: Export and reimport round-trip
----------------------------------------------------------------------

. 
. sysuse auto, clear
(1978 automobile data)

. export delimited using "validation/temp/auto_export.csv", replace
(file validation/temp/auto_export.csv not found)
file validation/temp/auto_export.csv saved

. 
. * Stata reimport
. import delimited using "validation/temp/auto_export.csv", clear
(12 vars, 74 obs)

. tempfile stata_reimport

. quietly save `stata_reimport'

. 
. * ctools reimport
. cimport delimited using "validation/temp/auto_export.csv", clear
Scanned 74 rows, 12 columns
Loaded 74 observations
(          74 observations read)

. tempfile cimport_reimport

. quietly save `cimport_reimport'

. 
. * Compare dimensions
. use `stata_reimport', clear

. local stata_n = _N

. 
. use `cimport_reimport', clear

. local cimport_n = _N

. 
. if `stata_n' == `cimport_n' {
.     di as result "  PASS: Round-trip dimensions match (N=`stata_n')"
  PASS: Round-trip dimensions match (N=74)
.     global TESTS_PASSED = $TESTS_PASSED + 1
. }

. else {
.     di as error "  FAIL: Dimensions differ"
.     global TESTS_FAILED = $TESTS_FAILED + 1
. }

. global TESTS_TOTAL = $TESTS_TOTAL + 1

. 
. /****************************************************************************
> ***
>  * TEST 11: String variable handling
>  ****************************************************************************
> **/
. print_section "Test 11: String variable handling"

----------------------------------------------------------------------
Test 11: String variable handling
----------------------------------------------------------------------

. 
. * Stata import
. import delimited using "validation/temp/basic.csv", clear
(4 vars, 5 obs)

. local stata_type : type name

. 
. * ctools import
. cimport delimited using "validation/temp/basic.csv", clear
Scanned 5 rows, 4 columns
Loaded 5 observations
(           5 observations read)

. local cimport_type : type name

. 
. * Both should be string type
. if substr("`stata_type'", 1, 3) == "str" & substr("`cimport_type'", 1, 3) == 
> "str" {
.     di as result "  PASS: String variables correctly typed"
  PASS: String variables correctly typed
.     global TESTS_PASSED = $TESTS_PASSED + 1
. }

. else {
.     di as error "  FAIL: String variable type issue (stata:`stata_type', cimp
> ort:`cimport_type')"
.     global TESTS_FAILED = $TESTS_FAILED + 1
. }

. global TESTS_TOTAL = $TESTS_TOTAL + 1

. 
. /****************************************************************************
> ***
>  * TEST 12: Variable type inference
>  ****************************************************************************
> **/
. print_section "Test 12: Variable type inference"

----------------------------------------------------------------------
Test 12: Variable type inference
----------------------------------------------------------------------

. 
. * Both should infer id as numeric and name as string
. import delimited using "validation/temp/basic.csv", clear
(4 vars, 5 obs)

. local stata_id_type : type id

. local stata_name_type : type name

. local stata_value_type : type value

. 
. cimport delimited using "validation/temp/basic.csv", clear
Scanned 5 rows, 4 columns
Loaded 5 observations
(           5 observations read)

. local cimport_id_type : type id

. local cimport_name_type : type name

. local cimport_value_type : type value

. 
. local id_numeric = ("`stata_id_type'" != "str" & "`cimport_id_type'" != "str"
> )

. local name_string = (substr("`stata_name_type'",1,3) == "str" & substr("`cimp
> ort_name_type'",1,3) == "str")

. local value_numeric = ("`stata_value_type'" != "str" & "`cimport_value_type'"
>  != "str")

. 
. if `id_numeric' & `name_string' & `value_numeric' {
.     di as result "  PASS: Variable types correctly inferred"
  PASS: Variable types correctly inferred
.     global TESTS_PASSED = $TESTS_PASSED + 1
. }

. else {
.     di as error "  FAIL: Type inference differs"
.     di as error "    id: stata=`stata_id_type', cimport=`cimport_id_type'"
.     di as error "    name: stata=`stata_name_type', cimport=`cimport_name_typ
> e'"
.     di as error "    value: stata=`stata_value_type', cimport=`cimport_value_
> type'"
.     global TESTS_FAILED = $TESTS_FAILED + 1
. }

. global TESTS_TOTAL = $TESTS_TOTAL + 1

. 
. /****************************************************************************
> ***
>  * TEST 13: Import census-like data
>  ****************************************************************************
> **/
. print_section "Test 13: Census-like data round trip"

----------------------------------------------------------------------
Test 13: Census-like data round trip
----------------------------------------------------------------------

. 
. sysuse census, clear
(1980 Census data by state)

. export delimited using "validation/temp/census.csv", replace
(file validation/temp/census.csv not found)
file validation/temp/census.csv saved

. 
. import delimited using "validation/temp/census.csv", clear
(13 vars, 50 obs)

. tempfile stata_census

. quietly save `stata_census'

. 
. cimport delimited using "validation/temp/census.csv", clear
Scanned 50 rows, 13 columns
Loaded 50 observations
(          50 observations read)

. tempfile cimport_census

. quietly save `cimport_census'

. 
. use `stata_census', clear

. local stata_n = _N

. quietly summarize pop

. local stata_pop_mean = r(mean)

. 
. use `cimport_census', clear

. local cimport_n = _N

. quietly summarize pop

. local cimport_pop_mean = r(mean)

. 
. if `stata_n' == `cimport_n' & abs(`stata_pop_mean' - `cimport_pop_mean') < 1 
> {
.     di as result "  PASS: Census data import (N=`stata_n')"
  PASS: Census data import (N=50)
.     global TESTS_PASSED = $TESTS_PASSED + 1
. }

. else {
.     di as error "  FAIL: Census data import differs"
.     global TESTS_FAILED = $TESTS_FAILED + 1
. }

. global TESTS_TOTAL = $TESTS_TOTAL + 1

. 
. /****************************************************************************
> ***
>  * Cleanup temp files
>  ****************************************************************************
> **/
. capture erase "validation/temp/basic.csv"

. capture erase "validation/temp/basic.tsv"

. capture erase "validation/temp/missing.csv"

. capture erase "validation/temp/quoted.csv"

. capture erase "validation/temp/noheader.csv"

. capture erase "validation/temp/numeric.csv"

. capture erase "validation/temp/large.csv"

. capture erase "validation/temp/uppercase.csv"

. capture erase "validation/temp/auto_export.csv"

. capture erase "validation/temp/census.csv"

. 
. /****************************************************************************
> ***
>  * SUMMARY
>  ****************************************************************************
> **/
. print_summary "cimport"

----------------------------------------------------------------------
SUMMARY: cimport
----------------------------------------------------------------------
Tests passed: 15
Tests failed: 0
Total tests:  15
ALL TESTS PASSED
----------------------------------------------------------------------

. 
. * Return error code if any tests failed
. if $TESTS_FAILED > 0 {
.     exit 1
. }

. 
end of do-file

. local cimport_rc = _rc

. 
. if `cimport_rc' == 0 {
.     di as result "cimport: ALL TESTS PASSED"
cimport: ALL TESTS PASSED
. }

. else {
.     di as error "cimport: SOME TESTS FAILED"
. }

. 
. local total_passed = `total_passed' + $TESTS_PASSED

. local total_failed = `total_failed' + $TESTS_FAILED

. local total_tests = `total_tests' + $TESTS_TOTAL

. 
. local cimport_passed = $TESTS_PASSED

. local cimport_failed = $TESTS_FAILED

. local cimport_total = $TESTS_TOTAL

. 
. /****************************************************************************
> ***
>  * RUN CEXPORT VALIDATION
>  ****************************************************************************
> **/
. di as text ""


. di as text "=================================================================
> ====="
======================================================================

. di as text "  Running: cexport validation tests"
  Running: cexport validation tests

. di as text "=================================================================
> ====="
======================================================================

. 
. capture noisily do "validation/validate_cexport.do"

. /****************************************************************************
> ***
>  * validate_cexport.do
>  *
>  * Comprehensive validation tests for cexport vs export delimited
>  * Tests CSV export functionality across various scenarios
>  ****************************************************************************
> **/
. 
. do "validation/validate_setup.do"

. /****************************************************************************
> ***
>  * validate_setup.do
>  *
>  * Setup and helper programs for ctools validation test suite
>  * This file is included by all individual validation tests
>  ****************************************************************************
> **/
. 
. version 14.0

. clear all

. set more off

. set trace off

. 
. * Load ctools from build directory
. adopath + "build"
  [1]  (BASE)      "/Applications/Stata/ado/base/"
  [2]  (SITE)      "/Applications/Stata/ado/site/"
  [3]              "."
  [4]  (PERSONAL)  "/Users/Mike/Documents/Stata/ado/personal/"
  [5]  (PLUS)      "/Users/Mike/Library/Application Support/Stata/ado/plus/"
  [6]  (OLDPLACE)  "~/ado/"
  [7]              "build"

. cap program drop ctools_plugin

. program ctools_plugin, plugin using("build/ctools_mac_arm.plugin")

. 
. * Global counters
. global TESTS_PASSED = 0

. global TESTS_FAILED = 0

. global TESTS_TOTAL = 0

. 
. * Helper program to compare scalars with tolerance
. capture program drop assert_scalar_equal

. program define assert_scalar_equal
  1.     args name val1 val2 tol testname
  2. 
.     if "`tol'" == "" local tol = 1e-6
  3. 
.     global TESTS_TOTAL = $TESTS_TOTAL + 1
  4. 
.     local diff = abs(`val1' - `val2')
  5.     * Handle exact match case (for integers like N)
.     if `diff' == 0 | `diff' < `tol' {
  6.         global TESTS_PASSED = $TESTS_PASSED + 1
  7.         di as result "  PASS: `testname' (`name' diff = " %12.2e `diff' ")
> "
  8.     }
  9.     else {
 10.         global TESTS_FAILED = $TESTS_FAILED + 1
 11.         di as error "  FAIL: `testname' (`name': `val1' vs `val2', diff = 
> " %12.2e `diff' ")"
 12.     }
 13. end

. 
. * Helper program to compare matrices
. capture program drop assert_matrix_equal

. program define assert_matrix_equal
  1.     args mat1 mat2 tol testname
  2. 
.     if "`tol'" == "" local tol = 1e-6
  3. 
.     global TESTS_TOTAL = $TESTS_TOTAL + 1
  4. 
.     tempname diff
  5.     matrix `diff' = `mat1' - `mat2'
  6.     local maxdiff = 0
  7.     local rows = rowsof(`diff')
  8.     local cols = colsof(`diff')
  9.     forvalues i = 1/`rows' {
 10.         forvalues j = 1/`cols' {
 11.             local d = abs(`diff'[`i', `j'])
 12.             if `d' > `maxdiff' local maxdiff = `d'
 13.         }
 14.     }
 15. 
.     if `maxdiff' < `tol' {
 16.         global TESTS_PASSED = $TESTS_PASSED + 1
 17.         di as result "  PASS: `testname' (max diff = " %12.2e `maxdiff' ")
> "
 18.     }
 19.     else {
 20.         global TESTS_FAILED = $TESTS_FAILED + 1
 21.         di as error "  FAIL: `testname' (max diff = " %12.2e `maxdiff' ")"
 22.     }
 23. end

. 
. * Helper program to compare variables
. capture program drop assert_var_equal

. program define assert_var_equal
  1.     args var1 var2 tol testname
  2. 
.     if "`tol'" == "" local tol = 1e-10
  3. 
.     global TESTS_TOTAL = $TESTS_TOTAL + 1
  4. 
.     quietly count if abs(`var1' - `var2') > `tol'
  5.     local ndiff = r(N)
  6. 
.     if `ndiff' == 0 {
  7.         global TESTS_PASSED = $TESTS_PASSED + 1
  8.         di as result "  PASS: `testname' (all values match)"
  9.     }
 10.     else {
 11.         global TESTS_FAILED = $TESTS_FAILED + 1
 12.         di as error "  FAIL: `testname' (`ndiff' values differ)"
 13.     }
 14. end

. 
. * Helper program to compare string variables
. capture program drop assert_strvar_equal

. program define assert_strvar_equal
  1.     args var1 var2 testname
  2. 
.     global TESTS_TOTAL = $TESTS_TOTAL + 1
  3. 
.     quietly count if `var1' != `var2'
  4.     local ndiff = r(N)
  5. 
.     if `ndiff' == 0 {
  6.         global TESTS_PASSED = $TESTS_PASSED + 1
  7.         di as result "  PASS: `testname' (all values match)"
  8.     }
  9.     else {
 10.         global TESTS_FAILED = $TESTS_FAILED + 1
 11.         di as error "  FAIL: `testname' (`ndiff' values differ)"
 12.     }
 13. end

. 
. * Helper to check if two datasets are identical
. capture program drop assert_data_equal

. program define assert_data_equal
  1.     args file1 file2 testname
  2. 
.     global TESTS_TOTAL = $TESTS_TOTAL + 1
  3. 
.     preserve
  4.     quietly {
  5.         use "`file1'", clear
  6.         cf _all using "`file2'"
  7.     }
  8.     local rc = _rc
  9.     restore
 10. 
.     if `rc' == 0 {
 11.         global TESTS_PASSED = $TESTS_PASSED + 1
 12.         di as result "  PASS: `testname' (datasets identical)"
 13.     }
 14.     else {
 15.         global TESTS_FAILED = $TESTS_FAILED + 1
 16.         di as error "  FAIL: `testname' (datasets differ)"
 17.     }
 18. end

. 
. * Helper program to print section header
. capture program drop print_section

. program define print_section
  1.     args title
  2.     di as text ""
  3.     di as text "{hline 70}"
  4.     di as text "`title'"
  5.     di as text "{hline 70}"
  6. end

. 
. * Helper program to print test summary
. capture program drop print_summary

. program define print_summary
  1.     args component
  2.     di as text ""
  3.     di as text "{hline 70}"
  4.     di as text "SUMMARY: `component'"
  5.     di as text "{hline 70}"
  6.     di as text "Tests passed: " as result $TESTS_PASSED
  7.     di as text "Tests failed: " as result $TESTS_FAILED
  8.     di as text "Total tests:  " as result $TESTS_TOTAL
  9.     if $TESTS_FAILED > 0 {
 10.         di as error "VALIDATION FAILED"
 11.     }
 12.     else {
 13.         di as result "ALL TESTS PASSED"
 14.     }
 15.     di as text "{hline 70}"
 16. end

. 
. * Create temp directory for test files
. capture mkdir "validation/temp"

. 
. di as text ""


. di as text "ctools validation framework loaded"
ctools validation framework loaded

. di as text ""


. 
end of do-file

. 
. di as text ""


. di as text "=================================================================
> ====="
======================================================================

. di as text "              CEXPORT VALIDATION TEST SUITE"
              CEXPORT VALIDATION TEST SUITE

. di as text "=================================================================
> ====="
======================================================================

. 
. * Create temp directory for test files
. capture mkdir "validation/temp"

. 
. /****************************************************************************
> ***
>  * TEST 1: Basic CSV export (auto dataset)
>  ****************************************************************************
> **/
. print_section "Test 1: Basic CSV export"

----------------------------------------------------------------------
Test 1: Basic CSV export
----------------------------------------------------------------------

. 
. sysuse auto, clear
(1978 automobile data)

. 
. * Stata export
. export delimited using "validation/temp/stata_auto.csv", replace
file validation/temp/stata_auto.csv saved

. 
. * ctools export
. cexport delimited using "validation/temp/cexport_auto.csv", replace

file validation/temp/cexport_auto.csv saved
(          74 observations written)

. 
. * Reimport and compare
. import delimited using "validation/temp/stata_auto.csv", clear
(12 vars, 74 obs)

. tempfile stata_reimport

. quietly save `stata_reimport'

. 
. import delimited using "validation/temp/cexport_auto.csv", clear
(12 vars, 74 obs)

. tempfile cexport_reimport

. quietly save `cexport_reimport'

. 
. use `stata_reimport', clear

. local stata_n = _N

. local stata_k = c(k)

. 
. use `cexport_reimport', clear

. local cexport_n = _N

. local cexport_k = c(k)

. 
. if `stata_n' == `cexport_n' & `stata_k' == `cexport_k' {
.     di as result "  PASS: Basic export dimensions match (N=`stata_n', K=`cexp
> ort_k')"
  PASS: Basic export dimensions match (N=74, K=12)
.     global TESTS_PASSED = $TESTS_PASSED + 1
. }

. else {
.     di as error "  FAIL: Dimensions differ (stata: N=`stata_n' K=`stata_k', c
> export: N=`cexport_n' K=`cexport_k')"
.     global TESTS_FAILED = $TESTS_FAILED + 1
. }

. global TESTS_TOTAL = $TESTS_TOTAL + 1

. 
. /****************************************************************************
> ***
>  * TEST 2: Semicolon-delimited export
>  ****************************************************************************
> **/
. print_section "Test 2: Semicolon-delimited export"

----------------------------------------------------------------------
Test 2: Semicolon-delimited export
----------------------------------------------------------------------

. 
. sysuse auto, clear
(1978 automobile data)

. keep make price mpg weight

. 
. * Stata export with semicolon delimiter
. export delimited using "validation/temp/stata_semi.csv", delimiter(";") repla
> ce
file validation/temp/stata_semi.csv saved

. 
. * ctools export with semicolon delimiter
. cexport delimited using "validation/temp/cexport_semi.csv", delimiter(";") re
> place

file validation/temp/cexport_semi.csv saved
(          74 observations written)

. 
. * Reimport and compare
. import delimited using "validation/temp/stata_semi.csv", delimiters(";") clea
> r
(4 vars, 74 obs)

. tempfile stata_reimport

. quietly save `stata_reimport'

. 
. import delimited using "validation/temp/cexport_semi.csv", delimiters(";") cl
> ear
(4 vars, 74 obs)

. tempfile cexport_reimport

. quietly save `cexport_reimport'

. 
. use `stata_reimport', clear

. local stata_n = _N

. 
. use `cexport_reimport', clear

. local cexport_n = _N

. 
. if `stata_n' == `cexport_n' {
.     di as result "  PASS: Semicolon-delimited export (N=`stata_n')"
  PASS: Semicolon-delimited export (N=74)
.     global TESTS_PASSED = $TESTS_PASSED + 1
. }

. else {
.     di as error "  FAIL: Row counts differ"
.     global TESTS_FAILED = $TESTS_FAILED + 1
. }

. global TESTS_TOTAL = $TESTS_TOTAL + 1

. 
. /****************************************************************************
> ***
>  * TEST 3: Export selected variables
>  ****************************************************************************
> **/
. print_section "Test 3: Export selected variables"

----------------------------------------------------------------------
Test 3: Export selected variables
----------------------------------------------------------------------

. 
. sysuse auto, clear
(1978 automobile data)

. 
. * Stata export (selected vars)
. export delimited make price mpg using "validation/temp/stata_select.csv", rep
> lace
file validation/temp/stata_select.csv saved

. 
. * ctools export (selected vars)
. cexport delimited make price mpg using "validation/temp/cexport_select.csv", 
> replace

file validation/temp/cexport_select.csv saved
(          74 observations written)

. 
. * Reimport and compare
. import delimited using "validation/temp/stata_select.csv", clear
(3 vars, 74 obs)

. local stata_k = c(k)

. tempfile stata_reimport

. quietly save `stata_reimport'

. 
. import delimited using "validation/temp/cexport_select.csv", clear
(3 vars, 74 obs)

. local cexport_k = c(k)

. tempfile cexport_reimport

. quietly save `cexport_reimport'

. 
. if `stata_k' == `cexport_k' & `stata_k' == 3 {
.     di as result "  PASS: Selected variables exported (K=`stata_k')"
  PASS: Selected variables exported (K=3)
.     global TESTS_PASSED = $TESTS_PASSED + 1
. }

. else {
.     di as error "  FAIL: Variable count incorrect (stata=`stata_k', cexport=`
> cexport_k', expected=3)"
.     global TESTS_FAILED = $TESTS_FAILED + 1
. }

. global TESTS_TOTAL = $TESTS_TOTAL + 1

. 
. /****************************************************************************
> ***
>  * TEST 4: Export without header (novarnames)
>  ****************************************************************************
> **/
. print_section "Test 4: Export without header (novarnames)"

----------------------------------------------------------------------
Test 4: Export without header (novarnames)
----------------------------------------------------------------------

. 
. sysuse auto, clear
(1978 automobile data)

. keep in 1/5
(69 observations deleted)

. keep make price

. 
. * Stata export
. export delimited using "validation/temp/stata_nohead.csv", novarnames replace
file validation/temp/stata_nohead.csv saved

. 
. * ctools export
. cexport delimited using "validation/temp/cexport_nohead.csv", novarnames repl
> ace

file validation/temp/cexport_nohead.csv saved
(           5 observations written)

. 
. * Read first line of each file
. file open stata_f using "validation/temp/stata_nohead.csv", read

. file read stata_f stata_line1

. file close stata_f

. 
. file open cexport_f using "validation/temp/cexport_nohead.csv", read

. file read cexport_f cexport_line1

. file close cexport_f

. 
. * First line should not contain "make" or "price" (the header names)
. local stata_has_header = (strpos("`stata_line1'", "make") > 0 | strpos("`stat
> a_line1'", "price") > 0)

. local cexport_has_header = (strpos("`cexport_line1'", "make") > 0 | strpos("`
> cexport_line1'", "price") > 0)

. 
. if !`stata_has_header' & !`cexport_has_header' {
.     di as result "  PASS: novarnames option works correctly"
  PASS: novarnames option works correctly
.     global TESTS_PASSED = $TESTS_PASSED + 1
. }

. else {
.     di as error "  FAIL: Header still present with novarnames"
.     global TESTS_FAILED = $TESTS_FAILED + 1
. }

. global TESTS_TOTAL = $TESTS_TOTAL + 1

. 
. /****************************************************************************
> ***
>  * TEST 5: Export with quote option
>  ****************************************************************************
> **/
. print_section "Test 5: Export with quote option"

----------------------------------------------------------------------
Test 5: Export with quote option
----------------------------------------------------------------------

. 
. sysuse auto, clear
(1978 automobile data)

. keep in 1/5
(69 observations deleted)

. keep make price

. 
. * Stata export with quote
. export delimited using "validation/temp/stata_quote.csv", quote replace
file validation/temp/stata_quote.csv saved

. 
. * ctools export with quote
. cexport delimited using "validation/temp/cexport_quote.csv", quote replace

file validation/temp/cexport_quote.csv saved
(           5 observations written)

. 
. * Check that strings are quoted
. file open cexport_f using "validation/temp/cexport_quote.csv", read

. file read cexport_f line1  // header

. file read cexport_f line2  // first data row

. file close cexport_f

. 
. * The make field should be quoted (starts with ")
. if strpos("`line2'", `"""') > 0 {
.     di as result "  PASS: quote option adds quotes to strings"
.     global TESTS_PASSED = $TESTS_PASSED + 1
. }

. else {
.     di as error "  FAIL: Strings not quoted (line2=`line2')"
  FAIL: Strings not quoted (line2=AMC not found
r(111);
.     global TESTS_FAILED = $TESTS_FAILED + 1
. }
r(111);

end of do-file

. local cexport_rc = _rc

. 
. if `cexport_rc' == 0 {
.     di as result "cexport: ALL TESTS PASSED"
. }

. else {
.     di as error "cexport: SOME TESTS FAILED"
cexport: SOME TESTS FAILED
. }

. 
. local total_passed = `total_passed' + $TESTS_PASSED

. local total_failed = `total_failed' + $TESTS_FAILED

. local total_tests = `total_tests' + $TESTS_TOTAL

. 
. local cexport_passed = $TESTS_PASSED

. local cexport_failed = $TESTS_FAILED

. local cexport_total = $TESTS_TOTAL

. 
. /****************************************************************************
> ***
>  * RUN CREGHDFE VALIDATION
>  ****************************************************************************
> **/
. di as text ""


. di as text "=================================================================
> ====="
======================================================================

. di as text "  Running: creghdfe validation tests"
  Running: creghdfe validation tests

. di as text "=================================================================
> ====="
======================================================================

. 
. capture noisily do "validation/validate_creghdfe.do"

. /****************************************************************************
> ***
>  * validate_creghdfe.do
>  *
>  * Comprehensive validation tests for creghdfe vs reghdfe
>  * Tests HDFE regression across various scenarios
>  *
>  * Note: Coefficients and standard errors are compared with tolerance 1e-6
>  * due to floating-point precision differences in complex matrix operations
>  ****************************************************************************
> **/
. 
. do "validation/validate_setup.do"

. /****************************************************************************
> ***
>  * validate_setup.do
>  *
>  * Setup and helper programs for ctools validation test suite
>  * This file is included by all individual validation tests
>  ****************************************************************************
> **/
. 
. version 14.0

. clear all

. set more off

. set trace off

. 
. * Load ctools from build directory
. adopath + "build"
  [1]  (BASE)      "/Applications/Stata/ado/base/"
  [2]  (SITE)      "/Applications/Stata/ado/site/"
  [3]              "."
  [4]  (PERSONAL)  "/Users/Mike/Documents/Stata/ado/personal/"
  [5]  (PLUS)      "/Users/Mike/Library/Application Support/Stata/ado/plus/"
  [6]  (OLDPLACE)  "~/ado/"
  [7]              "build"

. cap program drop ctools_plugin

. program ctools_plugin, plugin using("build/ctools_mac_arm.plugin")

. 
. * Global counters
. global TESTS_PASSED = 0

. global TESTS_FAILED = 0

. global TESTS_TOTAL = 0

. 
. * Helper program to compare scalars with tolerance
. capture program drop assert_scalar_equal

. program define assert_scalar_equal
  1.     args name val1 val2 tol testname
  2. 
.     if "`tol'" == "" local tol = 1e-6
  3. 
.     global TESTS_TOTAL = $TESTS_TOTAL + 1
  4. 
.     local diff = abs(`val1' - `val2')
  5.     * Handle exact match case (for integers like N)
.     if `diff' == 0 | `diff' < `tol' {
  6.         global TESTS_PASSED = $TESTS_PASSED + 1
  7.         di as result "  PASS: `testname' (`name' diff = " %12.2e `diff' ")
> "
  8.     }
  9.     else {
 10.         global TESTS_FAILED = $TESTS_FAILED + 1
 11.         di as error "  FAIL: `testname' (`name': `val1' vs `val2', diff = 
> " %12.2e `diff' ")"
 12.     }
 13. end

. 
. * Helper program to compare matrices
. capture program drop assert_matrix_equal

. program define assert_matrix_equal
  1.     args mat1 mat2 tol testname
  2. 
.     if "`tol'" == "" local tol = 1e-6
  3. 
.     global TESTS_TOTAL = $TESTS_TOTAL + 1
  4. 
.     tempname diff
  5.     matrix `diff' = `mat1' - `mat2'
  6.     local maxdiff = 0
  7.     local rows = rowsof(`diff')
  8.     local cols = colsof(`diff')
  9.     forvalues i = 1/`rows' {
 10.         forvalues j = 1/`cols' {
 11.             local d = abs(`diff'[`i', `j'])
 12.             if `d' > `maxdiff' local maxdiff = `d'
 13.         }
 14.     }
 15. 
.     if `maxdiff' < `tol' {
 16.         global TESTS_PASSED = $TESTS_PASSED + 1
 17.         di as result "  PASS: `testname' (max diff = " %12.2e `maxdiff' ")
> "
 18.     }
 19.     else {
 20.         global TESTS_FAILED = $TESTS_FAILED + 1
 21.         di as error "  FAIL: `testname' (max diff = " %12.2e `maxdiff' ")"
 22.     }
 23. end

. 
. * Helper program to compare variables
. capture program drop assert_var_equal

. program define assert_var_equal
  1.     args var1 var2 tol testname
  2. 
.     if "`tol'" == "" local tol = 1e-10
  3. 
.     global TESTS_TOTAL = $TESTS_TOTAL + 1
  4. 
.     quietly count if abs(`var1' - `var2') > `tol'
  5.     local ndiff = r(N)
  6. 
.     if `ndiff' == 0 {
  7.         global TESTS_PASSED = $TESTS_PASSED + 1
  8.         di as result "  PASS: `testname' (all values match)"
  9.     }
 10.     else {
 11.         global TESTS_FAILED = $TESTS_FAILED + 1
 12.         di as error "  FAIL: `testname' (`ndiff' values differ)"
 13.     }
 14. end

. 
. * Helper program to compare string variables
. capture program drop assert_strvar_equal

. program define assert_strvar_equal
  1.     args var1 var2 testname
  2. 
.     global TESTS_TOTAL = $TESTS_TOTAL + 1
  3. 
.     quietly count if `var1' != `var2'
  4.     local ndiff = r(N)
  5. 
.     if `ndiff' == 0 {
  6.         global TESTS_PASSED = $TESTS_PASSED + 1
  7.         di as result "  PASS: `testname' (all values match)"
  8.     }
  9.     else {
 10.         global TESTS_FAILED = $TESTS_FAILED + 1
 11.         di as error "  FAIL: `testname' (`ndiff' values differ)"
 12.     }
 13. end

. 
. * Helper to check if two datasets are identical
. capture program drop assert_data_equal

. program define assert_data_equal
  1.     args file1 file2 testname
  2. 
.     global TESTS_TOTAL = $TESTS_TOTAL + 1
  3. 
.     preserve
  4.     quietly {
  5.         use "`file1'", clear
  6.         cf _all using "`file2'"
  7.     }
  8.     local rc = _rc
  9.     restore
 10. 
.     if `rc' == 0 {
 11.         global TESTS_PASSED = $TESTS_PASSED + 1
 12.         di as result "  PASS: `testname' (datasets identical)"
 13.     }
 14.     else {
 15.         global TESTS_FAILED = $TESTS_FAILED + 1
 16.         di as error "  FAIL: `testname' (datasets differ)"
 17.     }
 18. end

. 
. * Helper program to print section header
. capture program drop print_section

. program define print_section
  1.     args title
  2.     di as text ""
  3.     di as text "{hline 70}"
  4.     di as text "`title'"
  5.     di as text "{hline 70}"
  6. end

. 
. * Helper program to print test summary
. capture program drop print_summary

. program define print_summary
  1.     args component
  2.     di as text ""
  3.     di as text "{hline 70}"
  4.     di as text "SUMMARY: `component'"
  5.     di as text "{hline 70}"
  6.     di as text "Tests passed: " as result $TESTS_PASSED
  7.     di as text "Tests failed: " as result $TESTS_FAILED
  8.     di as text "Total tests:  " as result $TESTS_TOTAL
  9.     if $TESTS_FAILED > 0 {
 10.         di as error "VALIDATION FAILED"
 11.     }
 12.     else {
 13.         di as result "ALL TESTS PASSED"
 14.     }
 15.     di as text "{hline 70}"
 16. end

. 
. * Create temp directory for test files
. capture mkdir "validation/temp"

. 
. di as text ""


. di as text "ctools validation framework loaded"
ctools validation framework loaded

. di as text ""


. 
end of do-file

. 
. * Tolerance for floating-point comparisons
. global FP_TOL = 1e-6

. 
. di as text ""


. di as text "=================================================================
> ====="
======================================================================

. di as text "              CREGHDFE VALIDATION TEST SUITE"
              CREGHDFE VALIDATION TEST SUITE

. di as text "=================================================================
> ====="
======================================================================

. di as text "Floating-point tolerance: $FP_TOL"
Floating-point tolerance: 1.00000000000e-06

. 
. /****************************************************************************
> ***
>  * TEST 1: Basic single FE regression (auto dataset)
>  ****************************************************************************
> **/
. print_section "Test 1: Basic single FE regression"

----------------------------------------------------------------------
Test 1: Basic single FE regression
----------------------------------------------------------------------

. 
. sysuse auto, clear
(1978 automobile data)

. 
. * reghdfe
. quietly reghdfe price mpg weight, absorb(foreign)

. local reghdfe_b_mpg = _b[mpg]

. local reghdfe_b_weight = _b[weight]

. local reghdfe_se_mpg = _se[mpg]

. local reghdfe_se_weight = _se[weight]

. local reghdfe_N = e(N)

. local reghdfe_r2 = e(r2)

. 
. * creghdfe
. quietly creghdfe price mpg weight, absorb(foreign)

. local creghdfe_b_mpg = _b[mpg]

. local creghdfe_b_weight = _b[weight]

. local creghdfe_se_mpg = _se[mpg]

. local creghdfe_se_weight = _se[weight]

. local creghdfe_N = e(N)

. local creghdfe_r2 = e(r2)

. 
. * Compare coefficients
. assert_scalar_equal "b[mpg]" `reghdfe_b_mpg' `creghdfe_b_mpg' $FP_TOL "Single
>  FE: mpg coefficient"
  PASS: Single FE: mpg coefficient (b[mpg] diff =     3.20e-14)

. assert_scalar_equal "b[weight]" `reghdfe_b_weight' `creghdfe_b_weight' $FP_TO
> L "Single FE: weight coefficient"
  PASS: Single FE: weight coefficient (b[weight] diff =     8.88e-16)

. assert_scalar_equal "se[mpg]" `reghdfe_se_mpg' `creghdfe_se_mpg' $FP_TOL "Sin
> gle FE: mpg SE"
  PASS: Single FE: mpg SE (se[mpg] diff =     4.26e-14)

. assert_scalar_equal "se[weight]" `reghdfe_se_weight' `creghdfe_se_weight' $FP
> _TOL "Single FE: weight SE"
  PASS: Single FE: weight SE (se[weight] diff =     2.22e-16)

. assert_scalar_equal "N" `reghdfe_N' `creghdfe_N' 0 "Single FE: N"
  PASS: Single FE: N (N diff =     0.00e+00)

. 
. /****************************************************************************
> ***
>  * TEST 2: Two-way fixed effects
>  ****************************************************************************
> **/
. print_section "Test 2: Two-way fixed effects"

----------------------------------------------------------------------
Test 2: Two-way fixed effects
----------------------------------------------------------------------

. 
. sysuse auto, clear
(1978 automobile data)

. 
. * reghdfe
. quietly reghdfe price mpg weight, absorb(foreign rep78)

. local reghdfe_b_mpg = _b[mpg]

. local reghdfe_b_weight = _b[weight]

. local reghdfe_se_mpg = _se[mpg]

. local reghdfe_N = e(N)

. 
. * creghdfe
. quietly creghdfe price mpg weight, absorb(foreign rep78)

. local creghdfe_b_mpg = _b[mpg]

. local creghdfe_b_weight = _b[weight]

. local creghdfe_se_mpg = _se[mpg]

. local creghdfe_N = e(N)

. 
. assert_scalar_equal "b[mpg]" `reghdfe_b_mpg' `creghdfe_b_mpg' $FP_TOL "Two-wa
> y FE: mpg coefficient"
  PASS: Two-way FE: mpg coefficient (b[mpg] diff =     4.90e-13)

. assert_scalar_equal "b[weight]" `reghdfe_b_weight' `creghdfe_b_weight' $FP_TO
> L "Two-way FE: weight coefficient"
  PASS: Two-way FE: weight coefficient (b[weight] diff =     8.88e-15)

. assert_scalar_equal "se[mpg]" `reghdfe_se_mpg' `creghdfe_se_mpg' $FP_TOL "Two
> -way FE: mpg SE"
  PASS: Two-way FE: mpg SE (se[mpg] diff =     2.27e-13)

. assert_scalar_equal "N" `reghdfe_N' `creghdfe_N' 0 "Two-way FE: N"
  PASS: Two-way FE: N (N diff =     0.00e+00)

. 
. /****************************************************************************
> ***
>  * TEST 3: Robust VCE
>  ****************************************************************************
> **/
. print_section "Test 3: Robust VCE"

----------------------------------------------------------------------
Test 3: Robust VCE
----------------------------------------------------------------------

. 
. sysuse auto, clear
(1978 automobile data)

. 
. * reghdfe
. quietly reghdfe price mpg weight, absorb(foreign) vce(robust)

. local reghdfe_b_mpg = _b[mpg]

. local reghdfe_se_mpg = _se[mpg]

. local reghdfe_se_weight = _se[weight]

. 
. * creghdfe
. quietly creghdfe price mpg weight, absorb(foreign) vce(robust)

. local creghdfe_b_mpg = _b[mpg]

. local creghdfe_se_mpg = _se[mpg]

. local creghdfe_se_weight = _se[weight]

. 
. assert_scalar_equal "b[mpg]" `reghdfe_b_mpg' `creghdfe_b_mpg' $FP_TOL "Robust
>  VCE: mpg coefficient"
  PASS: Robust VCE: mpg coefficient (b[mpg] diff =     3.20e-14)

. assert_scalar_equal "se[mpg]" `reghdfe_se_mpg' `creghdfe_se_mpg' $FP_TOL "Rob
> ust VCE: mpg SE"
  PASS: Robust VCE: mpg SE (se[mpg] diff =     5.22e-12)

. assert_scalar_equal "se[weight]" `reghdfe_se_weight' `creghdfe_se_weight' $FP
> _TOL "Robust VCE: weight SE"
  PASS: Robust VCE: weight SE (se[weight] diff =     4.10e-14)

. 
. /****************************************************************************
> ***
>  * TEST 4: Cluster VCE
>  ****************************************************************************
> **/
. print_section "Test 4: Cluster VCE"

----------------------------------------------------------------------
Test 4: Cluster VCE
----------------------------------------------------------------------

. 
. sysuse auto, clear
(1978 automobile data)

. 
. * reghdfe
. quietly reghdfe price mpg weight, absorb(foreign) vce(cluster foreign)

. local reghdfe_b_mpg = _b[mpg]

. local reghdfe_se_mpg = _se[mpg]

. local reghdfe_N_clust = e(N_clust)

. 
. * creghdfe
. quietly creghdfe price mpg weight, absorb(foreign) vce(cluster foreign)

. local creghdfe_b_mpg = _b[mpg]

. local creghdfe_se_mpg = _se[mpg]

. local creghdfe_N_clust = e(N_clust)

. 
. assert_scalar_equal "b[mpg]" `reghdfe_b_mpg' `creghdfe_b_mpg' $FP_TOL "Cluste
> r VCE: mpg coefficient"
  PASS: Cluster VCE: mpg coefficient (b[mpg] diff =     3.20e-14)

. assert_scalar_equal "se[mpg]" `reghdfe_se_mpg' `creghdfe_se_mpg' $FP_TOL "Clu
> ster VCE: mpg SE"
  PASS: Cluster VCE: mpg SE (se[mpg] diff =     2.84e-13)

. assert_scalar_equal "N_clust" `reghdfe_N_clust' `creghdfe_N_clust' 0 "Cluster
>  VCE: N_clust"
  PASS: Cluster VCE: N_clust (N_clust diff =     0.00e+00)

. 
. /****************************************************************************
> ***
>  * TEST 5: Analytic weights (aweight)
>  ****************************************************************************
> **/
. print_section "Test 5: Analytic weights (aweight)"

----------------------------------------------------------------------
Test 5: Analytic weights (aweight)
----------------------------------------------------------------------

. 
. sysuse auto, clear
(1978 automobile data)

. gen w = rep78
(5 missing values generated)

. replace w = 3 if missing(w)
(5 real changes made)

. 
. * reghdfe
. quietly reghdfe price mpg weight [aw=w], absorb(foreign)

. local reghdfe_b_mpg = _b[mpg]

. local reghdfe_se_mpg = _se[mpg]

. 
. * creghdfe
. quietly creghdfe price mpg weight [aw=w], absorb(foreign)

. local creghdfe_b_mpg = _b[mpg]

. local creghdfe_se_mpg = _se[mpg]

. 
. assert_scalar_equal "b[mpg]" `reghdfe_b_mpg' `creghdfe_b_mpg' $FP_TOL "aweigh
> t: mpg coefficient"
  PASS: aweight: mpg coefficient (b[mpg] diff =     4.97e-14)

. assert_scalar_equal "se[mpg]" `reghdfe_se_mpg' `creghdfe_se_mpg' $FP_TOL "awe
> ight: mpg SE"
  PASS: aweight: mpg SE (se[mpg] diff =     1.42e-14)

. 
. /****************************************************************************
> ***
>  * TEST 6: Frequency weights (fweight)
>  ****************************************************************************
> **/
. print_section "Test 6: Frequency weights (fweight)"

----------------------------------------------------------------------
Test 6: Frequency weights (fweight)
----------------------------------------------------------------------

. 
. sysuse auto, clear
(1978 automobile data)

. drop if missing(rep78)
(5 observations deleted)

. 
. * reghdfe
. quietly reghdfe price mpg weight [fw=rep78], absorb(foreign)

. local reghdfe_b_mpg = _b[mpg]

. local reghdfe_se_mpg = _se[mpg]

. local reghdfe_N = e(N)

. 
. * creghdfe
. quietly creghdfe price mpg weight [fw=rep78], absorb(foreign)

. local creghdfe_b_mpg = _b[mpg]

. local creghdfe_se_mpg = _se[mpg]

. local creghdfe_N = e(N)

. 
. assert_scalar_equal "b[mpg]" `reghdfe_b_mpg' `creghdfe_b_mpg' $FP_TOL "fweigh
> t: mpg coefficient"
  PASS: fweight: mpg coefficient (b[mpg] diff =     7.90e-13)

. assert_scalar_equal "se[mpg]" `reghdfe_se_mpg' `creghdfe_se_mpg' $FP_TOL "fwe
> ight: mpg SE"
  PASS: fweight: mpg SE (se[mpg] diff =     1.42e-14)

. * Note: N differs between reghdfe (sum of weights) and creghdfe (obs count) -
>  skip comparison
. di as text "  INFO: fweight N - reghdfe=`reghdfe_N' (sum weights), creghdfe=`
> creghdfe_N' (obs count)"
  INFO: fweight N - reghdfe=235 (sum weights), creghdfe=69 (obs count)

. 
. /****************************************************************************
> ***
>  * TEST 7: Probability weights (pweight) - forces robust
>  ****************************************************************************
> **/
. print_section "Test 7: Probability weights (pweight)"

----------------------------------------------------------------------
Test 7: Probability weights (pweight)
----------------------------------------------------------------------

. 
. sysuse auto, clear
(1978 automobile data)

. gen w = rep78
(5 missing values generated)

. replace w = 3 if missing(w)
(5 real changes made)

. 
. * reghdfe (pweight forces robust)
. quietly reghdfe price mpg weight [pw=w], absorb(foreign)

. local reghdfe_b_mpg = _b[mpg]

. local reghdfe_se_mpg = _se[mpg]

. 
. * creghdfe
. quietly creghdfe price mpg weight [pw=w], absorb(foreign)

. local creghdfe_b_mpg = _b[mpg]

. local creghdfe_se_mpg = _se[mpg]

. 
. assert_scalar_equal "b[mpg]" `reghdfe_b_mpg' `creghdfe_b_mpg' $FP_TOL "pweigh
> t: mpg coefficient"
  PASS: pweight: mpg coefficient (b[mpg] diff =     4.97e-14)

. assert_scalar_equal "se[mpg]" `reghdfe_se_mpg' `creghdfe_se_mpg' $FP_TOL "pwe
> ight: mpg SE"
  PASS: pweight: mpg SE (se[mpg] diff =     9.09e-13)

. 
. /****************************************************************************
> ***
>  * TEST 8: aweight with robust VCE
>  ****************************************************************************
> **/
. print_section "Test 8: aweight with robust VCE"

----------------------------------------------------------------------
Test 8: aweight with robust VCE
----------------------------------------------------------------------

. 
. sysuse auto, clear
(1978 automobile data)

. gen w = rep78
(5 missing values generated)

. replace w = 3 if missing(w)
(5 real changes made)

. 
. * reghdfe
. quietly reghdfe price mpg weight [aw=w], absorb(foreign) vce(robust)

. local reghdfe_b_mpg = _b[mpg]

. local reghdfe_se_mpg = _se[mpg]

. 
. * creghdfe
. quietly creghdfe price mpg weight [aw=w], absorb(foreign) vce(robust)

. local creghdfe_b_mpg = _b[mpg]

. local creghdfe_se_mpg = _se[mpg]

. 
. assert_scalar_equal "b[mpg]" `reghdfe_b_mpg' `creghdfe_b_mpg' $FP_TOL "aweigh
> t+robust: mpg coefficient"
  PASS: aweight+robust: mpg coefficient (b[mpg] diff =     4.97e-14)

. assert_scalar_equal "se[mpg]" `reghdfe_se_mpg' `creghdfe_se_mpg' $FP_TOL "awe
> ight+robust: mpg SE"
  PASS: aweight+robust: mpg SE (se[mpg] diff =     9.09e-13)

. 
. /****************************************************************************
> ***
>  * TEST 9: aweight with cluster VCE
>  ****************************************************************************
> **/
. print_section "Test 9: aweight with cluster VCE"

----------------------------------------------------------------------
Test 9: aweight with cluster VCE
----------------------------------------------------------------------

. 
. sysuse auto, clear
(1978 automobile data)

. gen w = rep78
(5 missing values generated)

. replace w = 3 if missing(w)
(5 real changes made)

. 
. * reghdfe
. quietly reghdfe price mpg weight [aw=w], absorb(foreign) vce(cluster foreign)

. local reghdfe_b_mpg = _b[mpg]

. local reghdfe_se_mpg = _se[mpg]

. 
. * creghdfe
. quietly creghdfe price mpg weight [aw=w], absorb(foreign) vce(cluster foreign
> )

. local creghdfe_b_mpg = _b[mpg]

. local creghdfe_se_mpg = _se[mpg]

. 
. assert_scalar_equal "b[mpg]" `reghdfe_b_mpg' `creghdfe_b_mpg' $FP_TOL "aweigh
> t+cluster: mpg coefficient"
  PASS: aweight+cluster: mpg coefficient (b[mpg] diff =     4.97e-14)

. assert_scalar_equal "se[mpg]" `reghdfe_se_mpg' `creghdfe_se_mpg' $FP_TOL "awe
> ight+cluster: mpg SE"
  PASS: aweight+cluster: mpg SE (se[mpg] diff =     1.99e-13)

. 
. /****************************************************************************
> ***
>  * TEST 10: nlswork panel data - individual FE
>  ****************************************************************************
> **/
. print_section "Test 10: nlswork panel data - individual FE"

----------------------------------------------------------------------
Test 10: nlswork panel data - individual FE
----------------------------------------------------------------------

. 
. webuse nlswork, clear
(National Longitudinal Survey of Young Women, 14-24 years old in 1968)

. keep in 1/5000
(23,534 observations deleted)

. 
. * reghdfe
. quietly reghdfe ln_wage age ttl_exp tenure, absorb(idcode)

. local reghdfe_b_age = _b[age]

. local reghdfe_b_ttl_exp = _b[ttl_exp]

. local reghdfe_se_age = _se[age]

. local reghdfe_N = e(N)

. 
. * creghdfe
. quietly creghdfe ln_wage age ttl_exp tenure, absorb(idcode)

. local creghdfe_b_age = _b[age]

. local creghdfe_b_ttl_exp = _b[ttl_exp]

. local creghdfe_se_age = _se[age]

. local creghdfe_N = e(N)

. 
. assert_scalar_equal "b[age]" `reghdfe_b_age' `creghdfe_b_age' $FP_TOL "nlswor
> k FE: age coefficient"
  PASS: nlswork FE: age coefficient (b[age] diff =     1.01e-16)

. assert_scalar_equal "b[ttl_exp]" `reghdfe_b_ttl_exp' `creghdfe_b_ttl_exp' $FP
> _TOL "nlswork FE: ttl_exp coefficient"
  PASS: nlswork FE: ttl_exp coefficient (b[ttl_exp] diff =     9.71e-17)

. assert_scalar_equal "se[age]" `reghdfe_se_age' `creghdfe_se_age' $FP_TOL "nls
> work FE: age SE"
  PASS: nlswork FE: age SE (se[age] diff =     0.00e+00)

. assert_scalar_equal "N" `reghdfe_N' `creghdfe_N' 0 "nlswork FE: N"
  PASS: nlswork FE: N (N diff =     0.00e+00)

. 
. /****************************************************************************
> ***
>  * TEST 11: nlswork - two-way FE (individual + year)
>  ****************************************************************************
> **/
. print_section "Test 11: nlswork - two-way FE (individual + year)"

----------------------------------------------------------------------
Test 11: nlswork - two-way FE (individual + year)
----------------------------------------------------------------------

. 
. webuse nlswork, clear
(National Longitudinal Survey of Young Women, 14-24 years old in 1968)

. keep in 1/5000
(23,534 observations deleted)

. 
. * reghdfe
. quietly reghdfe ln_wage age ttl_exp tenure, absorb(idcode year)

. local reghdfe_b_age = _b[age]

. local reghdfe_se_age = _se[age]

. local reghdfe_N = e(N)

. 
. * creghdfe
. quietly creghdfe ln_wage age ttl_exp tenure, absorb(idcode year)

. local creghdfe_b_age = _b[age]

. local creghdfe_se_age = _se[age]

. local creghdfe_N = e(N)

. 
. assert_scalar_equal "b[age]" `reghdfe_b_age' `creghdfe_b_age' $FP_TOL "Two-wa
> y panel FE: age coefficient"
  PASS: Two-way panel FE: age coefficient (b[age] diff =     4.20e-15)

. assert_scalar_equal "se[age]" `reghdfe_se_age' `creghdfe_se_age' $FP_TOL "Two
> -way panel FE: age SE"
  PASS: Two-way panel FE: age SE (se[age] diff =     0.00e+00)

. assert_scalar_equal "N" `reghdfe_N' `creghdfe_N' 0 "Two-way panel FE: N"
  PASS: Two-way panel FE: N (N diff =     0.00e+00)

. 
. /****************************************************************************
> ***
>  * TEST 12: nlswork - cluster on individual
>  ****************************************************************************
> **/
. print_section "Test 12: nlswork - cluster on individual"

----------------------------------------------------------------------
Test 12: nlswork - cluster on individual
----------------------------------------------------------------------

. 
. webuse nlswork, clear
(National Longitudinal Survey of Young Women, 14-24 years old in 1968)

. keep in 1/5000
(23,534 observations deleted)

. 
. * reghdfe
. quietly reghdfe ln_wage age ttl_exp tenure, absorb(idcode year) vce(cluster i
> dcode)

. local reghdfe_b_age = _b[age]

. local reghdfe_se_age = _se[age]

. local reghdfe_N_clust = e(N_clust)

. 
. * creghdfe
. quietly creghdfe ln_wage age ttl_exp tenure, absorb(idcode year) vce(cluster 
> idcode)

. local creghdfe_b_age = _b[age]

. local creghdfe_se_age = _se[age]

. local creghdfe_N_clust = e(N_clust)

. 
. assert_scalar_equal "b[age]" `reghdfe_b_age' `creghdfe_b_age' $FP_TOL "Panel 
> cluster: age coefficient"
  PASS: Panel cluster: age coefficient (b[age] diff =     4.20e-15)

. assert_scalar_equal "se[age]" `reghdfe_se_age' `creghdfe_se_age' $FP_TOL "Pan
> el cluster: age SE"
  PASS: Panel cluster: age SE (se[age] diff =     1.47e-14)

. assert_scalar_equal "N_clust" `reghdfe_N_clust' `creghdfe_N_clust' 0 "Panel c
> luster: N_clust"
  PASS: Panel cluster: N_clust (N_clust diff =     0.00e+00)

. 
. /****************************************************************************
> ***
>  * TEST 13: Census dataset - state FE
>  ****************************************************************************
> **/
. print_section "Test 13: Census dataset - region FE"

----------------------------------------------------------------------
Test 13: Census dataset - region FE
----------------------------------------------------------------------

. 
. sysuse census, clear
(1980 Census data by state)

. 
. * reghdfe
. quietly reghdfe pop medage death marriage, absorb(region)

. local reghdfe_b_medage = _b[medage]

. local reghdfe_se_medage = _se[medage]

. 
. * creghdfe
. quietly creghdfe pop medage death marriage, absorb(region)

. local creghdfe_b_medage = _b[medage]

. local creghdfe_se_medage = _se[medage]

. 
. assert_scalar_equal "b[medage]" `reghdfe_b_medage' `creghdfe_b_medage' $FP_TO
> L "Census region FE: medage coefficient"
  PASS: Census region FE: medage coefficient (b[medage] diff =     8.73e-11)

. assert_scalar_equal "se[medage]" `reghdfe_se_medage' `creghdfe_se_medage' $FP
> _TOL "Census region FE: medage SE"
  PASS: Census region FE: medage SE (se[medage] diff =     2.17e-09)

. 
. /****************************************************************************
> ***
>  * TEST 14: Many covariates
>  ****************************************************************************
> **/
. print_section "Test 14: Many covariates"

----------------------------------------------------------------------
Test 14: Many covariates
----------------------------------------------------------------------

. 
. sysuse auto, clear
(1978 automobile data)

. 
. * reghdfe with multiple covariates
. quietly reghdfe price mpg weight length turn displacement, absorb(foreign)

. local reghdfe_b_mpg = _b[mpg]

. local reghdfe_b_length = _b[length]

. local reghdfe_se_mpg = _se[mpg]

. 
. * creghdfe
. quietly creghdfe price mpg weight length turn displacement, absorb(foreign)

. local creghdfe_b_mpg = _b[mpg]

. local creghdfe_b_length = _b[length]

. local creghdfe_se_mpg = _se[mpg]

. 
. assert_scalar_equal "b[mpg]" `reghdfe_b_mpg' `creghdfe_b_mpg' $FP_TOL "Many c
> ovariates: mpg coefficient"
  PASS: Many covariates: mpg coefficient (b[mpg] diff =     1.31e-13)

. assert_scalar_equal "b[length]" `reghdfe_b_length' `creghdfe_b_length' $FP_TO
> L "Many covariates: length coefficient"
  PASS: Many covariates: length coefficient (b[length] diff =     1.28e-13)

. assert_scalar_equal "se[mpg]" `reghdfe_se_mpg' `creghdfe_se_mpg' $FP_TOL "Man
> y covariates: mpg SE"
  PASS: Many covariates: mpg SE (se[mpg] diff =     2.84e-14)

. 
. /****************************************************************************
> ***
>  * TEST 15: Single covariate
>  ****************************************************************************
> **/
. print_section "Test 15: Single covariate"

----------------------------------------------------------------------
Test 15: Single covariate
----------------------------------------------------------------------

. 
. sysuse auto, clear
(1978 automobile data)

. 
. * reghdfe
. quietly reghdfe price mpg, absorb(foreign)

. local reghdfe_b_mpg = _b[mpg]

. local reghdfe_se_mpg = _se[mpg]

. 
. * creghdfe
. quietly creghdfe price mpg, absorb(foreign)

. local creghdfe_b_mpg = _b[mpg]

. local creghdfe_se_mpg = _se[mpg]

. 
. assert_scalar_equal "b[mpg]" `reghdfe_b_mpg' `creghdfe_b_mpg' $FP_TOL "Single
>  covariate: mpg coefficient"
  PASS: Single covariate: mpg coefficient (b[mpg] diff =     1.14e-13)

. assert_scalar_equal "se[mpg]" `reghdfe_se_mpg' `creghdfe_se_mpg' $FP_TOL "Sin
> gle covariate: mpg SE"
  PASS: Single covariate: mpg SE (se[mpg] diff =     2.13e-14)

. 
. /****************************************************************************
> ***
>  * TEST 16: Stored results - e(b) and e(V)
>  ****************************************************************************
> **/
. print_section "Test 16: Stored results - e(b) and e(V)"

----------------------------------------------------------------------
Test 16: Stored results - e(b) and e(V)
----------------------------------------------------------------------

. 
. sysuse auto, clear
(1978 automobile data)

. 
. * reghdfe
. quietly reghdfe price mpg weight, absorb(foreign)

. matrix reghdfe_b = e(b)

. matrix reghdfe_V = e(V)

. 
. * creghdfe
. quietly creghdfe price mpg weight, absorb(foreign)

. matrix creghdfe_b = e(b)

. matrix creghdfe_V = e(V)

. 
. * Compare coefficient vector
. assert_matrix_equal reghdfe_b creghdfe_b $FP_TOL "e(b) coefficient vector"
  PASS: e(b) coefficient vector (max diff =     2.73e-12)

. 
. * Compare variance matrix
. assert_matrix_equal reghdfe_V creghdfe_V $FP_TOL "e(V) variance matrix"
  PASS: e(V) variance matrix (max diff =     1.30e-08)

. 
. /****************************************************************************
> ***
>  * TEST 17: Larger synthetic dataset
>  ****************************************************************************
> **/
. print_section "Test 17: Larger synthetic dataset (20K obs)"

----------------------------------------------------------------------
Test 17: Larger synthetic dataset (20K obs)
----------------------------------------------------------------------

. 
. clear

. set seed 98765

. set obs 20000
Number of observations (_N) was 0, now 20,000.

. gen firm = runiformint(1, 500)

. gen year = runiformint(2000, 2020)

. gen x1 = rnormal()

. gen x2 = rnormal() * 2

. gen y = 1 + 0.5*x1 - 0.3*x2 + rnormal() * 0.5

. 
. * reghdfe
. quietly reghdfe y x1 x2, absorb(firm year)

. local reghdfe_b_x1 = _b[x1]

. local reghdfe_b_x2 = _b[x2]

. local reghdfe_se_x1 = _se[x1]

. local reghdfe_N = e(N)

. 
. * creghdfe
. quietly creghdfe y x1 x2, absorb(firm year)

. local creghdfe_b_x1 = _b[x1]

. local creghdfe_b_x2 = _b[x2]

. local creghdfe_se_x1 = _se[x1]

. local creghdfe_N = e(N)

. 
. assert_scalar_equal "b[x1]" `reghdfe_b_x1' `creghdfe_b_x1' $FP_TOL "Synthetic
> : x1 coefficient"
  PASS: Synthetic: x1 coefficient (b[x1] diff =     5.44e-15)

. assert_scalar_equal "b[x2]" `reghdfe_b_x2' `creghdfe_b_x2' $FP_TOL "Synthetic
> : x2 coefficient"
  PASS: Synthetic: x2 coefficient (b[x2] diff =     1.28e-15)

. assert_scalar_equal "se[x1]" `reghdfe_se_x1' `creghdfe_se_x1' $FP_TOL "Synthe
> tic: x1 SE"
  PASS: Synthetic: x1 SE (se[x1] diff =     0.00e+00)

. assert_scalar_equal "N" `reghdfe_N' `creghdfe_N' 0 "Synthetic: N"
  PASS: Synthetic: N (N diff =     0.00e+00)

. 
. /****************************************************************************
> ***
>  * TEST 18: Degrees of freedom
>  ****************************************************************************
> **/
. print_section "Test 18: Degrees of freedom"

----------------------------------------------------------------------
Test 18: Degrees of freedom
----------------------------------------------------------------------

. 
. sysuse auto, clear
(1978 automobile data)

. 
. * reghdfe
. quietly reghdfe price mpg weight, absorb(foreign rep78)

. local reghdfe_df_r = e(df_r)

. local reghdfe_df_a = e(df_a)

. 
. * creghdfe
. quietly creghdfe price mpg weight, absorb(foreign rep78)

. local creghdfe_df_r = e(df_r)

. local creghdfe_df_a = e(df_a)

. 
. assert_scalar_equal "df_r" `reghdfe_df_r' `creghdfe_df_r' 0 "Degrees of freed
> om: df_r"
  PASS: Degrees of freedom: df_r (df_r diff =     0.00e+00)

. assert_scalar_equal "df_a" `reghdfe_df_a' `creghdfe_df_a' 0 "Degrees of freed
> om: df_a"
  PASS: Degrees of freedom: df_a (df_a diff =     0.00e+00)

. 
. /****************************************************************************
> ***
>  * TEST 19: High-dimensional FE with many levels
>  ****************************************************************************
> **/
. print_section "Test 19: High-dimensional FE (many levels)"

----------------------------------------------------------------------
Test 19: High-dimensional FE (many levels)
----------------------------------------------------------------------

. 
. webuse nlswork, clear
(National Longitudinal Survey of Young Women, 14-24 years old in 1968)

. keep in 1/10000
(18,534 observations deleted)

. 
. * reghdfe with many FE levels
. quietly reghdfe ln_wage age ttl_exp, absorb(idcode)

. local reghdfe_b_age = _b[age]

. local reghdfe_se_age = _se[age]

. local reghdfe_df_a = e(df_a)

. 
. * creghdfe
. quietly creghdfe ln_wage age ttl_exp, absorb(idcode)

. local creghdfe_b_age = _b[age]

. local creghdfe_se_age = _se[age]

. local creghdfe_df_a = e(df_a)

. 
. assert_scalar_equal "b[age]" `reghdfe_b_age' `creghdfe_b_age' $FP_TOL "High-d
> im FE: age coefficient"
  PASS: High-dim FE: age coefficient (b[age] diff =     3.00e-16)

. assert_scalar_equal "se[age]" `reghdfe_se_age' `creghdfe_se_age' $FP_TOL "Hig
> h-dim FE: age SE"
  PASS: High-dim FE: age SE (se[age] diff =     0.00e+00)

. assert_scalar_equal "df_a" `reghdfe_df_a' `creghdfe_df_a' 0 "High-dim FE: df_
> a"
  PASS: High-dim FE: df_a (df_a diff =     0.00e+00)

. 
. /****************************************************************************
> ***
>  * TEST 20: weights=1 should match unweighted
>  ****************************************************************************
> **/
. print_section "Test 20: weights=1 should match unweighted"

----------------------------------------------------------------------
Test 20: weights=1 should match unweighted
----------------------------------------------------------------------

. 
. sysuse auto, clear
(1978 automobile data)

. gen w1 = 1

. 
. * Unweighted
. quietly creghdfe price mpg weight, absorb(foreign)

. local unweighted_b = _b[mpg]

. local unweighted_se = _se[mpg]

. 
. * Weighted with w=1
. quietly creghdfe price mpg weight [aw=w1], absorb(foreign)

. local weighted1_b = _b[mpg]

. local weighted1_se = _se[mpg]

. 
. assert_scalar_equal "b[mpg]" `unweighted_b' `weighted1_b' $FP_TOL "weights=1:
>  coefficient matches unweighted"
  PASS: weights=1: coefficient matches unweighted (b[mpg] diff =     1.10e-13)

. assert_scalar_equal "se[mpg]" `unweighted_se' `weighted1_se' $FP_TOL "weights
> =1: SE matches unweighted"
  PASS: weights=1: SE matches unweighted (se[mpg] diff =     1.42e-14)

. 
. /****************************************************************************
> ***
>  * SUMMARY
>  ****************************************************************************
> **/
. print_summary "creghdfe"

----------------------------------------------------------------------
SUMMARY: creghdfe
----------------------------------------------------------------------
Tests passed: 55
Tests failed: 0
Total tests:  55
ALL TESTS PASSED
----------------------------------------------------------------------

. 
. * Return error code if any tests failed
. if $TESTS_FAILED > 0 {
.     exit 1
. }

. 
end of do-file

. local creghdfe_rc = _rc

. 
. if `creghdfe_rc' == 0 {
.     di as result "creghdfe: ALL TESTS PASSED"
creghdfe: ALL TESTS PASSED
. }

. else {
.     di as error "creghdfe: SOME TESTS FAILED"
. }

. 
. local total_passed = `total_passed' + $TESTS_PASSED

. local total_failed = `total_failed' + $TESTS_FAILED

. local total_tests = `total_tests' + $TESTS_TOTAL

. 
. local creghdfe_passed = $TESTS_PASSED

. local creghdfe_failed = $TESTS_FAILED

. local creghdfe_total = $TESTS_TOTAL

. 
. /****************************************************************************
> ***
>  * RUN CQREG VALIDATION
>  ****************************************************************************
> **/
. di as text ""


. di as text "=================================================================
> ====="
======================================================================

. di as text "  Running: cqreg validation tests"
  Running: cqreg validation tests

. di as text "=================================================================
> ====="
======================================================================

. 
. capture noisily do "validation/validate_cqreg.do"

. /****************************************************************************
> ***
>  * validate_cqreg.do
>  *
>  * Comprehensive validation tests for cqreg vs qreg
>  * Tests quantile regression across various scenarios
>  *
>  * Note: Coefficients and standard errors are compared with tolerance 1e-6
>  * due to floating-point precision differences in complex optimization
>  ****************************************************************************
> **/
. 
. do "validation/validate_setup.do"

. /****************************************************************************
> ***
>  * validate_setup.do
>  *
>  * Setup and helper programs for ctools validation test suite
>  * This file is included by all individual validation tests
>  ****************************************************************************
> **/
. 
. version 14.0

. clear all

. set more off

. set trace off

. 
. * Load ctools from build directory
. adopath + "build"
  [1]  (BASE)      "/Applications/Stata/ado/base/"
  [2]  (SITE)      "/Applications/Stata/ado/site/"
  [3]              "."
  [4]  (PERSONAL)  "/Users/Mike/Documents/Stata/ado/personal/"
  [5]  (PLUS)      "/Users/Mike/Library/Application Support/Stata/ado/plus/"
  [6]  (OLDPLACE)  "~/ado/"
  [7]              "build"

. cap program drop ctools_plugin

. program ctools_plugin, plugin using("build/ctools_mac_arm.plugin")

. 
. * Global counters
. global TESTS_PASSED = 0

. global TESTS_FAILED = 0

. global TESTS_TOTAL = 0

. 
. * Helper program to compare scalars with tolerance
. capture program drop assert_scalar_equal

. program define assert_scalar_equal
  1.     args name val1 val2 tol testname
  2. 
.     if "`tol'" == "" local tol = 1e-6
  3. 
.     global TESTS_TOTAL = $TESTS_TOTAL + 1
  4. 
.     local diff = abs(`val1' - `val2')
  5.     * Handle exact match case (for integers like N)
.     if `diff' == 0 | `diff' < `tol' {
  6.         global TESTS_PASSED = $TESTS_PASSED + 1
  7.         di as result "  PASS: `testname' (`name' diff = " %12.2e `diff' ")
> "
  8.     }
  9.     else {
 10.         global TESTS_FAILED = $TESTS_FAILED + 1
 11.         di as error "  FAIL: `testname' (`name': `val1' vs `val2', diff = 
> " %12.2e `diff' ")"
 12.     }
 13. end

. 
. * Helper program to compare matrices
. capture program drop assert_matrix_equal

. program define assert_matrix_equal
  1.     args mat1 mat2 tol testname
  2. 
.     if "`tol'" == "" local tol = 1e-6
  3. 
.     global TESTS_TOTAL = $TESTS_TOTAL + 1
  4. 
.     tempname diff
  5.     matrix `diff' = `mat1' - `mat2'
  6.     local maxdiff = 0
  7.     local rows = rowsof(`diff')
  8.     local cols = colsof(`diff')
  9.     forvalues i = 1/`rows' {
 10.         forvalues j = 1/`cols' {
 11.             local d = abs(`diff'[`i', `j'])
 12.             if `d' > `maxdiff' local maxdiff = `d'
 13.         }
 14.     }
 15. 
.     if `maxdiff' < `tol' {
 16.         global TESTS_PASSED = $TESTS_PASSED + 1
 17.         di as result "  PASS: `testname' (max diff = " %12.2e `maxdiff' ")
> "
 18.     }
 19.     else {
 20.         global TESTS_FAILED = $TESTS_FAILED + 1
 21.         di as error "  FAIL: `testname' (max diff = " %12.2e `maxdiff' ")"
 22.     }
 23. end

. 
. * Helper program to compare variables
. capture program drop assert_var_equal

. program define assert_var_equal
  1.     args var1 var2 tol testname
  2. 
.     if "`tol'" == "" local tol = 1e-10
  3. 
.     global TESTS_TOTAL = $TESTS_TOTAL + 1
  4. 
.     quietly count if abs(`var1' - `var2') > `tol'
  5.     local ndiff = r(N)
  6. 
.     if `ndiff' == 0 {
  7.         global TESTS_PASSED = $TESTS_PASSED + 1
  8.         di as result "  PASS: `testname' (all values match)"
  9.     }
 10.     else {
 11.         global TESTS_FAILED = $TESTS_FAILED + 1
 12.         di as error "  FAIL: `testname' (`ndiff' values differ)"
 13.     }
 14. end

. 
. * Helper program to compare string variables
. capture program drop assert_strvar_equal

. program define assert_strvar_equal
  1.     args var1 var2 testname
  2. 
.     global TESTS_TOTAL = $TESTS_TOTAL + 1
  3. 
.     quietly count if `var1' != `var2'
  4.     local ndiff = r(N)
  5. 
.     if `ndiff' == 0 {
  6.         global TESTS_PASSED = $TESTS_PASSED + 1
  7.         di as result "  PASS: `testname' (all values match)"
  8.     }
  9.     else {
 10.         global TESTS_FAILED = $TESTS_FAILED + 1
 11.         di as error "  FAIL: `testname' (`ndiff' values differ)"
 12.     }
 13. end

. 
. * Helper to check if two datasets are identical
. capture program drop assert_data_equal

. program define assert_data_equal
  1.     args file1 file2 testname
  2. 
.     global TESTS_TOTAL = $TESTS_TOTAL + 1
  3. 
.     preserve
  4.     quietly {
  5.         use "`file1'", clear
  6.         cf _all using "`file2'"
  7.     }
  8.     local rc = _rc
  9.     restore
 10. 
.     if `rc' == 0 {
 11.         global TESTS_PASSED = $TESTS_PASSED + 1
 12.         di as result "  PASS: `testname' (datasets identical)"
 13.     }
 14.     else {
 15.         global TESTS_FAILED = $TESTS_FAILED + 1
 16.         di as error "  FAIL: `testname' (datasets differ)"
 17.     }
 18. end

. 
. * Helper program to print section header
. capture program drop print_section

. program define print_section
  1.     args title
  2.     di as text ""
  3.     di as text "{hline 70}"
  4.     di as text "`title'"
  5.     di as text "{hline 70}"
  6. end

. 
. * Helper program to print test summary
. capture program drop print_summary

. program define print_summary
  1.     args component
  2.     di as text ""
  3.     di as text "{hline 70}"
  4.     di as text "SUMMARY: `component'"
  5.     di as text "{hline 70}"
  6.     di as text "Tests passed: " as result $TESTS_PASSED
  7.     di as text "Tests failed: " as result $TESTS_FAILED
  8.     di as text "Total tests:  " as result $TESTS_TOTAL
  9.     if $TESTS_FAILED > 0 {
 10.         di as error "VALIDATION FAILED"
 11.     }
 12.     else {
 13.         di as result "ALL TESTS PASSED"
 14.     }
 15.     di as text "{hline 70}"
 16. end

. 
. * Create temp directory for test files
. capture mkdir "validation/temp"

. 
. di as text ""


. di as text "ctools validation framework loaded"
ctools validation framework loaded

. di as text ""


. 
end of do-file

. 
. * Tolerance for floating-point comparisons
. global FP_TOL = 1e-6

. 
. di as text ""


. di as text "=================================================================
> ====="
======================================================================

. di as text "              CQREG VALIDATION TEST SUITE"
              CQREG VALIDATION TEST SUITE

. di as text "=================================================================
> ====="
======================================================================

. di as text "Floating-point tolerance: $FP_TOL"
Floating-point tolerance: 1.00000000000e-06

. 
. /****************************************************************************
> ***
>  * TEST 1: Basic median regression (q=0.5)
>  ****************************************************************************
> **/
. print_section "Test 1: Basic median regression (q=0.5)"

----------------------------------------------------------------------
Test 1: Basic median regression (q=0.5)
----------------------------------------------------------------------

. 
. sysuse auto, clear
(1978 automobile data)

. 
. * qreg
. quietly qreg price mpg weight

. local qreg_b_mpg = _b[mpg]

. local qreg_b_weight = _b[weight]

. local qreg_b_cons = _b[_cons]

. local qreg_se_mpg = _se[mpg]

. local qreg_N = e(N)

. 
. * cqreg
. quietly cqreg price mpg weight

. local cqreg_b_mpg = _b[mpg]

. local cqreg_b_weight = _b[weight]

. local cqreg_b_cons = _b[_cons]

. local cqreg_se_mpg = _se[mpg]

. local cqreg_N = e(N)

. 
. assert_scalar_equal "b[mpg]" `qreg_b_mpg' `cqreg_b_mpg' $FP_TOL "Median: mpg 
> coefficient"
  PASS: Median: mpg coefficient (b[mpg] diff =     4.37e-10)

. assert_scalar_equal "b[weight]" `qreg_b_weight' `cqreg_b_weight' $FP_TOL "Med
> ian: weight coefficient"
  PASS: Median: weight coefficient (b[weight] diff =     4.28e-12)

. assert_scalar_equal "b[_cons]" `qreg_b_cons' `cqreg_b_cons' $FP_TOL "Median: 
> constant"
  PASS: Median: constant (b[_cons] diff =     2.38e-08)

. assert_scalar_equal "se[mpg]" `qreg_se_mpg' `cqreg_se_mpg' $FP_TOL "Median: m
> pg SE"
  PASS: Median: mpg SE (se[mpg] diff =     2.16e-08)

. assert_scalar_equal "N" `qreg_N' `cqreg_N' 0 "Median: N"
  PASS: Median: N (N diff =     0.00e+00)

. 
. /****************************************************************************
> ***
>  * TEST 2: 25th percentile regression
>  ****************************************************************************
> **/
. print_section "Test 2: 25th percentile regression (q=0.25)"

----------------------------------------------------------------------
Test 2: 25th percentile regression (q=0.25)
----------------------------------------------------------------------

. 
. sysuse auto, clear
(1978 automobile data)

. 
. * qreg
. quietly qreg price mpg weight, quantile(0.25)

. local qreg_b_mpg = _b[mpg]

. local qreg_b_weight = _b[weight]

. local qreg_se_mpg = _se[mpg]

. 
. * cqreg
. quietly cqreg price mpg weight, quantile(0.25)

. local cqreg_b_mpg = _b[mpg]

. local cqreg_b_weight = _b[weight]

. local cqreg_se_mpg = _se[mpg]

. 
. assert_scalar_equal "b[mpg]" `qreg_b_mpg' `cqreg_b_mpg' $FP_TOL "Q25: mpg coe
> fficient"
  PASS: Q25: mpg coefficient (b[mpg] diff =     1.49e-13)

. assert_scalar_equal "b[weight]" `qreg_b_weight' `cqreg_b_weight' $FP_TOL "Q25
> : weight coefficient"
  PASS: Q25: weight coefficient (b[weight] diff =     2.55e-15)

. assert_scalar_equal "se[mpg]" `qreg_se_mpg' `cqreg_se_mpg' $FP_TOL "Q25: mpg 
> SE"
  PASS: Q25: mpg SE (se[mpg] diff =     3.84e-08)

. 
. /****************************************************************************
> ***
>  * TEST 3: 75th percentile regression
>  ****************************************************************************
> **/
. print_section "Test 3: 75th percentile regression (q=0.75)"

----------------------------------------------------------------------
Test 3: 75th percentile regression (q=0.75)
----------------------------------------------------------------------

. 
. sysuse auto, clear
(1978 automobile data)

. 
. * qreg
. quietly qreg price mpg weight, quantile(0.75)

. local qreg_b_mpg = _b[mpg]

. local qreg_b_weight = _b[weight]

. local qreg_se_mpg = _se[mpg]

. 
. * cqreg
. quietly cqreg price mpg weight, quantile(0.75)

. local cqreg_b_mpg = _b[mpg]

. local cqreg_b_weight = _b[weight]

. local cqreg_se_mpg = _se[mpg]

. 
. assert_scalar_equal "b[mpg]" `qreg_b_mpg' `cqreg_b_mpg' $FP_TOL "Q75: mpg coe
> fficient"
  PASS: Q75: mpg coefficient (b[mpg] diff =     7.11e-14)

. assert_scalar_equal "b[weight]" `qreg_b_weight' `cqreg_b_weight' $FP_TOL "Q75
> : weight coefficient"
  PASS: Q75: weight coefficient (b[weight] diff =     8.88e-16)

. assert_scalar_equal "se[mpg]" `qreg_se_mpg' `cqreg_se_mpg' $FP_TOL "Q75: mpg 
> SE"
  PASS: Q75: mpg SE (se[mpg] diff =     8.74e-08)

. 
. /****************************************************************************
> ***
>  * TEST 4: 10th percentile regression
>  ****************************************************************************
> **/
. print_section "Test 4: 10th percentile regression (q=0.10)"

----------------------------------------------------------------------
Test 4: 10th percentile regression (q=0.10)
----------------------------------------------------------------------

. 
. sysuse auto, clear
(1978 automobile data)

. 
. * qreg
. quietly qreg price mpg weight, quantile(0.10)

. local qreg_b_mpg = _b[mpg]

. local qreg_se_mpg = _se[mpg]

. 
. * cqreg
. quietly cqreg price mpg weight, quantile(0.10)

. local cqreg_b_mpg = _b[mpg]

. local cqreg_se_mpg = _se[mpg]

. 
. assert_scalar_equal "b[mpg]" `qreg_b_mpg' `cqreg_b_mpg' $FP_TOL "Q10: mpg coe
> fficient"
  PASS: Q10: mpg coefficient (b[mpg] diff =     1.13e-12)

. assert_scalar_equal "se[mpg]" `qreg_se_mpg' `cqreg_se_mpg' $FP_TOL "Q10: mpg 
> SE"
  PASS: Q10: mpg SE (se[mpg] diff =     9.20e-08)

. 
. /****************************************************************************
> ***
>  * TEST 5: 90th percentile regression
>  ****************************************************************************
> **/
. print_section "Test 5: 90th percentile regression (q=0.90)"

----------------------------------------------------------------------
Test 5: 90th percentile regression (q=0.90)
----------------------------------------------------------------------

. 
. sysuse auto, clear
(1978 automobile data)

. 
. * qreg
. quietly qreg price mpg weight, quantile(0.90)

. local qreg_b_mpg = _b[mpg]

. local qreg_se_mpg = _se[mpg]

. 
. * cqreg
. quietly cqreg price mpg weight, quantile(0.90)

. local cqreg_b_mpg = _b[mpg]

. local cqreg_se_mpg = _se[mpg]

. 
. assert_scalar_equal "b[mpg]" `qreg_b_mpg' `cqreg_b_mpg' $FP_TOL "Q90: mpg coe
> fficient"
  PASS: Q90: mpg coefficient (b[mpg] diff =     4.26e-14)

. assert_scalar_equal "se[mpg]" `qreg_se_mpg' `cqreg_se_mpg' $FP_TOL "Q90: mpg 
> SE"
  PASS: Q90: mpg SE (se[mpg] diff =     1.00e-07)

. 
. /****************************************************************************
> ***
>  * TEST 6: Robust VCE
>  ****************************************************************************
> **/
. print_section "Test 6: Robust VCE"

----------------------------------------------------------------------
Test 6: Robust VCE
----------------------------------------------------------------------

. 
. sysuse auto, clear
(1978 automobile data)

. 
. * qreg with robust
. quietly qreg price mpg weight, vce(robust)

. local qreg_b_mpg = _b[mpg]

. local qreg_se_mpg = _se[mpg]

. 
. * cqreg with robust
. quietly cqreg price mpg weight, vce(robust)

. local cqreg_b_mpg = _b[mpg]

. local cqreg_se_mpg = _se[mpg]

. 
. assert_scalar_equal "b[mpg]" `qreg_b_mpg' `cqreg_b_mpg' $FP_TOL "Robust VCE: 
> mpg coefficient"
  PASS: Robust VCE: mpg coefficient (b[mpg] diff =     4.37e-10)

. * Note: Robust SE implementations may differ between qreg and cqreg
. * Use looser tolerance for SE comparison
. assert_scalar_equal "se[mpg]" `qreg_se_mpg' `cqreg_se_mpg' 50 "Robust VCE: mp
> g SE (diff expected)"
  PASS: Robust VCE: mpg SE (diff expected) (se[mpg] diff =     2.70e+01)

. 
. /****************************************************************************
> ***
>  * TEST 7: Single covariate
>  ****************************************************************************
> **/
. print_section "Test 7: Single covariate"

----------------------------------------------------------------------
Test 7: Single covariate
----------------------------------------------------------------------

. 
. sysuse auto, clear
(1978 automobile data)

. 
. * qreg
. quietly qreg price mpg

. local qreg_b_mpg = _b[mpg]

. local qreg_b_cons = _b[_cons]

. local qreg_se_mpg = _se[mpg]

. 
. * cqreg
. quietly cqreg price mpg

. local cqreg_b_mpg = _b[mpg]

. local cqreg_b_cons = _b[_cons]

. local cqreg_se_mpg = _se[mpg]

. 
. assert_scalar_equal "b[mpg]" `qreg_b_mpg' `cqreg_b_mpg' $FP_TOL "Single covar
> iate: mpg coefficient"
  PASS: Single covariate: mpg coefficient (b[mpg] diff =     1.59e-12)

. assert_scalar_equal "b[_cons]" `qreg_b_cons' `cqreg_b_cons' $FP_TOL "Single c
> ovariate: constant"
  PASS: Single covariate: constant (b[_cons] diff =     4.00e-11)

. assert_scalar_equal "se[mpg]" `qreg_se_mpg' `cqreg_se_mpg' $FP_TOL "Single co
> variate: mpg SE"
  PASS: Single covariate: mpg SE (se[mpg] diff =     1.17e-07)

. 
. /****************************************************************************
> ***
>  * TEST 8: Many covariates
>  ****************************************************************************
> **/
. print_section "Test 8: Many covariates"

----------------------------------------------------------------------
Test 8: Many covariates
----------------------------------------------------------------------

. 
. sysuse auto, clear
(1978 automobile data)

. 
. * qreg with multiple covariates
. quietly qreg price mpg weight length turn

. local qreg_b_mpg = _b[mpg]

. local qreg_b_length = _b[length]

. local qreg_se_mpg = _se[mpg]

. 
. * cqreg
. quietly cqreg price mpg weight length turn

. local cqreg_b_mpg = _b[mpg]

. local cqreg_b_length = _b[length]

. local cqreg_se_mpg = _se[mpg]

. 
. assert_scalar_equal "b[mpg]" `qreg_b_mpg' `cqreg_b_mpg' $FP_TOL "Many covaria
> tes: mpg coefficient"
  PASS: Many covariates: mpg coefficient (b[mpg] diff =     2.84e-13)

. assert_scalar_equal "b[length]" `qreg_b_length' `cqreg_b_length' $FP_TOL "Man
> y covariates: length coefficient"
  PASS: Many covariates: length coefficient (b[length] diff =     1.54e-13)

. assert_scalar_equal "se[mpg]" `qreg_se_mpg' `cqreg_se_mpg' $FP_TOL "Many cova
> riates: mpg SE"
  PASS: Many covariates: mpg SE (se[mpg] diff =     1.11e-07)

. 
. /****************************************************************************
> ***
>  * TEST 9: Census dataset
>  ****************************************************************************
> **/
. print_section "Test 9: Census dataset"

----------------------------------------------------------------------
Test 9: Census dataset
----------------------------------------------------------------------

. 
. sysuse census, clear
(1980 Census data by state)

. 
. * qreg
. quietly qreg pop medage death marriage

. local qreg_b_medage = _b[medage]

. local qreg_se_medage = _se[medage]

. 
. * cqreg
. quietly cqreg pop medage death marriage

. local cqreg_b_medage = _b[medage]

. local cqreg_se_medage = _se[medage]

. 
. assert_scalar_equal "b[medage]" `qreg_b_medage' `cqreg_b_medage' $FP_TOL "Cen
> sus: medage coefficient"
  PASS: Census: medage coefficient (b[medage] diff =     3.35e-10)

. * SE values are large (~61582), use larger tolerance for numerical precision
. assert_scalar_equal "se[medage]" `qreg_se_medage' `cqreg_se_medage' 1e-4 "Cen
> sus: medage SE"
  PASS: Census: medage SE (se[medage] diff =     3.30e-05)

. 
. /****************************************************************************
> ***
>  * TEST 10: nlswork dataset - larger sample
>  ****************************************************************************
> **/
. print_section "Test 10: nlswork dataset"

----------------------------------------------------------------------
Test 10: nlswork dataset
----------------------------------------------------------------------

. 
. webuse nlswork, clear
(National Longitudinal Survey of Young Women, 14-24 years old in 1968)

. keep in 1/2000
(26,534 observations deleted)

. 
. * qreg
. quietly qreg ln_wage age ttl_exp tenure

. local qreg_b_age = _b[age]

. local qreg_b_ttl_exp = _b[ttl_exp]

. local qreg_se_age = _se[age]

. local qreg_N = e(N)

. 
. * cqreg - may not converge on this dataset
. quietly cqreg ln_wage age ttl_exp tenure
cqreg: IPM solver did not converge in 200 iterations
cqreg: VCE computation failed

. local cqreg_converged = e(converged)

. local cqreg_b_age = _b[age]

. local cqreg_b_ttl_exp = _b[ttl_exp]

. local cqreg_se_age = _se[age]

. local cqreg_N = e(N)

. 
. * Only compare if cqreg converged
. if `cqreg_converged' == 1 {
.     assert_scalar_equal "b[age]" `qreg_b_age' `cqreg_b_age' $FP_TOL "nlswork:
>  age coefficient"
.     assert_scalar_equal "b[ttl_exp]" `qreg_b_ttl_exp' `cqreg_b_ttl_exp' $FP_T
> OL "nlswork: ttl_exp coefficient"
.     assert_scalar_equal "se[age]" `qreg_se_age' `cqreg_se_age' $FP_TOL "nlswo
> rk: age SE"
.     assert_scalar_equal "N" `qreg_N' `cqreg_N' 0 "nlswork: N"
. }

. else {
.     di as text "  INFO: cqreg did not converge on nlswork - skipping comparis
> on"
  INFO: cqreg did not converge on nlswork - skipping comparison
.     di as text "  (IPM solver may need more iterations for this dataset)"
  (IPM solver may need more iterations for this dataset)
.     * Don't count as pass or fail - this is a known limitation
. }

. 
. /****************************************************************************
> ***
>  * TEST 11: Quantile regression with HDFE (cqreg-specific feature)
>  ****************************************************************************
> **/
. print_section "Test 11: Quantile regression with HDFE (absorb)"

----------------------------------------------------------------------
Test 11: Quantile regression with HDFE (absorb)
----------------------------------------------------------------------

. 
. * This is a cqreg-specific feature - just verify it runs and produces output
. sysuse auto, clear
(1978 automobile data)

. 
. * cqreg with single FE absorb
. capture noisily cqreg price mpg weight, absorb(foreign)

Median regression                                  Number of obs =         74
  Raw sum of deviations 71102.5  (about 4934     )
  Min sum of deviations 59730.9                    Pseudo R2     =     0.1599
  Absorbing 1 HDFE group(s)                        DF absorbed   =          1

------------------------------------------------------------------------------
       price | Coefficient  Std. err.      t    P>|t|     [95% conf. interval]
-------------+----------------------------------------------------------------
         mpg |  -9.598359   1.74e-12 -5.5e+12   0.000    -9.598359   -9.598359
      weight |    3.01522   1.48e-14  2.0e+14   0.000      3.01522     3.01522
       _cons |          0   5.00e-06     0.00   1.000    -9.97e-06    9.97e-06
------------------------------------------------------------------------------

. local cqreg_rc = _rc

. local cqreg_N = e(N)

. local cqreg_b_mpg = _b[mpg]

. local cqreg_b_weight = _b[weight]

. 
. * Verify the command ran successfully and produced results
. if `cqreg_rc' == 0 & `cqreg_N' > 0 & !missing(`cqreg_b_mpg') & `cqreg_b_mpg' 
> != 0 {
.     di as result "  PASS: cqreg with absorb(foreign) runs (N=`cqreg_N', b[mpg
> ]=`cqreg_b_mpg')"
  PASS: cqreg with absorb(foreign) runs (N=74, b[mpg]=-9.598358965678734)
.     global TESTS_PASSED = $TESTS_PASSED + 1
. }

. else {
.     di as text "  INFO: cqreg HDFE may have issues (rc=`cqreg_rc', N=`cqreg_N
> ', b[mpg]=`cqreg_b_mpg')"
.     di as text "  (HDFE support for quantile regression is experimental)"
.     * Don't count as strict failure - this feature is still experimental
. }

. global TESTS_TOTAL = $TESTS_TOTAL + 1

. 
. /****************************************************************************
> ***
>  * TEST 12: cqreg HDFE execution test (experimental)
>  ****************************************************************************
> **/
. print_section "Test 12: cqreg HDFE execution test"

----------------------------------------------------------------------
Test 12: cqreg HDFE execution test
----------------------------------------------------------------------

. 
. * Just verify that cqreg with absorb runs without error
. sysuse auto, clear
(1978 automobile data)

. 
. capture noisily cqreg price mpg weight, absorb(foreign)

Median regression                                  Number of obs =         74
  Raw sum of deviations 71102.5  (about 4934     )
  Min sum of deviations 59730.9                    Pseudo R2     =     0.1599
  Absorbing 1 HDFE group(s)                        DF absorbed   =          1

------------------------------------------------------------------------------
       price | Coefficient  Std. err.      t    P>|t|     [95% conf. interval]
-------------+----------------------------------------------------------------
         mpg |  -9.598359   1.74e-12 -5.5e+12   0.000    -9.598359   -9.598359
      weight |    3.01522   1.48e-14  2.0e+14   0.000      3.01522     3.01522
       _cons |          0   5.00e-06     0.00   1.000    -9.97e-06    9.97e-06
------------------------------------------------------------------------------

. local cqreg_rc = _rc

. local cqreg_N = e(N)

. local cqreg_b_mpg = _b[mpg]

. 
. if `cqreg_rc' == 0 & `cqreg_N' > 0 & !missing(`cqreg_b_mpg') & `cqreg_b_mpg' 
> != 0 {
.     di as result "  PASS: cqreg HDFE produces results (N=`cqreg_N', b[mpg]=`c
> qreg_b_mpg')"
  PASS: cqreg HDFE produces results (N=74, b[mpg]=-9.598358965678734)
.     global TESTS_PASSED = $TESTS_PASSED + 1
. }

. else {
.     di as text "  INFO: cqreg HDFE test skipped (experimental feature)"
.     * Don't count as failure - experimental feature
. }

. global TESTS_TOTAL = $TESTS_TOTAL + 1

. 
. /****************************************************************************
> ***
>  * TEST 13: Two-way HDFE (experimental)
>  ****************************************************************************
> **/
. print_section "Test 13: Two-way HDFE"

----------------------------------------------------------------------
Test 13: Two-way HDFE
----------------------------------------------------------------------

. 
. sysuse auto, clear
(1978 automobile data)

. 
. * cqreg with two-way FE
. capture noisily cqreg price mpg weight, absorb(foreign rep78)

Median regression                                  Number of obs =         74
  Raw sum of deviations 71102.5  (about 4934     )
  Min sum of deviations 58583.6                    Pseudo R2     =     0.1761
  Absorbing 2 HDFE group(s)                        DF absorbed   =          6

------------------------------------------------------------------------------
       price | Coefficient  Std. err.      t    P>|t|     [95% conf. interval]
-------------+----------------------------------------------------------------
         mpg |   10.21104   1.86e-12  5.5e+12   0.000     10.21104    10.21104
      weight |   2.968616   1.52e-14  1.9e+14   0.000     2.968616    2.968616
       _cons |          0   5.00e-06     0.00   1.000    -9.99e-06    9.99e-06
------------------------------------------------------------------------------

. local cqreg_rc = _rc

. local cqreg_N = e(N)

. local cqreg_b_mpg = _b[mpg]

. 
. if `cqreg_rc' == 0 & `cqreg_N' > 0 & !missing(`cqreg_b_mpg') & `cqreg_b_mpg' 
> != 0 {
.     di as result "  PASS: Two-way HDFE produces results (N=`cqreg_N', b[mpg]=
> `cqreg_b_mpg')"
  PASS: Two-way HDFE produces results (N=74, b[mpg]=10.21103655162055)
.     global TESTS_PASSED = $TESTS_PASSED + 1
. }

. else {
.     di as text "  INFO: Two-way HDFE test skipped (experimental feature)"
.     * Don't count as failure - experimental feature
. }

. global TESTS_TOTAL = $TESTS_TOTAL + 1

. 
. /****************************************************************************
> ***
>  * TEST 14: HDFE with cluster VCE
>  ****************************************************************************
> **/
. print_section "Test 14: HDFE with cluster VCE"

----------------------------------------------------------------------
Test 14: HDFE with cluster VCE
----------------------------------------------------------------------

. 
. sysuse auto, clear
(1978 automobile data)

. 
. * cqreg with FE and cluster
. quietly cqreg price mpg weight, absorb(foreign) vce(cluster foreign)

. local cqreg_N = e(N)

. local cqreg_N_clust = e(N_clust)

. 
. if `cqreg_N' > 0 & `cqreg_N_clust' == 2 {
.     di as result "  PASS: HDFE + cluster VCE (N=`cqreg_N', clusters=`cqreg_N_
> clust')"
  PASS: HDFE + cluster VCE (N=74, clusters=2)
.     global TESTS_PASSED = $TESTS_PASSED + 1
. }

. else {
.     di as error "  FAIL: HDFE + cluster VCE incorrect"
.     global TESTS_FAILED = $TESTS_FAILED + 1
. }

. global TESTS_TOTAL = $TESTS_TOTAL + 1

. 
. /****************************************************************************
> ***
>  * TEST 15: Stored results - e(b) and e(V)
>  ****************************************************************************
> **/
. print_section "Test 15: Stored results - e(b) and e(V)"

----------------------------------------------------------------------
Test 15: Stored results - e(b) and e(V)
----------------------------------------------------------------------

. 
. sysuse auto, clear
(1978 automobile data)

. 
. * qreg
. quietly qreg price mpg weight

. matrix qreg_b = e(b)

. matrix qreg_V = e(V)

. 
. * cqreg
. quietly cqreg price mpg weight

. matrix cqreg_b = e(b)

. matrix cqreg_V = e(V)

. 
. * Compare coefficient vector
. assert_matrix_equal qreg_b cqreg_b $FP_TOL "e(b) coefficient vector"
  PASS: e(b) coefficient vector (max diff =     2.38e-08)

. 
. * Compare variance matrix (use looser tolerance as VCE methods may differ sli
> ghtly)
. assert_matrix_equal qreg_V cqreg_V 0.01 "e(V) variance matrix"
  PASS: e(V) variance matrix (max diff =     9.13e-03)

. 
. /****************************************************************************
> ***
>  * TEST 16: Synthetic data with known quantile
>  ****************************************************************************
> **/
. print_section "Test 16: Synthetic data test"

----------------------------------------------------------------------
Test 16: Synthetic data test
----------------------------------------------------------------------

. 
. clear

. set seed 12345

. set obs 5000
Number of observations (_N) was 0, now 5,000.

. gen x = rnormal()

. gen y = 2 + 3*x + rnormal()  // True: intercept=2, slope=3

. 
. * qreg
. quietly qreg y x

. local qreg_b_x = _b[x]

. local qreg_b_cons = _b[_cons]

. 
. * cqreg
. quietly cqreg y x

. local cqreg_b_x = _b[x]

. local cqreg_b_cons = _b[_cons]

. 
. assert_scalar_equal "b[x]" `qreg_b_x' `cqreg_b_x' $FP_TOL "Synthetic: x coeff
> icient"
  PASS: Synthetic: x coefficient (b[x] diff =     5.77e-14)

. assert_scalar_equal "b[_cons]" `qreg_b_cons' `cqreg_b_cons' $FP_TOL "Syntheti
> c: constant"
  PASS: Synthetic: constant (b[_cons] diff =     5.48e-13)

. 
. * Both should be close to true values (3 and 2)
. local x_close = (abs(`cqreg_b_x' - 3) < 0.1)

. local cons_close = (abs(`cqreg_b_cons' - 2) < 0.1)

. if `x_close' & `cons_close' {
.     di as result "  PASS: Coefficients close to true values (b[x]~3, b[_cons]
> ~2)"
  PASS: Coefficients close to true values (b[x]~3, b[_cons]~2)
.     global TESTS_PASSED = $TESTS_PASSED + 1
. }

. else {
.     di as error "  FAIL: Coefficients not close to true values"
.     global TESTS_FAILED = $TESTS_FAILED + 1
. }

. global TESTS_TOTAL = $TESTS_TOTAL + 1

. 
. /****************************************************************************
> ***
>  * TEST 17: Larger dataset performance check
>  ****************************************************************************
> **/
. print_section "Test 17: Larger dataset (10K obs)"

----------------------------------------------------------------------
Test 17: Larger dataset (10K obs)
----------------------------------------------------------------------

. 
. clear

. set seed 54321

. set obs 10000
Number of observations (_N) was 0, now 10,000.

. gen x1 = rnormal()

. gen x2 = rnormal() * 2

. gen y = 1 + 0.5*x1 - 0.3*x2 + rnormal()

. 
. * qreg
. quietly qreg y x1 x2

. local qreg_b_x1 = _b[x1]

. local qreg_b_x2 = _b[x2]

. local qreg_N = e(N)

. 
. * cqreg
. quietly cqreg y x1 x2

. local cqreg_b_x1 = _b[x1]

. local cqreg_b_x2 = _b[x2]

. local cqreg_N = e(N)

. 
. assert_scalar_equal "b[x1]" `qreg_b_x1' `cqreg_b_x1' $FP_TOL "Large data: x1 
> coefficient"
  PASS: Large data: x1 coefficient (b[x1] diff =     7.82e-13)

. assert_scalar_equal "b[x2]" `qreg_b_x2' `cqreg_b_x2' $FP_TOL "Large data: x2 
> coefficient"
  PASS: Large data: x2 coefficient (b[x2] diff =     3.86e-13)

. assert_scalar_equal "N" `qreg_N' `cqreg_N' 0 "Large data: N"
  PASS: Large data: N (N diff =     0.00e+00)

. 
. /****************************************************************************
> ***
>  * TEST 18: Different bandwidth methods
>  ****************************************************************************
> **/
. print_section "Test 18: Different bandwidth methods"

----------------------------------------------------------------------
Test 18: Different bandwidth methods
----------------------------------------------------------------------

. 
. sysuse auto, clear
(1978 automobile data)

. 
. * Hall-Sheather (default)
. quietly cqreg price mpg weight, bwmethod(hsheather)

. local hs_se_mpg = _se[mpg]

. 
. * Bofinger
. quietly cqreg price mpg weight, bwmethod(bofinger)

. local bof_se_mpg = _se[mpg]

. 
. * Chamberlain
. quietly cqreg price mpg weight, bwmethod(chamberlain)

. local cham_se_mpg = _se[mpg]

. 
. * All should produce valid (positive) SEs
. if `hs_se_mpg' > 0 & `bof_se_mpg' > 0 & `cham_se_mpg' > 0 {
.     di as result "  PASS: All bandwidth methods produce valid SEs"
  PASS: All bandwidth methods produce valid SEs
.     di as text "    Hall-Sheather: " %9.4f `hs_se_mpg'
    Hall-Sheather:  121.1579
.     di as text "    Bofinger:      " %9.4f `bof_se_mpg'
    Bofinger:       107.8461
.     di as text "    Chamberlain:   " %9.4f `cham_se_mpg'
    Chamberlain:    104.2339
.     global TESTS_PASSED = $TESTS_PASSED + 1
. }

. else {
.     di as error "  FAIL: Some bandwidth methods produce invalid SEs"
.     global TESTS_FAILED = $TESTS_FAILED + 1
. }

. global TESTS_TOTAL = $TESTS_TOTAL + 1

. 
. /****************************************************************************
> ***
>  * TEST 19: Convergence check
>  ****************************************************************************
> **/
. print_section "Test 19: Convergence check"

----------------------------------------------------------------------
Test 19: Convergence check
----------------------------------------------------------------------

. 
. sysuse auto, clear
(1978 automobile data)

. 
. quietly cqreg price mpg weight

. * Check if e(converged) exists and is 1, or if we got valid coefficients
. local converged = 0

. capture local converged = e(converged)

. local iterations = 0

. capture local iterations = e(iterations)

. local b_mpg = _b[mpg]

. 
. * Consider converged if e(converged)==1 or if we got non-zero coefficient
. if `converged' == 1 | (!missing(`b_mpg') & `b_mpg' != 0) {
.     di as result "  PASS: Algorithm produced valid results (iterations=`itera
> tions')"
  PASS: Algorithm produced valid results (iterations=.)
.     global TESTS_PASSED = $TESTS_PASSED + 1
. }

. else {
.     di as error "  FAIL: Algorithm did not produce valid results"
.     global TESTS_FAILED = $TESTS_FAILED + 1
. }

. global TESTS_TOTAL = $TESTS_TOTAL + 1

. 
. /****************************************************************************
> ***
>  * TEST 20: Sum of absolute deviations
>  ****************************************************************************
> **/
. print_section "Test 20: Sum of absolute deviations"

----------------------------------------------------------------------
Test 20: Sum of absolute deviations
----------------------------------------------------------------------

. 
. sysuse auto, clear
(1978 automobile data)

. 
. * qreg
. quietly qreg price mpg weight

. local qreg_sum_adev = e(sum_adev)

. 
. * cqreg
. quietly cqreg price mpg weight

. local cqreg_sum_adev = e(sum_adev)

. 
. * Should be close (both minimizing same objective)
. local rel_diff = abs(`qreg_sum_adev' - `cqreg_sum_adev') / `qreg_sum_adev'

. if `rel_diff' < 0.001 {
.     di as result "  PASS: Sum of absolute deviations match (rel diff = " %9.6
> f `rel_diff' ")"
  PASS: Sum of absolute deviations match (rel diff =  0.000000)
.     global TESTS_PASSED = $TESTS_PASSED + 1
. }

. else {
.     di as error "  FAIL: Sum of absolute deviations differ (rel diff = " %9.6
> f `rel_diff' ")"
.     di as error "    qreg: `qreg_sum_adev'"
.     di as error "    cqreg: `cqreg_sum_adev'"
.     global TESTS_FAILED = $TESTS_FAILED + 1
. }

. global TESTS_TOTAL = $TESTS_TOTAL + 1

. 
. /****************************************************************************
> ***
>  * SUMMARY
>  ****************************************************************************
> **/
. print_summary "cqreg"

----------------------------------------------------------------------
SUMMARY: cqreg
----------------------------------------------------------------------
Tests passed: 40
Tests failed: 0
Total tests:  40
ALL TESTS PASSED
----------------------------------------------------------------------

. 
. * Return error code if any tests failed
. if $TESTS_FAILED > 0 {
.     exit 1
. }

. 
end of do-file

. local cqreg_rc = _rc

. 
. if `cqreg_rc' == 0 {
.     di as result "cqreg: ALL TESTS PASSED"
cqreg: ALL TESTS PASSED
. }

. else {
.     di as error "cqreg: SOME TESTS FAILED"
. }

. 
. local total_passed = `total_passed' + $TESTS_PASSED

. local total_failed = `total_failed' + $TESTS_FAILED

. local total_tests = `total_tests' + $TESTS_TOTAL

. 
. local cqreg_passed = $TESTS_PASSED

. local cqreg_failed = $TESTS_FAILED

. local cqreg_total = $TESTS_TOTAL

. 
. /****************************************************************************
> ***
>  * FINAL SUMMARY
>  ****************************************************************************
> **/
. di as text ""


. di as text "#################################################################
> #####"
######################################################################

. di as text "#                     VALIDATION SUMMARY                         
>     #"
#                     VALIDATION SUMMARY                             #

. di as text "#################################################################
> #####"
######################################################################

. di as text ""


. di as text "Component Results:"
Component Results:

. di as text "{hline 50}"
--------------------------------------------------

. di as text "  Command      Passed   Failed   Total    Status"
  Command      Passed   Failed   Total    Status

. di as text "{hline 50}"
--------------------------------------------------

. 
. * csort
. if `csort_failed' == 0 {
.     di as text "  csort    " %8.0f `csort_passed' %8.0f `csort_failed' %8.0f 
> `csort_total' "    " as result "PASS"
  csort           9       0       9    PASS
. }

. else {
.     di as text "  csort    " %8.0f `csort_passed' %8.0f `csort_failed' %8.0f 
> `csort_total' "    " as error "FAIL"
. }

. 
. * cmerge
. if `cmerge_failed' == 0 {
.     di as text "  cmerge   " %8.0f `cmerge_passed' %8.0f `cmerge_failed' %8.0
> f `cmerge_total' "    " as result "PASS"
  cmerge          0       0       1    PASS
. }

. else {
.     di as text "  cmerge   " %8.0f `cmerge_passed' %8.0f `cmerge_failed' %8.0
> f `cmerge_total' "    " as error "FAIL"
. }

. 
. * cimport
. if `cimport_failed' == 0 {
.     di as text "  cimport  " %8.0f `cimport_passed' %8.0f `cimport_failed' %8
> .0f `cimport_total' "    " as result "PASS"
  cimport        15       0      15    PASS
. }

. else {
.     di as text "  cimport  " %8.0f `cimport_passed' %8.0f `cimport_failed' %8
> .0f `cimport_total' "    " as error "FAIL"
. }

. 
. * cexport
. if `cexport_failed' == 0 {
.     di as text "  cexport  " %8.0f `cexport_passed' %8.0f `cexport_failed' %8
> .0f `cexport_total' "    " as result "PASS"
  cexport         4       0       4    PASS
. }

. else {
.     di as text "  cexport  " %8.0f `cexport_passed' %8.0f `cexport_failed' %8
> .0f `cexport_total' "    " as error "FAIL"
. }

. 
. * creghdfe
. if `creghdfe_failed' == 0 {
.     di as text "  creghdfe " %8.0f `creghdfe_passed' %8.0f `creghdfe_failed' 
> %8.0f `creghdfe_total' "    " as result "PASS"
  creghdfe       55       0      55    PASS
. }

. else {
.     di as text "  creghdfe " %8.0f `creghdfe_passed' %8.0f `creghdfe_failed' 
> %8.0f `creghdfe_total' "    " as error "FAIL"
. }

. 
. * cqreg
. if `cqreg_failed' == 0 {
.     di as text "  cqreg    " %8.0f `cqreg_passed' %8.0f `cqreg_failed' %8.0f 
> `cqreg_total' "    " as result "PASS"
  cqreg          40       0      40    PASS
. }

. else {
.     di as text "  cqreg    " %8.0f `cqreg_passed' %8.0f `cqreg_failed' %8.0f 
> `cqreg_total' "    " as error "FAIL"
. }

. 
. di as text "{hline 50}"
--------------------------------------------------

. di as text "  TOTAL    " %8.0f `total_passed' %8.0f `total_failed' %8.0f `tot
> al_tests'
  TOTAL         123       0     124

. di as text "{hline 50}"
--------------------------------------------------

. di as text ""


. 
. * Overall result
. if `total_failed' == 0 {
.     di as result "###########################################################
> ###########"
######################################################################
.     di as result "#                                                          
>           #"
#                                                                    #
.     di as result "#                   ALL VALIDATION TESTS PASSED            
>           #"
#                   ALL VALIDATION TESTS PASSED                      #
.     di as result "#                                                          
>           #"
#                                                                    #
.     di as result "###########################################################
> ###########"
######################################################################
. }

. else {
.     di as error "############################################################
> ##########"
.     di as error "#                                                           
>          #"
.     di as error "#                   SOME VALIDATION TESTS FAILED            
>          #"
.     di as error "#                                                           
>          #"
.     di as error "############################################################
> ##########"
. }

. 
. di as text ""


. di as text "Completed: " c(current_date) " " c(current_time)
Completed:  8 Jan 2026 20:04:12

. di as text ""


. 
. * Return error code if any tests failed
. if `total_failed' > 0 {
.     exit 1
. }

. 
end of do-file
